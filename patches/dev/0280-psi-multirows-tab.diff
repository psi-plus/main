--- a/iconsets.qrc
+++ b/iconsets.qrc
@@ -139,6 +139,7 @@
         <file>iconsets/system/default/psiplus/draw.png</file>
         <file>iconsets/system/default/psiplus/frame.png</file>
         <file>iconsets/system/default/psiplus/palette.png</file>
+        <file>iconsets/system/default/psiplus/pin.png</file>
         <file>iconsets/system/default/psiplus/undo.png</file>
         <file>iconsets/system/default/psiplus/print.png</file>
         <file>iconsets/system/default/whiteboarding/whiteboard.png</file>
--- a/iconsets/system/default/icondef.xml
+++ b/iconsets/system/default/icondef.xml
@@ -731,6 +731,11 @@
 		<x xmlns='name'>psi/doubleBackArrow</x>
 		<object mime='image/png'>psiplus/doublebackarrow.png</object>
 	</icon>
+
+	<icon>
+		<x xmlns='name'>psi/pin</x>
+		<object mime='image/png'>psiplus/pin.png</object>
+	</icon>
 	<!-- End psi Plus icons -->
 
 	<!-- Icons for screenshot-plugin -->
--- a/options/default.xml
+++ b/options/default.xml
@@ -514,6 +514,9 @@ QLineEdit#le_status_text {
 				<tab-singles type="QString" comment="Tab types that would have been untabbed are given their own tabset. 'C' for chat and 'M' for mucs"/>
 				<use-tab-shortcuts type="bool">true</use-tab-shortcuts>
 				<show-tab-buttons type="bool">true</show-tab-buttons>
+				<multi-rows comment="Use multi rows mode for chat tab bar" type="bool">true</multi-rows>
+				<current-index-at-bottom comment="Move current row to bottom in multi-row mode" type="bool">true</current-index-at-bottom>
+				<disable-wheel-scroll type="bool">false</disable-wheel-scroll>
 			</tabs>
 		</ui>
 		<shortcuts comment="Shortcuts">
@@ -581,8 +584,10 @@ QLineEdit#le_status_text {
 				<chat_icon type="QKeySequence"></chat_icon>
 				<chat_info type="QKeySequence"></chat_info>
 				<chat_pgp type="QKeySequence"></chat_pgp>
+				<chat_pin_tab type="QKeySequence"></chat_pin_tab>
 				<chat_ps type="QKeySequence"></chat_ps>
 				<chat_templates type="QKeySequence"></chat_templates>
+				<chat_unpin_tab type="QKeySequence"></chat_unpin_tab>
 				<chat_voice type="QKeySequence"></chat_voice>
 				<gchat_clear type="QKeySequence"></gchat_clear>
 				<gchat_configure type="QKeySequence"></gchat_configure>
@@ -591,6 +596,8 @@ QLineEdit#le_status_text {
 				<gchat_icon type="QKeySequence"></gchat_icon>
 				<gchat_ps type="QKeySequence"></gchat_ps>
 				<gchat_templates type="QKeySequence"></gchat_templates>
+				<gchat_pin_tab type="QKeySequence"></gchat_pin_tab>
+				<gchat_unpin_tab type="QKeySequence"></gchat_unpin_tab>
 			</alist>
 			<chat comment="Shortcuts in the chat dialog">
 				<next-tab type="QVariantList" comment="Switch to the next tab">
--- a/src/groupchatdlg.cpp
+++ b/src/groupchatdlg.cpp
@@ -94,6 +94,7 @@
 #include "mcmdsimplesite.h"
 #include "tabcompletion.h"
 #include "vcardfactory.h"
+#include "tabdlg.h"
 
 #ifdef Q_OS_WIN
 #include <windows.h>
@@ -777,6 +778,9 @@ GCMainDlg::GCMainDlg(PsiAccount *pa, const Jid &j, TabManager *tabManager)
 		else if (name == "gchat_info") {
 			connect(action, SIGNAL(triggered()), SLOT(doInfo()));
 		}
+		else if (name == "gchat_pin_tab" || name == "gchat_unpin_tab") {
+			connect(action, SIGNAL(triggered()), SLOT(pinTab()));
+		}
 	}
 
 	actList = account()->psi()->actionList()->actionLists(PsiActionList::Actions_Common).at(0);
@@ -2250,6 +2254,13 @@ void GCMainDlg::buildMenu()
 	d->pm_settings->addAction(d->actions->action("gchat_icon"));
 	d->pm_settings->addAction(d->act_nick);
 	d->pm_settings->addAction(d->act_bookmark);
+	if (PsiOptions::instance()->getOption("options.ui.tabs.multi-rows").toBool()) {
+		d->pm_settings->addSeparator();
+		if (getManagingTabDlg()->isTabPinned(this))
+			d->pm_settings->addAction(d->actions->action("gchat_unpin_tab"));
+		else
+			d->pm_settings->addAction(d->actions->action("gchat_pin_tab"));
+	}
 #ifdef PSI_PLUGINS
 	if(!PsiOptions::instance()->getOption("options.ui.contactlist.toolbars.m1.visible").toBool()) {
 		d->pm_settings->addSeparator();
--- a/src/psiactionlist.cpp
+++ b/src/psiactionlist.cpp
@@ -461,6 +461,8 @@ void PsiActionList::Private::createChat()
 		IconAction *actHistory = new IconAction(tr("Message History"), "psi/history", tr("Message History"), 0, this);
 		IconAction *actCompact = new IconAction(tr("Toggle Compact/Full Size"), "psi/compact", tr("Toggle Compact/Full Size"), 0, this);
 		IconAction *actActiveContacts = new IconAction (tr("Active contacts"), "psi/jabber", tr("Active contacts"), 0, this);
+		IconAction *actPinTab = new IconAction(tr("Pin Tab"), "psi/pin", tr("Pin Tab"), 0 , this);
+		IconAction *actUnpinTab = new IconAction(tr("Unpin Tab"), "psi/pin", tr("Unpin Tab"), 0 , this);
 
 		ActionNames actions[] = {
 			{ "chat_clear",  actClear  },
@@ -475,6 +477,8 @@ void PsiActionList::Private::createChat()
 			{ "chat_history", actHistory   },
 			{ "chat_compact", actCompact   },
 			{ "chat_active_contacts", actActiveContacts   },
+			{ "chat_pin_tab", actPinTab },
+			{ "chat_unpin_tab", actUnpinTab },
 			{ "", 0 }
 		};
 
@@ -492,6 +496,8 @@ void PsiActionList::Private::createGroupchat()
 		IconAction *actHtmlText = new IconAction(tr("Set Text Format"), "psi/text", tr("Set Text Format"), 0, this);
 		IconAction *actConfigure = new IconAction(tr("Configure Room"), "psi/configure-room", tr("Configure Room"), 0, this);
 		IconAction *actIcon = new IconAction(tr("Select Icon"), "psi/smile", tr("Select Icon"), 0, this);
+		IconAction *actPinTab = new IconAction(tr("Pin Tab"), "psi/pin", tr("Pin Tab"), 0 , this);
+		IconAction *actUnpinTab = new IconAction(tr("Unpin Tab"), "psi/pin", tr("Unpin Tab"), 0 , this);
 
 		ActionNames actions[] = {
 			{ "gchat_clear",  actClear  },
@@ -499,6 +505,8 @@ void PsiActionList::Private::createGroupchat()
 			{ "gchat_html_text", actHtmlText   },
 			{ "gchat_configure", actConfigure   },
 			{ "gchat_icon", actIcon   },
+			{ "gchat_pin_tab", actPinTab },
+			{ "gchat_unpin_tab", actUnpinTab },
 			{ "", 0 }
 		};
 
--- a/src/psichatdlg.cpp
+++ b/src/psichatdlg.cpp
@@ -49,6 +49,7 @@
 #include "avcall/avcall.h"
 #include "actionlist.h"
 #include "psiactionlist.h"
+#include "tabdlg.h"
 #ifdef PSI_PLUGINS
 #include "pluginmanager.h"
 #endif
@@ -529,6 +530,9 @@ void PsiChatDlg::initToolButtons()
 		else if (name == "chat_active_contacts") {
 			connect(action, SIGNAL(triggered()), SLOT(actActiveContacts()));
 		}
+		else if (name == "chat_pin_tab" || name == "chat_unpin_tab") {
+			connect(action, SIGNAL(triggered()), SLOT(pinTab()));
+		}
 	}
 
 	list = account()->psi()->actionList()->actionLists(PsiActionList::Actions_Common).at(0);
@@ -905,6 +909,12 @@ void PsiChatDlg::buildMenu()
 
 	pm_settings_->addAction(actions_->action("chat_info"));
 	pm_settings_->addAction(actions_->action("chat_history"));
+    auto dlg = getManagingTabDlg();
+    if (dlg) {
+        pm_settings_->addAction(actions_->action(dlg->isTabPinned(this)?
+                                                     "chat_unpin_tab":
+                                                     "chat_pin_tab"));
+    } // else it's not tabbed dialog
 #ifdef PSI_PLUGINS
 	if(!PsiOptions::instance()->getOption("options.ui.contactlist.toolbars.m0.visible").toBool()) {
 		pm_settings_->addSeparator();
--- a/src/tabs/tabbablewidget.cpp
+++ b/src/tabs/tabbablewidget.cpp
@@ -252,3 +252,8 @@ void TabbableWidget::hideTab()
 	else
 		hide();
 }
+
+void TabbableWidget::pinTab()
+{
+	getManagingTabDlg()->pinTab(this);
+}
--- a/src/tabs/tabbablewidget.h
+++ b/src/tabs/tabbablewidget.h
@@ -81,6 +81,7 @@ public slots:
 	void bringToFront(bool raiseWindow = true);
 	virtual void ensureTabbedCorrectly();
 	void hideTab();
+	void pinTab();
 
 protected:
 	virtual void setJid(const Jid&);
--- a/src/tabs/tabdlg.cpp
+++ b/src/tabs/tabdlg.cpp
@@ -291,6 +291,11 @@ void TabDlg::showTabMenu(int tab, QPoint pos, QContextMenuEvent * event)
 			tabMenu_->addMenu(sendTo);
 		}
 
+		QAction *p = 0;
+		if (PsiOptions::instance()->getOption("options.ui.tabs.multi-rows", true).toBool()) {
+			p = tabMenu_->addAction(tabWidget_->isPagePinned(getTab(tab)) ? tr("Unpin Tab") : tr("Pin Tab"));
+		}
+
 		QAction *act = tabMenu_->exec(pos);
 		if (!act)
 			return;
@@ -303,6 +308,9 @@ void TabDlg::showTabMenu(int tab, QPoint pos, QContextMenuEvent * event)
 		else if(act == h) {
 			hideTab(getTab(tab));
 		}
+		else if (p && act == p) {
+			pinTab(getTab(tab));
+		}
 		else {
 			TabDlg* target = sentTos[act];
 			if (target)
@@ -448,6 +456,11 @@ void TabDlg::hideTab(TabbableWidget* tab)
 	closeTab(tab, false);
 }
 
+void TabDlg::pinTab(TabbableWidget* tab)
+{
+	tabWidget_->setPagePinned(tab, !tabWidget_->isPagePinned(tab));
+}
+
 void TabDlg::hideAllTab()
 {
 	foreach(TabbableWidget* tab, tabs_)
@@ -924,6 +937,11 @@ void TabDlg::updateVSplitters(int log, int chat)
 	}
 }
 
+bool TabDlg::isTabPinned(QWidget *page)
+{
+	return tabWidget_->isPagePinned(page);
+}
+
 TabbableWidget* TabDlg::getCurrentTab() const
 {
 	return dynamic_cast<TabbableWidget*>(tabWidget_->currentPage());
--- a/src/tabs/tabdlg.h
+++ b/src/tabs/tabdlg.h
@@ -90,6 +90,8 @@ public:
 	void setTabIcon(QWidget *,const QIcon &);
 	TabbableWidget* getCurrentTab() const;
 
+	bool isTabPinned(QWidget *page);
+
 protected:
 	void setShortcuts();
 
@@ -125,6 +127,7 @@ public slots:
 	void sendTabTo(TabbableWidget*, TabDlg *);
 	void tabCloseRequested(int i);
 	void hideTab(TabbableWidget*);
+	void pinTab(TabbableWidget *tab);
 	void hideCurrentTab();
 	void hideAllTab();
 
--- a/src/widgets/psitabbar.cpp
+++ b/src/widgets/psitabbar.cpp
@@ -22,7 +22,6 @@
 #include "psitabwidget.h"
 #include <QMouseEvent>
 #include <QApplication>
-#include <QDrag>
 #include <QMimeData>
 #include <QPainter>
 
@@ -32,14 +31,13 @@
  * Constructor
  */
 PsiTabBar::PsiTabBar(PsiTabWidget *parent)
-		: QTabBar(parent)
-		, dragsEnabled_(true) {
+		: TabBar(parent)
+{
 	//setAcceptDrops(true);
 
 	setMovable(true);
 	setTabsClosable(true);
 	setSelectionBehaviorOnRemove ( QTabBar::SelectPreviousTab );
-	currTab=-1;
 }
 
 /**
@@ -58,7 +56,11 @@ PsiTabWidget* PsiTabBar::psiTabWidget() {
 /**
  * Overriding this allows us to emit signals for double clicks
  */
-void PsiTabBar::mouseDoubleClickEvent(QMouseEvent *event) {
+void PsiTabBar::mouseDoubleClickEvent(QMouseEvent *event)
+{
+	if (event->button() != Qt::MouseButton::LeftButton)
+		return;
+
 	const QPoint pos = event->pos();
 	int tab = findTabUnder(pos);
 	if (tab >= 0 && tab < count()) {
@@ -79,7 +81,7 @@ int PsiTabBar::findTabUnder(const QPoint &pos) {
 }
 
 void PsiTabBar::mousePressEvent(QMouseEvent *event) {
-	QTabBar::mousePressEvent(event);
+	TabBar::mousePressEvent(event);
 	event->accept();
 }
 
@@ -89,38 +91,26 @@ void PsiTabBar::mouseReleaseEvent ( QMouseEvent * event )
 		emit mouseMiddleClickTab(findTabUnder(event->pos()));
 		event->accept();
 	}
-	QTabBar::mouseReleaseEvent(event);
+	TabBar::mouseReleaseEvent(event);
 
-	if ((dragTab_ != -1) && (event->button() != Qt::MidButton)) {
+	if (event->button() != Qt::MidButton) {
 		this->setCurrentIndex(currentIndex());
 	}
 };
 
-/*
- * Used for starting drags of tabs
- */
-void PsiTabBar::mouseMoveEvent(QMouseEvent *event) {
-	if (!dragsEnabled_) {
-		return;
-	}
-	if (!(event->buttons() & Qt::LeftButton)) {
-		currTab=-1;
-		return;
-	}
-	if ((event->pos() - dragStartPosition_).manhattanLength()
-		< QApplication::startDragDistance()) {
-		return;
-	}
-
-	QTabBar::mouseMoveEvent(event);
-}
-
 void PsiTabBar::contextMenuEvent(QContextMenuEvent *event) {
 	event->accept();
-	emit contextMenu(event, findTabUnder(event->pos()));
+	int tab = findTabUnder(event->pos());
+	if (tab < 0)
+		tab = currentIndex();
+
+	emit contextMenu(event, tab);
 }
 
 void PsiTabBar::wheelEvent(QWheelEvent *event) {
+	if (PsiOptions::instance()->getOption("options.ui.tabs.disable-wheel-scroll").toBool())
+		return;
+
 	int numDegrees = event->delta() / 8;
 	int numSteps = numDegrees / 15;
 
@@ -136,16 +126,9 @@ void PsiTabBar::wheelEvent(QWheelEvent *event) {
 	event->accept();
 }
 
-/*
- * Enable/disable dragging of tabs
- */
-void PsiTabBar::setDragsEnabled(bool enabled) {
-	dragsEnabled_ = enabled;
-}
-
 void PsiTabBar::paintEvent(QPaintEvent *event)
 {
-	QTabBar::paintEvent(event);
+	TabBar::paintEvent(event);
 };
 
 void PsiTabBar::resizeEvent(QResizeEvent * event)
--- a/src/widgets/psitabbar.h
+++ b/src/widgets/psitabbar.h
@@ -21,12 +21,12 @@
 #ifndef _PSITABBAR_H_
 #define _PSITABBAR_H_
 
-#include <QTabBar>
+#include "tabbar.h"
 #include <QPoint>
 
 class PsiTabWidget;
 
-class PsiTabBar : public QTabBar
+class PsiTabBar : public TabBar
 {
 	Q_OBJECT
 
@@ -35,8 +35,6 @@ public:
 	~PsiTabBar();
 	PsiTabWidget *psiTabWidget();
 
-	void setDragsEnabled(bool enabled); // default enabled
-
 signals:
 	void mouseDoubleClickTab(int tab);
 	void mouseMiddleClickTab(int tab);
@@ -46,7 +44,6 @@ signals:
 
 protected:
 	void mouseDoubleClickEvent(QMouseEvent *event);
-	void mouseMoveEvent(QMouseEvent *event);
 	//void dragEnterEvent(QDragEnterEvent *event);
 	//void dropEvent(QDropEvent *event);
 	void mousePressEvent(QMouseEvent *event);
@@ -58,11 +55,7 @@ protected:
 
 private:
 	int findTabUnder(const QPoint &pos);
-	QPoint dragStartPosition_;
-	int dragTab_;
-	int currTab;
 	bool isOnTheLeft;
-	bool dragsEnabled_;
 };
 
 #endif /* _PSITABBAR_H_ */
--- a/src/widgets/psitabwidget.cpp
+++ b/src/widgets/psitabwidget.cpp
@@ -38,7 +38,11 @@ PsiTabWidget::PsiTabWidget(QWidget *parent)
 		: QWidget(parent) {
 	tabsPosition_ = QTabWidget::East; // impossible => uninitialised state
 	tabBar_ = new PsiTabBar(this);
-	tabBar_->setUsesScrollButtons(true);
+	bool multiRow = PsiOptions::instance()->getOption("options.ui.tabs.multi-rows", true).toBool();
+	bool currentIndexAlwaysAtBottom  = PsiOptions::instance()->getOption("options.ui.tabs.current-index-at-bottom", true).toBool();
+	tabBar_->setMultiRow(multiRow);
+	tabBar_->setUsesScrollButtons(!multiRow);
+	tabBar_->setCurrentIndexAlwaysAtBottom(currentIndexAlwaysAtBottom);
 	layout_ = new QVBoxLayout(this);
 	layout_->setMargin(0);
 	layout_->setSpacing(0);
@@ -55,19 +59,21 @@ PsiTabWidget::PsiTabWidget(QWidget *parent)
 	downButton_ = new QToolButton(this);
 	downButton_->setMinimumSize(3,3);
 	downButton_->setFixedWidth(buttonwidth);
-	downButton_->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Minimum);
+	downButton_->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
 	menu_ = new QMenu(this);
 	downButton_->setMenu(menu_);
 	downButton_->setStyleSheet(" QToolButton::menu-indicator { image:none } ");
 	connect(menu_, SIGNAL(aboutToShow()), SLOT(menu_aboutToShow()));
 	connect(menu_, SIGNAL(triggered(QAction*)), SLOT(menu_triggered(QAction*)));
 	barLayout_->addWidget(downButton_);
+	barLayout_->setAlignment(downButton_, Qt::AlignBottom);
 
 	closeButton_ = new QToolButton(this);
 	closeButton_->setMinimumSize(3,3);
 	closeButton_->setFixedWidth(buttonwidth);
-	closeButton_->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Minimum);
+	closeButton_->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
 	barLayout_->addWidget(closeButton_);
+	barLayout_->setAlignment(closeButton_, Qt::AlignBottom);
 	closeButton_->setText("x");
 	downButton_->setArrowType(Qt::DownArrow);
 	downButton_->setPopupMode(QToolButton::InstantPopup);
@@ -76,20 +82,23 @@ PsiTabWidget::PsiTabWidget(QWidget *parent)
 	setTabPosition(QTabWidget::North);
 	setLooks();
 
-	if (!PsiOptions::instance()->getOption("options.ui.tabs.show-tab-close-buttons").toBool()){
-		tabBar_->setTabsClosable(false);
-	}
 	if (!PsiOptions::instance()->getOption("options.ui.tabs.show-tab-buttons").toBool()){
 		closeButton_->hide();
 		downButton_->hide();
 	}
-	connect(tabBar_, SIGNAL(mouseDoubleClickTab(int)), SLOT(mouseDoubleClickTab(int)));
-	connect(tabBar_, SIGNAL(mouseMiddleClickTab(int)), SLOT(mouseMiddleClickTab(int)));
-	connect(tabBar_, SIGNAL( currentChanged(int)), SLOT(tab_currentChanged(int)));
-	connect(tabBar_, SIGNAL( contextMenu(QContextMenuEvent*,int)), SLOT( tab_contextMenu(QContextMenuEvent*,int)));
+#if QT_VERSION >= 0x040500
+	if (!PsiOptions::instance()->getOption("options.ui.tabs.show-tab-close-buttons").toBool()){
+		tabBar_->setTabsClosable(false);
+	}
+#endif
+	connect( tabBar_, SIGNAL(mouseDoubleClickTab(int)), SLOT(mouseDoubleClickTab(int)));
+	connect( tabBar_, SIGNAL(mouseMiddleClickTab(int)), SLOT(mouseMiddleClickTab(int)));
+	// TabBar::tabRemove must be handled before tab_currentChanged
+	connect( tabBar_, SIGNAL( currentChanged(int)), SLOT(tab_currentChanged(int)));
+	connect( tabBar_, SIGNAL( contextMenu(QContextMenuEvent*,int)), SLOT( tab_contextMenu(QContextMenuEvent*,int)));
+	connect( closeButton_, SIGNAL(clicked()), SIGNAL(closeButtonClicked()));
 	connect(tabBar_, SIGNAL(tabMoved(int,int)),SLOT(widgetMoved(int,int)));
 	connect(tabBar_, SIGNAL(tabCloseRequested(int)),SIGNAL(tabCloseRequested(int)));
-	connect(closeButton_, SIGNAL(clicked()), SIGNAL(closeButtonClicked()));
 }
 
 void PsiTabWidget::setCloseIcon(const QIcon& icon) {
@@ -180,6 +189,7 @@ void PsiTabWidget::addTab(QWidget *widget, QString name, const QIcon &icon)
 		tabBar_->addTab(name);
 	setLooks();
 	showPage(currentPage());
+	tabBar_->layoutTabs();
 }
 
 void PsiTabWidget::setLooks()
@@ -190,6 +200,14 @@ void PsiTabWidget::setLooks()
 	}
 }
 
+void PsiTabWidget::resizeEvent(QResizeEvent *event)
+{
+	QWidget::resizeEvent(event);
+	if (tabBar_->multiRow()) {
+		tabBar_->layoutTabs();
+	}
+}
+
 /**
  * Selects the page for the specified widget.
  */
@@ -217,6 +235,29 @@ void PsiTabWidget::showPageDirectly(QWidget* widget) {
 	}
 }
 
+void PsiTabWidget::setPagePinned(QWidget *page, bool pinned)
+{
+	for (int i = 0; i < count(); ++i) {
+		if (widgets_.at(i) == page) {
+			tabBar_->setTabPinned(i, pinned);
+			showPageDirectly(page);
+			break;
+		}
+	}
+}
+
+bool PsiTabWidget::isPagePinned(QWidget *page)
+{
+	for (int i = 0; i < count(); ++i) {
+		if (widgets_.at(i) == page) {
+			return tabBar_->isTabPinned(i);
+			break;
+		}
+	}
+
+	return false;
+}
+
 /**
  * Removes the page for the specified widget.
  */
@@ -364,6 +405,11 @@ void PsiTabWidget::setDragsEnabled(bool enabled) {
 	((PsiTabBar *)tabBar_)->setDragsEnabled(enabled);
 }
 
+void PsiTabWidget::setTabBarUpdateEnabled(bool b)
+{
+	tabBar_->setUpdateEnabled(b);
+}
+
 void PsiTabWidget::widgetMoved(int from, int to)
 {
 	if (from > to) {
@@ -379,6 +425,9 @@ void PsiTabWidget::widgetMoved(int from, int to)
 		stacked_->insertWidget(to,widgets_[to]);
 	}
 
+#if QT_VERSION <= 0x040500
+	setCurrentPage(to);
+#endif
 	emit currentChanged(currentPage());
 
 };
--- a/src/widgets/psitabwidget.h
+++ b/src/widgets/psitabwidget.h
@@ -22,7 +22,6 @@
 #define PSITABWIDGET_H
 
 #include <QTabWidget>
-#include <QTabBar>
 #include <QDragEnterEvent>
 #include "psitabbar.h"
 
@@ -52,6 +51,9 @@ public:
 	void showPage(QWidget *);
 	void showPageDirectly(QWidget *);
 
+	void setPagePinned(QWidget *page, bool pinned);
+	bool isPagePinned(QWidget *page);
+
 	void removePage(QWidget *);
 	QWidget* page(int index);
 	int getIndex(QWidget *);
@@ -64,6 +66,8 @@ public:
 	void setTabButtonsShown(bool shown); // default shown
 	void setDragsEnabled(bool enabled);  // default enabled
 
+	void setTabBarUpdateEnabled(bool b);
+
 public slots:
 	void setCurrentPage(int);
 	void removeCurrentPage();
@@ -80,6 +84,9 @@ signals:
 	// context menu on the blank space will have tab==-1
 	void tabContextMenu(int tab, QPoint pos, QContextMenuEvent *event);
 
+protected:
+	void resizeEvent(QResizeEvent *event);
+
 private slots:
 	void mouseDoubleClickTab(int tab);
 	void mouseMiddleClickTab(int tab);
@@ -91,7 +98,7 @@ private slots:
 
 private:
 	QVector<QWidget*> widgets_;
-	QTabBar *tabBar_;
+	PsiTabBar *tabBar_;
 	QVBoxLayout *layout_;
 	QHBoxLayout *barLayout_;
 	QStackedLayout *stacked_;
--- /dev/null
+++ b/src/widgets/tabbar.cpp
@@ -0,0 +1,1334 @@
+/*
+ * tabbar.cpp
+ * Copyright (C) 2013-2016  Ivan Romanov <drizt@land.ru>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "tabbar.h"
+#include "iconset.h"
+
+#include <QAbstractButton>
+#include <QPixmap>
+#include <QStyleOptionTab>
+#include <QStylePainter>
+#include <QMouseEvent>
+#include <QApplication>
+#include <QLine>
+#include <QDrag>
+#include <QMimeData>
+#include <QDebug>
+
+#define PINNED_CHARS 4
+
+// Do not count invisible &
+//#define PINNED_TEXT(text) text.left(text.left(PINNED_CHARS).contains("&") ? (PINNED_CHARS + 1) : PINNED_CHARS)
+
+#ifdef HAVE_QT5
+typedef QStyleOptionTab PsiStyleOptionTab;
+typedef QStyleOptionTabBarBase PsiStyleOptionTabBarBase;
+#else
+typedef QStyleOptionTabV3 PsiStyleOptionTab;
+typedef QStyleOptionTabBarBaseV2 PsiStyleOptionTabBarBase;
+#endif
+
+class CloseButton : public QAbstractButton
+{
+	Q_OBJECT
+
+public:
+	CloseButton(QWidget *parent = 0);
+
+	QSize sizeHint() const;
+	inline QSize minimumSizeHint() const
+		{ return sizeHint(); }
+	void enterEvent(QEvent *event);
+	void leaveEvent(QEvent *event);
+	void paintEvent(QPaintEvent *event);
+};
+
+struct RowSf
+{
+	RowSf() : number(0), sf(0.) {}
+
+	int number;
+	double sf;
+};
+
+typedef QList<RowSf> LayoutSf;
+
+class TabBar::Private
+{
+public:
+	Private(TabBar *base);
+
+	void layoutTabs();
+	int pinnedTabWidthHint() const;
+	QSize tabSizeHint(PsiStyleOptionTab tab) const;
+	void balanseCloseButtons();
+	bool indexAtBottom(int index) const;
+
+	TabBar *q;
+	QList<PsiStyleOptionTab> hackedTabs;
+	QList<CloseButton*> closeButtons;
+	bool tabsClosable;
+	bool multiRow;
+	int hoverTab;
+	bool dragsEnabled;
+	int dragTab;
+	int dragInsertIndex;
+	int dragHoverTab;
+	QPoint mousePressPoint;
+	int pinnedTabs;
+	bool update;
+	bool stopRecursive;
+	bool indexAlwaysAtBottom;
+
+	struct {
+		QList<int> tabs;
+		int barWidth;
+		int rows;
+		double baseSf;
+		LayoutSf layout;
+	} cachedLayout;
+};
+
+TabBar::Private::Private(TabBar *base)
+	: q(base)
+	, hackedTabs()
+	, closeButtons()
+	, tabsClosable(false)
+	, multiRow(false)
+	, hoverTab(-1)
+	, dragsEnabled(true)
+	, dragTab(-1)
+	, dragInsertIndex(-1)
+	, dragHoverTab(-1)
+	, mousePressPoint()
+	, pinnedTabs(0)
+	, update(true)
+	, stopRecursive(false)
+	, indexAlwaysAtBottom(false)
+	, cachedLayout({ QList<int>(), 0, 0, 0., LayoutSf() })
+{
+	balanseCloseButtons();
+}
+
+LayoutSf possibleLayouts2(const QList<int> &tabs, int barWidth, int rows, double baseSf)
+{
+	int layouts[50 * 10000]; // FIXME
+	for (int i = 0; i < rows; ++i) {
+		layouts[i] = i;
+	}
+
+	int *pPrevLayout = &layouts[0];
+	int *pLayout = &layouts[rows];
+	int nTabs = tabs.size();
+
+
+	// Fill layouts
+	while (true) {
+		for (int i = 0; i < rows; ++i) {
+			pLayout[i] = pPrevLayout[i];
+		}
+
+		int i = rows - 1;
+		while (i > 0) {
+			int base = pLayout[i] + 1;
+			if (base <= nTabs - rows + i) {
+				for (int j = i; j < rows; j++)
+					pLayout[j] = base++;
+
+				break;
+			}
+			else {
+				i--;
+			}
+		}
+
+		if (i == 0)
+			break;
+
+		pPrevLayout = pLayout;
+		pLayout += rows;
+	}
+
+	int *pGoodLayout = 0;
+	double minDSf = 10000.; // Just huge number
+
+	for (pPrevLayout = &layouts[0]; pPrevLayout < pLayout; pPrevLayout += rows) {
+		bool addRow = true;
+		double sf = 0.;
+		for (int i = 0; i < rows; ++i) {
+			int tabsWidth = 0;
+			int end = i == rows - 1 ? nTabs : pPrevLayout[i + 1];
+			for (int j = pPrevLayout[i]; j < end; ++j)
+				tabsWidth += tabs[j];
+
+			if (tabsWidth > barWidth && end - pPrevLayout[i] > 1) {
+				addRow = false;
+				break;
+			}
+
+			double curSf = static_cast<double>(barWidth) / tabsWidth;
+			sf += qAbs(baseSf - curSf);
+			if (i == rows - 1) {
+				if (sf < minDSf) {
+					pGoodLayout = pPrevLayout;
+					minDSf = sf;
+				}
+				else {
+					break;
+					addRow = false;
+				}
+			}
+		}
+
+		if (!addRow)
+			continue;
+	}
+
+	LayoutSf res;
+	if (pGoodLayout) {
+		for (int i = 0; i < rows; ++i) {
+			RowSf rowSf;
+			rowSf.number = pGoodLayout[i];
+
+			int tabsWidth = 0;
+			int end = i == rows - 1 ? nTabs : pGoodLayout[i + 1];
+			for (int j = pGoodLayout[i]; j < end; ++j)
+				tabsWidth += tabs[j];
+
+			rowSf.sf = static_cast<double>(barWidth) / tabsWidth;
+
+			res << rowSf;
+		}
+	}
+
+	return res;
+}
+
+LayoutSf possibleLayouts(const QList<int> &tabs, int barWidth, int rows, double baseSf)
+{
+	// Some safe combinations
+	if (                 tabs.size() <= 18
+		|| (rows <= 6 && tabs.size() <= 22)
+		|| (rows <= 5 && tabs.size() <= 28)
+		|| (rows <= 4 && tabs.size() <= 40)) {
+
+		return possibleLayouts2(tabs, barWidth, rows, baseSf);
+	}
+
+	// Will believe that 3 rows is enough good number to avoid overflow of layouts array
+	// in possibleLayouts2 function.
+	// Also look at Combination Formula to understand how it works.
+	LayoutSf layoutSf;
+	int i = 0;
+	int step = 3;
+	int extratab = (tabs.size() % rows) ? 1 : 0;
+	while (i < rows) {
+		if (rows - i - step == 1)
+			step = 2;
+
+		int rows2 = qMin(step, rows - i);
+		int startPos = i * (tabs.size() / rows + extratab);
+		int length = step * (tabs.size() / rows + extratab);
+		QList<int> tabs2 = tabs.mid(startPos, length);
+
+		LayoutSf newLayoutSf = possibleLayouts2(tabs2, barWidth, rows2, baseSf);
+		if (newLayoutSf.isEmpty()) {
+			layoutSf.clear();
+			break;
+		}
+		for (int j = 0; j < newLayoutSf.size(); ++j) {
+			newLayoutSf[j].number += startPos;
+		}
+		layoutSf += newLayoutSf;
+		i += step;
+	}
+
+	return layoutSf;
+}
+
+void TabBar::Private::layoutTabs()
+{
+	if (!update)
+		return;
+
+	pinnedTabs = qMin(pinnedTabs, q->count());
+	hackedTabs.clear();
+
+	QTabBar::ButtonPosition closeSide = (QTabBar::ButtonPosition)q->style()->styleHint(QStyle::SH_TabBar_CloseButtonPosition, 0, q);
+	// Tabs maybe 0 width in all-in-one mode
+	int barWidth = qMax(q->width(), 1);
+	int tabsWidthHint = 0;
+
+	int pinnedTabWidth = pinnedTabWidthHint();
+	int pinnedInRow = barWidth / pinnedTabWidth;
+
+	// Protect zero divide
+	if (!pinnedInRow)
+		pinnedInRow = 1;
+
+	int pinnedRows = pinnedTabs / pinnedInRow;
+	double pinnedSf = static_cast<double>(barWidth) / (pinnedInRow * pinnedTabWidth);
+
+	// Prepare hacked tabs
+	for (int i = 0; i < q->count(); i++) {
+		PsiStyleOptionTab tab;
+		q->initStyleOption(&tab, i);
+		if (i == 0) {
+			tab.rect.setLeft(0);
+		}
+
+		tab.state &= ~QStyle::State_MouseOver;
+		tab.position = QStyleOptionTab::Beginning;
+
+		if (tabsClosable && i >= pinnedTabs) {
+			tab.rect.setWidth(tab.rect.width() + closeButtons.at(i)->size().width());
+			if (closeSide == QTabBar::LeftSide) {
+				tab.leftButtonSize = closeButtons.at(i)->size();
+			}
+			else {
+				tab.rightButtonSize = closeButtons.at(i)->size();
+			}
+		}
+
+		tab.rect.setSize(tabSizeHint(tab));
+		// Make pinned tab if need
+		//if (i < pinnedTabs){
+		//	tab.text = PINNED_TEXT(tab.text);
+		//	tab.rect.setWidth(pinnedTabWidth);
+		//}
+		hackedTabs << tab;
+	}
+
+	// Extra checking for no any tabs (maybe can be dropped?)
+	if (hackedTabs.isEmpty())
+		return;
+
+	int firstNormalTab = pinnedInRow * pinnedRows;
+	// Not enough space for normal tab in row with pinned tabs
+	if (pinnedTabs == hackedTabs.size()
+		|| (pinnedTabs
+			&& (barWidth - pinnedTabWidth * (pinnedTabs - pinnedRows * pinnedInRow) < hackedTabs.at(pinnedTabs).rect.width()))) {
+
+		pinnedRows++;
+		firstNormalTab = pinnedTabs;
+	}
+
+	// Calculate all normal tabs (with pinned tale) width hint
+	for (int i = firstNormalTab; i < hackedTabs.size(); ++i) {
+		tabsWidthHint += hackedTabs.at(i).rect.width();
+	}
+
+	int normalRows = pinnedTabs < hackedTabs.size() ? tabsWidthHint / barWidth + 1 : 0;
+	int rows = normalRows + pinnedRows;
+
+	if (rows > hackedTabs.size()) {
+		rows = hackedTabs.size();
+		normalRows = rows - pinnedRows;
+	}
+
+	double sf = static_cast<float>(barWidth * normalRows) / tabsWidthHint;
+	LayoutSf layout;
+	if (rows == 1 || hackedTabs.size() == 1) {
+		// Only one row in bar
+		rows = 1;
+		normalRows = 1;
+		layout << RowSf();
+		layout[0].number = 0;
+		layout[0].sf = qMin(1.5, sf);
+	}
+	else {
+		QList<int> tabWidths;
+		for (int i = firstNormalTab; i < hackedTabs.size(); ++i) {
+			tabWidths << hackedTabs.at(i).rect.width();
+		}
+
+		if (normalRows) {
+			while (layout.isEmpty()) {
+				// Speed optimization
+				if (!cachedLayout.layout.isEmpty()
+					&& cachedLayout.tabs == tabWidths
+					&& cachedLayout.barWidth == barWidth
+					&& cachedLayout.baseSf == sf
+					&& cachedLayout.rows == normalRows) {
+
+					layout = cachedLayout.layout;
+					break;
+				}
+				else {
+					layout = possibleLayouts(tabWidths, barWidth, normalRows, sf);
+				}
+				if (layout.isEmpty()) {
+					normalRows++;
+					rows++;
+					sf = static_cast<float>(barWidth * normalRows) / tabsWidthHint;
+				}
+			}
+			cachedLayout.layout = layout;
+			cachedLayout.barWidth = barWidth;
+			cachedLayout.baseSf = sf;
+			cachedLayout.tabs = tabWidths;
+			cachedLayout.rows = normalRows;
+		}
+
+		// Add pinned tabs to layout
+		for (int i = 0; i < layout.size(); ++i) {
+			layout[i].number += firstNormalTab;
+		}
+
+		for (int i = pinnedRows - 1; i >= 0; --i) {
+			RowSf rowSf;
+			rowSf.number = i * pinnedInRow;
+			rowSf.sf = pinnedSf;
+			layout.prepend(rowSf);
+		}
+	}
+
+	// Calculate size and position for all tabs
+	for (int i = 0; i < rows; ++i) {
+		RowSf &row = layout[i];
+		int endTab = i == rows - 1 ? hackedTabs.size() : layout[i + 1].number;
+		int currentRowWidth = 0;
+		int bottom;
+		if (q->shape() == QTabBar::RoundedNorth)
+			bottom = i * (hackedTabs[0].rect.height() - 2);
+		else
+			bottom = (rows - i - 1) * (hackedTabs[0].rect.height() - 2);
+
+		for (int j = row.number; j < endTab; j++) {
+			PsiStyleOptionTab &tab = hackedTabs[j];
+			int tabWidth = tab.rect.width();
+			if (rows > 1 && (j < firstNormalTab || j >= pinnedTabs)) {
+				tabWidth *= row.sf;
+				tab.rect.setWidth(tabWidth);
+			}
+			tab.rect.moveTop(bottom);
+			tab.rect.moveLeft(currentRowWidth);
+
+			if (currentRowWidth == 0) {
+				if (endTab == j + 1) {
+					tab.position = QStyleOptionTab::OnlyOneTab;
+					if (rows > 1)
+						tab.rect.setRight(barWidth - 1);
+				}
+				else {
+					currentRowWidth += tabWidth;
+					tab.position = QStyleOptionTab::Beginning;
+				}
+			}
+			else {
+				if (j < endTab - 1) {
+					currentRowWidth += tabWidth;
+					tab.position = QStyleOptionTab::Middle;
+				}
+				else {
+					tab.position = QStyleOptionTab::End;
+
+					if (rows > 1)
+						tab.rect.setRight(barWidth - 1);
+					currentRowWidth = 0;
+				}
+			}
+		}
+	}
+
+#ifdef Q_OS_MAC
+	if (rows == 1) {
+		int offset = (barWidth - hackedTabs.last().rect.right()) / 2;
+		for (int i = 0; i < hackedTabs.size(); ++i)
+			hackedTabs[i].rect.adjust(offset, 0, offset, 0);
+	}
+#endif
+
+	q->setMinimumSize(0, q->sizeHint().height());
+	q->resize(q->sizeHint());
+}
+
+inline static bool verticalTabs(QTabBar::Shape shape)
+{
+	return shape == QTabBar::RoundedWest
+		   || shape == QTabBar::RoundedEast
+		   || shape == QTabBar::TriangularWest
+		   || shape == QTabBar::TriangularEast;
+}
+
+int TabBar::Private::pinnedTabWidthHint() const
+{
+	PsiStyleOptionTab opt;
+	q->initStyleOption(&opt, 0);
+	opt.leftButtonSize = QSize();
+	opt.rightButtonSize = QSize();
+	// opt.text = "XXX";
+	opt.text = QString(PINNED_CHARS, 'X');
+	QSize iconSize = opt.iconSize;
+	int hframe = q->style()->pixelMetric(QStyle::PM_TabBarTabHSpace, &opt, q);
+	int vframe = q->style()->pixelMetric(QStyle::PM_TabBarTabVSpace, &opt, q);
+	QFont f = q->font();
+	f.setBold(true);
+
+	const QFontMetrics fm(f);
+
+	int maxWidgetHeight = qMax(opt.leftButtonSize.height(), opt.rightButtonSize.height());
+	int maxWidgetWidth = qMax(opt.leftButtonSize.width(), opt.rightButtonSize.width());
+
+	int padding = 0;
+	if (!opt.icon.isNull())
+		padding += 4;
+
+	QSize csz;
+	if (verticalTabs(q->shape())) {
+		csz = QSize( qMax(maxWidgetWidth, qMax(fm.height(), iconSize.height())) + vframe,
+					 fm.size(Qt::TextShowMnemonic, opt.text).width() + iconSize.width() + hframe + padding);
+	} else {
+		csz = QSize(fm.size(Qt::TextShowMnemonic, opt.text).width() + iconSize.width() + hframe + padding,
+					qMax(maxWidgetHeight, qMax(fm.height(), iconSize.height())) + vframe);
+	}
+
+	QSize retSize = q->style()->sizeFromContents(QStyle::CT_TabBarTab, &opt, csz, q);
+	return retSize.width() + 5;
+
+}
+
+QSize TabBar::Private::tabSizeHint(PsiStyleOptionTab opt) const
+{
+	QSize iconSize = opt.iconSize;
+	int hframe = q->style()->pixelMetric(QStyle::PM_TabBarTabHSpace, &opt, q);
+	int vframe = q->style()->pixelMetric(QStyle::PM_TabBarTabVSpace, &opt, q);
+	QFont f = q->font();
+	f.setBold(true);
+
+	const QFontMetrics fm(f);
+
+	int maxWidgetHeight = qMax(opt.leftButtonSize.height(), opt.rightButtonSize.height());
+	int maxWidgetWidth = qMax(opt.leftButtonSize.width(), opt.rightButtonSize.width());
+
+	int widgetWidth = 0;
+	int widgetHeight = 0;
+	int padding = 0;
+	if (!opt.leftButtonSize.isEmpty()) {
+		padding += 4;
+		widgetWidth += opt.leftButtonSize.width();
+		widgetHeight += opt.leftButtonSize.height();
+	}
+	if (!opt.rightButtonSize.isEmpty()) {
+		padding += 4;
+		widgetWidth += opt.rightButtonSize.width();
+		widgetHeight += opt.rightButtonSize.height();
+	}
+	if (!opt.icon.isNull())
+		padding += 4;
+
+	QSize csz;
+	if (verticalTabs(q->shape())) {
+		csz = QSize( qMax(maxWidgetWidth, qMax(fm.height(), iconSize.height())) + vframe,
+					 fm.size(Qt::TextShowMnemonic, opt.text).width() + iconSize.width() + hframe + widgetHeight + padding);
+	} else {
+		csz = QSize(fm.size(Qt::TextShowMnemonic, opt.text).width() + iconSize.width() + hframe
+					+ widgetWidth + padding,
+					qMax(maxWidgetHeight, qMax(fm.height(), iconSize.height())) + vframe);
+	}
+
+	QSize retSize = q->style()->sizeFromContents(QStyle::CT_TabBarTab, &opt, csz, q);
+	return retSize;
+
+}
+
+void TabBar::Private::balanseCloseButtons()
+{
+	pinnedTabs = qMin(pinnedTabs, q->count());
+
+	if (tabsClosable && multiRow) {
+		while (closeButtons.isEmpty() || closeButtons.size() < q->count()) {
+			CloseButton *cb = new CloseButton(q);
+			closeButtons << cb;
+			cb->show();
+			connect(cb, SIGNAL(clicked()), q, SLOT(closeTab()));
+		}
+
+		while (closeButtons.size() > q->count()) {
+			closeButtons.takeLast()->deleteLater();
+		}
+
+		for (int i = 0; i < pinnedTabs && i < closeButtons.size(); ++i)
+			closeButtons.at(i)->hide();
+		for (int i = pinnedTabs; i < closeButtons.size(); ++i)
+			closeButtons.at(i)->show();
+	}
+	else {
+		qDeleteAll(closeButtons);
+		closeButtons.clear();
+	}
+}
+
+bool TabBar::Private::indexAtBottom(int index) const
+{
+	if (!indexAlwaysAtBottom)
+		return true;
+
+	int lastBeginTab = hackedTabs.size() - 1;
+	while (lastBeginTab > 0
+		   && hackedTabs.at(lastBeginTab).position != QStyleOptionTab::Beginning
+		   && hackedTabs.at(lastBeginTab).position != QStyleOptionTab::OnlyOneTab) {
+
+		lastBeginTab--;
+	}
+
+	return index >= lastBeginTab || index < pinnedTabs;
+}
+
+TabBar::TabBar(QWidget *parent)
+	: QTabBar(parent)
+{
+	d = new Private(this);
+#ifdef Q_OS_LINUX
+	// Workaround for KDE5 breeze problem with wrong window dragging on TabBar clicking
+	qApp->installEventFilter(this);
+#else
+	installEventFilter(this);
+#endif
+}
+
+TabBar::~TabBar()
+{
+	delete d;
+}
+
+void TabBar::layoutTabs()
+{
+	setMouseTracking(true);
+	if (d->multiRow) {
+		d->layoutTabs();
+		if (!d->indexAtBottom(currentIndex())) {
+			setCurrentIndex(currentIndex());
+		}
+	}
+	update();
+}
+
+void TabBar::setMultiRow(bool b)
+{
+	if (b == d->multiRow) {
+		return;
+	}
+
+	d->multiRow = b;
+	setMouseTracking(b);
+	setAcceptDrops(b);
+
+	if (b) {
+		d->tabsClosable = QTabBar::tabsClosable();
+		setElideMode(Qt::ElideNone);
+		QTabBar::setTabsClosable(false);
+	}
+	else {
+		QTabBar::setTabsClosable(d->tabsClosable);
+		d->tabsClosable = false;
+	}
+
+	d->balanseCloseButtons();
+	if (b) {
+		// setUsesScrollButtons(false);
+		layoutTabs();
+	}
+	else {
+		d->hackedTabs.clear();
+		update();
+	}
+}
+
+void TabBar::setCurrentIndex(int index)
+{
+	if (!d->multiRow || d->hackedTabs.isEmpty()) {
+		QTabBar::setCurrentIndex(index);
+		return;
+	}
+
+	if (index == currentIndex() && d->indexAtBottom(index))
+		return;
+
+	if (d->stopRecursive)
+		return;
+
+	d->stopRecursive = true;
+	d->pinnedTabs = qMin(d->pinnedTabs, count());
+
+	if (!d->indexAtBottom(index)) {
+		int curLastBeginTab = index;
+		while (d->hackedTabs.at(curLastBeginTab).position != QStyleOptionTab::Beginning
+			   && d->hackedTabs.at(curLastBeginTab).position != QStyleOptionTab::OnlyOneTab && curLastBeginTab > d->pinnedTabs) {
+
+			curLastBeginTab--;
+		}
+
+		if (d->hackedTabs.at(curLastBeginTab).position == QStyleOptionTab::OnlyOneTab) {
+
+			moveTab(curLastBeginTab, count() - 1);
+			index = count() - 1;
+		}
+		else {
+			int curLastEndingTab = curLastBeginTab;
+			while (d->hackedTabs.at(curLastEndingTab).position != QStyleOptionTab::End) {
+				curLastEndingTab++;
+			}
+
+			// Try to move whole line
+			for (int i = curLastBeginTab; i <= curLastEndingTab; i++) {
+				moveTab(curLastBeginTab, count() - 1);
+			}
+			index = count() - (curLastEndingTab - curLastBeginTab) - 1 + (index - curLastBeginTab);
+		}
+	}
+
+	QTabBar::setCurrentIndex(index);
+	d->layoutTabs();
+
+	// Extra checking for current tab at bottom
+	if (!d->indexAtBottom(index)) {
+		moveTab(index, count() - 1);
+		index = count() - 1;
+		QTabBar::setCurrentIndex(index);
+		d->layoutTabs();
+	}
+
+	d->stopRecursive = false;
+}
+
+void TabBar::setTabText(int index, const QString & text)
+{
+	QTabBar::setTabText(index, text);
+	layoutTabs();
+}
+
+void TabBar::setTabTextColor(int index, const QColor & color)
+{
+	QTabBar::setTabTextColor(index, color);
+	layoutTabs();
+}
+
+void TabBar::setTabIcon(int index, const QIcon &icon)
+{
+	QTabBar::setTabIcon(index, icon);
+	layoutTabs();
+}
+
+QRect TabBar::tabRect(int index) const
+{
+	if (d->multiRow) {
+		if (index < d->hackedTabs.size() && index >= 0)
+			return d->hackedTabs[index].rect;
+		else
+			return QRect();
+	}
+	else {
+		return QTabBar::tabRect(index);
+	}
+}
+
+QWidget *TabBar::tabButton(int index, ButtonPosition position) const
+{
+	ButtonPosition closeButtonPos = static_cast<ButtonPosition>(style()->styleHint(QStyle::SH_TabBar_CloseButtonPosition, 0, this));
+	if (!d->multiRow || position != closeButtonPos)
+		return QTabBar::tabButton(index, position);
+
+	Q_ASSERT(index < d->closeButtons.size());
+	return index < d->closeButtons.size() ? d->closeButtons[index] : 0;
+}
+
+int TabBar::tabAt(const QPoint &position) const
+{
+	if (d->multiRow) {
+		int tab = -1;
+		for (int i = 0; i < d->hackedTabs.count(); ++i) {
+			if (d->hackedTabs[i].rect.contains(position)) {
+				tab = i;
+				break;
+			}
+		}
+		return tab;
+	}
+	else {
+		return QTabBar::tabAt(position);
+	}
+}
+
+bool TabBar::eventFilter(QObject *watched, QEvent *event)
+{
+	if (d->multiRow && watched == this && event->type() == QEvent::MouseButtonPress) {
+		mousePressEvent(static_cast<QMouseEvent*>(event));
+		event->accept();
+		return true;
+	}
+	return QTabBar::eventFilter(watched, event);
+}
+
+void TabBar::setUpdateEnabled(bool b)
+{
+	d->update = b;
+	if (b) {
+		layoutTabs();
+	}
+	else {
+		d->hackedTabs.clear();
+	}
+}
+
+bool TabBar::multiRow() const
+{
+	return d->multiRow;
+}
+
+/*
+ * Enable/disable dragging of tabs
+ */
+void TabBar::setDragsEnabled(bool enabled)
+{
+	d->dragsEnabled = enabled;
+}
+
+void TabBar::setTabPinned(int index, bool pinned)
+{
+	int newPos = d->pinnedTabs + (pinned ? 0 : -1);
+	if (index != newPos)
+		moveTab(index, newPos);
+
+	d->pinnedTabs += pinned ? +1 : -1;
+
+	d->layoutTabs();
+	setCurrentIndex(newPos);
+	d->balanseCloseButtons();
+	update();
+}
+
+bool TabBar::isTabPinned(int index)
+{
+	return index < d->pinnedTabs;
+}
+
+void TabBar::setCurrentIndexAlwaysAtBottom(bool b)
+{
+	if (b == d->indexAlwaysAtBottom)
+		return;
+
+	d->indexAlwaysAtBottom = b;
+	layoutTabs();
+}
+
+bool TabBar::currentIndexAlwaysAtBottom() const
+{
+	return d->indexAlwaysAtBottom;
+}
+
+QSize TabBar::minimumSizeHint() const
+{
+	return QSize(0, sizeHint().height());
+}
+
+QSize TabBar::sizeHint() const
+{
+	// use own sizeHint only for single row mode
+	if (!d->multiRow) {
+		return QTabBar::sizeHint();
+	}
+
+	QList<PsiStyleOptionTab> tabs = d->hackedTabs;
+
+	QRect rect;
+	for (int i=0; i < tabs.size(); i++) {
+		rect = rect.united(tabs.at(i).rect);
+	}
+
+	QSize size = rect.size();
+	size.setWidth(width());
+	return size;
+}
+
+QSize TabBar::tabSizeHint(int index) const
+{
+	// use own sizeHint only for single row mode
+	if (!d->multiRow) {
+		return QTabBar::tabSizeHint(index);
+	}
+
+	if (index < 0 || d->hackedTabs.size() <= index) {
+		return QSize();
+	}
+
+	PsiStyleOptionTab opt = d->hackedTabs.at(index);
+	return d->tabSizeHint(opt);
+}
+
+void TabBar::setTabsClosable(bool b)
+{
+	if (!d->multiRow) {
+		QTabBar::setTabsClosable(b);
+		return;
+	}
+
+	if (d->tabsClosable == b) {
+		return;
+	}
+
+	d->tabsClosable = b;
+	d->balanseCloseButtons();
+	d->layoutTabs();
+}
+
+bool TabBar::tabsClosable() const
+{
+	return d->tabsClosable;
+}
+
+// stealed from qtabbar_p.h
+static void initStyleBaseOption(PsiStyleOptionTabBarBase *optTabBase, QTabBar *tabbar, QSize size)
+{
+	QStyleOptionTab tabOverlap;
+	tabOverlap.shape = tabbar->shape();
+	int overlap = tabbar->style()->pixelMetric(QStyle::PM_TabBarBaseOverlap, &tabOverlap, tabbar);
+	QWidget *theParent = tabbar->parentWidget();
+	optTabBase->init(tabbar);
+	optTabBase->shape = tabbar->shape();
+	optTabBase->documentMode = tabbar->documentMode();
+	if (theParent && overlap > 0) {
+		QRect rect;
+		switch (tabOverlap.shape) {
+		case QTabBar::RoundedNorth:
+		case QTabBar::TriangularNorth:
+			rect.setRect(0, size.height()-overlap, size.width(), overlap);
+			break;
+		case QTabBar::RoundedSouth:
+		case QTabBar::TriangularSouth:
+			rect.setRect(0, 0, size.width(), overlap);
+			break;
+		case QTabBar::RoundedEast:
+		case QTabBar::TriangularEast:
+			rect.setRect(0, 0, overlap, size.height());
+			break;
+		case QTabBar::RoundedWest:
+		case QTabBar::TriangularWest:
+			rect.setRect(size.width() - overlap, 0, overlap, size.height());
+			break;
+		}
+		optTabBase->rect = rect;
+	}
+}
+
+void TabBar::paintEvent(QPaintEvent *event)
+{
+	// use own painting only for multi row mode
+	if (!d->multiRow) {
+		QTabBar::paintEvent(event);
+		return;
+	}
+
+	QStylePainter p(this);
+	QList<PsiStyleOptionTab> tabs = d->hackedTabs;
+
+	for (int i = 0; i < tabs.size() && i < d->pinnedTabs; ++i) {
+		tabs[i].leftButtonSize = QSize();
+		tabs[i].rightButtonSize = QSize();
+	}
+
+	int selected = currentIndex();
+	if (drawBase()) {
+		PsiStyleOptionTabBarBase optTabBase;
+		initStyleBaseOption(&optTabBase, this, size());
+
+		if (selected >= 0) {
+			optTabBase.selectedTabRect = tabs[selected].rect;
+		}
+
+		for (int i = 0; i < tabs.size(); ++i)
+			optTabBase.tabBarRect |= tabs[i].rect;
+
+		p.drawPrimitive(QStyle::PE_FrameTabBarBase, optTabBase);
+	}
+
+	int rowHeight = 0;
+	if (selected >= 0) {
+		rowHeight = tabs[selected].rect.height();
+	} else if (tabs.count()) {
+		rowHeight = tabs[0].rect.height();
+	}
+
+	// There is some problems when tabs are painted not in first row.
+	// Draw on a pixmap like a painting in the first row. Then move image
+	// to real TabBar widget.
+	QPixmap pixmap(width(), rowHeight);
+	pixmap.fill(Qt::transparent);
+	QStylePainter pp(&pixmap, this);
+	bool drawSelected = false;
+	QPixmap pinPixmap = IconsetFactory::iconPixmap("psi/pin");
+	for (int i = 0; i < tabs.size(); i++) {
+		PsiStyleOptionTab tab = tabs[i];
+		if (i != selected) {
+			if (i == d->hoverTab)
+				tab.state |= QStyle::State_MouseOver;
+
+			if (shape() == QTabBar::RoundedNorth)
+				tab.rect.moveBottom(rowHeight - 1);
+			else
+				tab.rect.moveTop(0);
+
+			// Just dd.drawControl works incorrect with KDE5 breeze style
+			pp.style()->drawControl(QStyle::CE_TabBarTab, &tab, &pp);
+			if (i < d->pinnedTabs) {
+				pp.drawPixmap(tab.rect.topRight() - QPoint(pinPixmap.width(), -3), pinPixmap);
+			}
+		}
+		else {
+			drawSelected = true;
+		}
+
+
+		if (tab.position == QStyleOptionTab::End || tab.position == QStyleOptionTab::OnlyOneTab) {
+			if (drawSelected) {
+				// Draw current tab in the last order
+				tab = tabs.at(selected);
+				if (shape() == QTabBar::RoundedNorth)
+					tab.rect.moveBottom(rowHeight - 1);
+				else
+					tab.rect.moveTop(0);
+
+				// Draw tab shape
+				// Use red color as tab frame
+				QPalette oldPalette = tab.palette;
+				tab.palette.setColor(QPalette::Foreground, Qt::red);
+				tab.palette.setColor(QPalette::Light, Qt::red);
+				tab.palette.setColor(QPalette::Dark, Qt::red);
+				pp.drawControl(QStyle::CE_TabBarTabShape, tab);
+				tab.palette = oldPalette;
+
+				// Use bold font for current tab
+				QFont f = pp.font();
+				f.setBold(true);
+				pp.save();
+				pp.setFont(f);
+				pp.drawControl(QStyle::CE_TabBarTabLabel, tab);
+				pp.restore();
+
+				if (selected < d->pinnedTabs) {
+					pp.drawPixmap(tab.rect.topRight() - QPoint(pinPixmap.width(), -3), pinPixmap);
+				}
+
+				drawSelected = false;
+			}
+
+			QRect rect(0, tabs.at(i).rect.top(), width(), rowHeight);
+			p.drawItemPixmap(rect, Qt::AlignCenter, pixmap);
+			pixmap.fill(Qt::transparent);
+		}
+	}
+
+	ButtonPosition closeSide = (QTabBar::ButtonPosition)style()->styleHint(QStyle::SH_TabBar_CloseButtonPosition, 0, this);
+	QStyle::SubElement se = (closeSide == LeftSide ? QStyle::SE_TabBarTabLeftButton : QStyle::SE_TabBarTabRightButton);
+	if (d->tabsClosable) {
+		for (int i = 0; i < tabs.size(); i++) {
+			PsiStyleOptionTab opt;
+			opt = tabs.at(i);
+
+			QRect rect = style()->subElementRect(se, &opt, this);
+			rect.setTop(rect.top() + opt.rect.top());
+			QPoint p = rect.topLeft();
+			d->closeButtons.at(i)->move(p);
+		}
+	}
+
+	// Draw tab inserting position
+	if (d->dragInsertIndex > -1) {
+		QLine line;
+		if (d->dragInsertIndex == d->dragHoverTab) {
+			line.setP1(tabs[d->dragHoverTab].rect.topLeft());
+			line.setP2(tabs[d->dragHoverTab].rect.bottomLeft());
+		}
+		else {
+			line.setP1(tabs[d->dragHoverTab].rect.topRight());
+			line.setP2(tabs[d->dragHoverTab].rect.bottomRight());
+		}
+		p.save();
+		p.setPen(Qt::red);
+		p.drawLine(line);
+		p.restore();
+	}
+}
+
+void TabBar::mousePressEvent(QMouseEvent *event)
+{
+	if (!d->multiRow) {
+		QTabBar::mousePressEvent(event);
+	}
+	else {
+		d->mousePressPoint = event->pos();
+		event->accept();
+	}
+}
+
+void TabBar::mouseReleaseEvent(QMouseEvent *event)
+{
+	if (!d->multiRow) {
+		QTabBar::mouseReleaseEvent(event);
+		return;
+	}
+
+	if (event->button() != Qt::LeftButton) {
+		event->ignore();
+		return;
+	}
+
+	int curTab = -1;
+	for (int i = 0; i < count(); i++) {
+		if (d->hackedTabs.at(i).rect.contains(event->pos())) {
+			curTab = i;
+			break;
+		}
+	}
+
+	if (curTab < 0)
+		return;
+
+
+	setCurrentIndex(curTab);
+	d->layoutTabs();
+}
+
+void TabBar::mouseMoveEvent(QMouseEvent *event)
+{
+	if (d->multiRow && event->buttons() == Qt::NoButton) {
+		int newHoverTab = tabAt(event->pos());
+		if (newHoverTab != d->hoverTab) {
+			d->hoverTab = newHoverTab;
+			update();
+		}
+	}
+
+	if (!d->dragsEnabled)
+		return;
+
+	if (!(event->buttons() & Qt::LeftButton))
+		return;
+
+	if (!d->multiRow) {
+		QTabBar::mouseMoveEvent(event);
+	}
+	else {
+		if (d->dragTab == -1) {
+			if ((event->pos() - d->mousePressPoint).manhattanLength() >= QApplication::startDragDistance()) {
+				// Do not allow to drag single pinned tab
+				int tab = tabAt(d->mousePressPoint);
+				if (tab != 0 || d->pinnedTabs != 1)
+					d->dragTab = tab;
+				update();
+			}
+		}
+		if (d->dragTab > -1) {
+			PsiStyleOptionTab tab = d->hackedTabs[d->dragTab];
+			QPixmap pixmap(tab.rect.size());
+			tab.rect.moveTo(0, 0);
+			tab.state = QStyle::State_Active | QStyle::State_Enabled | QStyle::State_Selected;
+			pixmap.fill(Qt::transparent);
+			QStylePainter pp(&pixmap, this);
+			QFont f = pp.font();
+			f.setBold(true);
+			pp.setFont(f);
+			pp.style()->drawControl(QStyle::CE_TabBarTab, &tab, &pp);
+
+			QDrag *drag = new QDrag(this);
+			drag->setMimeData(new QMimeData);
+			drag->setPixmap(pixmap);
+			QPoint hotSpot = event->pos() - d->hackedTabs[d->dragTab].rect.topLeft();
+			if (hotSpot.x() < 0)
+				hotSpot.setX(0);
+			else if (hotSpot.x() > tab.rect.width())
+				hotSpot.setX(tab.rect.width());
+
+			if (hotSpot.y() < 0)
+				hotSpot.setY(0);
+			else if (hotSpot.y() > tab.rect.height())
+				hotSpot.setY(tab.rect.height());
+
+			drag->setHotSpot(hotSpot);
+			drag->exec();
+
+			d->hoverTab = -1;
+		}
+	}
+}
+
+void TabBar::dragMoveEvent(QDragMoveEvent *event)
+{
+	int newDragHoverTab = tabAt(event->pos());
+	int newDragInsertIndex = newDragHoverTab;
+
+	// Try to guess that need to insert in the end
+	if (newDragHoverTab == -1) {
+		QPoint p = d->hackedTabs.last().rect.topRight();
+		if (event->pos().x() > p.x() && event->pos().y() > p.y()) {
+			newDragHoverTab = d->hackedTabs.size() - 1;
+			newDragInsertIndex = newDragHoverTab;
+		}
+	}
+
+	if (newDragInsertIndex > -1) {
+		int x = event->pos().x() - d->hackedTabs[newDragInsertIndex].rect.left();
+		if (x * 2 > d->hackedTabs[newDragInsertIndex].rect.width())
+			newDragInsertIndex++;
+	}
+
+	if ((newDragInsertIndex != d->dragInsertIndex || newDragHoverTab != d->dragHoverTab)
+		&& ((d->dragTab >= d->pinnedTabs && newDragInsertIndex >= d->pinnedTabs)
+			|| (d->dragTab < d->pinnedTabs && newDragInsertIndex <= d->pinnedTabs))) {
+		d->dragInsertIndex = newDragInsertIndex;
+		d->dragHoverTab = newDragHoverTab;
+		update();
+	}
+}
+
+void TabBar::dragEnterEvent(QDragEnterEvent *event)
+{
+	if (event->source() == this) {
+		event->accept();
+	} else {
+		event->ignore();
+	}
+}
+
+void TabBar::dragLeaveEvent(QDragLeaveEvent *event)
+{
+	Q_UNUSED(event);
+
+	d->dragHoverTab = -1;
+	d->dragInsertIndex = -1;
+	update();
+}
+
+void TabBar::dropEvent(QDropEvent *event)
+{
+	if (event->source() == this) {
+		if (d->dragInsertIndex > -1 && d->dragInsertIndex != d->dragTab && d->dragInsertIndex != d->dragTab + 1) {
+			int curTab = d->dragInsertIndex > d->dragTab ? d->dragInsertIndex - 1 : d->dragInsertIndex;
+			moveTab(d->dragTab, curTab);
+			d->layoutTabs();
+			setCurrentIndex(curTab);
+		}
+		d->dragTab = -1;
+		d->dragInsertIndex = -1;
+		update();
+	}
+}
+
+void TabBar::leaveEvent(QEvent *event)
+{
+	if (d->hoverTab != -1) {
+		d->hoverTab = -1;
+		update();
+	}
+	QTabBar::leaveEvent(event);
+}
+
+void TabBar::tabInserted(int index)
+{
+	QTabBar::tabInserted(index);
+
+	if (!d->multiRow) {
+		return;
+	}
+
+	d->balanseCloseButtons();
+	d->layoutTabs();
+
+}
+
+void TabBar::tabRemoved(int index)
+{
+	QTabBar::tabRemoved(index);
+
+	if (!d->multiRow) {
+		return;
+	}
+
+	if (index < d->pinnedTabs)
+		d->pinnedTabs--;
+
+	d->balanseCloseButtons();
+	d->layoutTabs();
+}
+
+void TabBar::closeTab()
+{
+	CloseButton *cb = qobject_cast<CloseButton*>(sender());
+	int index = d->closeButtons.indexOf(cb);
+	emit tabCloseRequested(index);
+}
+
+CloseButton::CloseButton(QWidget *parent)
+	: QAbstractButton(parent)
+{
+	setFocusPolicy(Qt::NoFocus);
+	setCursor(Qt::ArrowCursor);
+	setToolTip(tr("Close Tab"));
+	resize(sizeHint());
+}
+
+QSize CloseButton::sizeHint() const
+{
+	ensurePolished();
+	int width = style()->pixelMetric(QStyle::PM_TabCloseIndicatorWidth, 0, this);
+	int height = style()->pixelMetric(QStyle::PM_TabCloseIndicatorHeight, 0, this);
+	return QSize(width, height);
+}
+
+void CloseButton::enterEvent(QEvent *event)
+{
+	if (isEnabled())
+		update();
+	QAbstractButton::enterEvent(event);
+}
+
+void CloseButton::leaveEvent(QEvent *event)
+{
+	if (isEnabled())
+		update();
+	QAbstractButton::leaveEvent(event);
+}
+
+void CloseButton::paintEvent(QPaintEvent *)
+{
+	QPainter p(this);
+	QStyleOption opt;
+	opt.init(this);
+	opt.state |= QStyle::State_AutoRaise;
+	if (isEnabled() && underMouse() && !isChecked() && !isDown())
+		opt.state |= QStyle::State_Raised;
+	if (isChecked())
+		opt.state |= QStyle::State_On;
+	if (isDown())
+		opt.state |= QStyle::State_Sunken;
+
+	if (const TabBar *tb = qobject_cast<const TabBar*>(parent())) {
+		int index = tb->currentIndex();
+		if (index >= 0) {
+			QTabBar::ButtonPosition position = static_cast<QTabBar::ButtonPosition>(style()->styleHint(QStyle::SH_TabBar_CloseButtonPosition, 0, tb));
+			if (tb->tabButton(index, position) == this)
+				opt.state |= QStyle::State_Selected;
+		}
+	}
+
+	style()->drawPrimitive(QStyle::PE_IndicatorTabClose, &opt, &p, this);
+}
+
+#include "tabbar.moc"
--- /dev/null
+++ b/src/widgets/tabbar.h
@@ -0,0 +1,82 @@
+/*
+ * tabbar.h
+ * Copyright (C) 2013-2014  Ivan Romanov <drizt@land.ru>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#pragma once
+
+#include <QTabBar>
+
+class TabBar : public QTabBar
+{
+	Q_OBJECT
+public:
+	explicit TabBar(QWidget *parent = 0);
+	~TabBar();
+
+	void layoutTabs();
+
+	void setMultiRow(bool b);
+	bool multiRow() const;
+
+	void setDragsEnabled(bool enabled); // default enabled
+	void setTabPinned(int index, bool pinned);
+	bool isTabPinned(int index);
+
+	void setCurrentIndexAlwaysAtBottom(bool b);
+	bool currentIndexAlwaysAtBottom() const;
+
+	// reimplemented
+	QSize minimumSizeHint() const;
+	QSize sizeHint() const;
+	QSize tabSizeHint(int index) const;
+	void setTabsClosable(bool b);
+	bool tabsClosable() const;
+	void setCurrentIndex(int index);
+	void setTabText(int index, const QString &text);
+	void setTabTextColor(int index, const QColor &color);
+	void setTabIcon(int index, const QIcon &icon);
+	QRect tabRect(int index) const;
+	QWidget *tabButton(int index, ButtonPosition position) const;
+	int tabAt(const QPoint &position) const;
+	bool eventFilter(QObject *watched, QEvent *event);
+	void setUpdateEnabled(bool b);
+
+protected:
+	// reimplemented
+	void paintEvent(QPaintEvent *event);
+	void mousePressEvent(QMouseEvent *event);
+	void mouseReleaseEvent(QMouseEvent *event);
+	void mouseMoveEvent(QMouseEvent *event);
+
+	void dragMoveEvent(QDragMoveEvent *event);
+	void dragEnterEvent(QDragEnterEvent *event);
+	void dragLeaveEvent(QDragLeaveEvent *event);
+	void dropEvent(QDropEvent *event);
+
+	void leaveEvent(QEvent *event);
+	void tabInserted(int index);
+	void tabRemoved(int index);
+
+private slots:
+	void closeTab();
+
+private:
+	class Private;
+	Private *d;
+};
--- a/src/widgets/widgets.pri
+++ b/src/widgets/widgets.pri
@@ -18,8 +18,8 @@ SOURCES += \
 	$$PWD/psitabbar.cpp \
 	$$PWD/psiwindowheader.cpp \
 	$$PWD/actionlineedit.cpp \
-	$$PWD/typeaheadfind.cpp
-
+	$$PWD/typeaheadfind.cpp \
+	$$PWD/tabbar.cpp
 
 HEADERS += \
 	$$PWD/stretchwidget.h \
@@ -46,7 +46,8 @@ HEADERS += \
 	$$PWD/psitabbar.h \
 	$$PWD/psiwindowheader.h \
 	$$PWD/actionlineedit.h \
-	$$PWD/typeaheadfind.h
+	$$PWD/typeaheadfind.h \
+	$$PWD/tabbar.h
 
 FORMS += $$PWD/fancypopup.ui \
 	$$PWD/psiwindowheader.ui
