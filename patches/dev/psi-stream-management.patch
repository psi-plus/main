--- psi.orig/iris/src/xmpp/xmpp-core/protocol.cpp
+++ psi/iris/src/xmpp/xmpp-core/protocol.cpp
@@ -34,8 +34,6 @@
 #include "td.h"
 #endif
 
-//#define IRIS_SM_DEBUG
-
 using namespace XMPP;
 
 // printArray
@@ -598,10 +596,6 @@ CoreProtocol::CoreProtocol()
 :BasicProtocol()
 {
 	init();
-	sm_resumption_supported = false;
-	sm_resumption_id = "";
-	sm_receive_count = 0;
-	sm_server_last_handled = 0;
 }
 
 CoreProtocol::~CoreProtocol()
@@ -639,7 +633,7 @@ void CoreProtocol::init()
 	sasl_started = false;
 	compress_started = false;
 
-	sm_started = false;
+	sm.reset();
 }
 
 void CoreProtocol::reset()
@@ -649,31 +643,18 @@ void CoreProtocol::reset()
 }
 
 void CoreProtocol::startTimer(int seconds) {
-	sm_ack_last_requested.start();
 	notify |= NTimeout;
 	need = NNotify;
 	timeout_sec = seconds;
 }
 
-void CoreProtocol::sendStanza(const QDomElement &e, bool notify) {
-	if (isStreamManagementActive()) {
-#ifdef XMPP_TEST
-		if (notify) qDebug() << "Want notification for stanza";
-#endif
-		sm_send_queue.push_back(qMakePair(e, notify));
-#ifdef IRIS_SM_DEBUG
-		qDebug() << "sm_send_queue: ";
-#endif
-		for (QList<QPair<QDomElement, bool> >::iterator i = sm_send_queue.begin(); i != sm_send_queue.end(); ++i) {
-			QPair<QDomElement, bool> entry = *i;
-#ifdef IRIS_SM_DEBUG
-			qDebug() << "\t" << entry.first.tagName() << " : " << entry.second;
-#endif
-		}
-		if (sm_send_queue.length() > 5 && sm_send_queue.length() % 4 == 0) requestSMAcknowlegement();
-		startTimer(20);
+void CoreProtocol::sendStanza(const QDomElement &e) {
+	if (sm.isActive()) {
+		int len = sm.addUnacknowledgedStanza(e);
+		if (len > 5 && len % 4 == 0)
+			if (needSMRequest())
+				event = ESend;
 	}
-	//qDebug() << "CoreProtocol::sendStanza";
 	BasicProtocol::sendStanza(e);
 }
 
@@ -777,12 +758,11 @@ bool CoreProtocol::loginComplete()
 	setReady(true);
 
 	// deal with stream management
-	if(!sm_started && features.sm_supported) {
-		if (sm_resumption_supported && sm_resumption_id != "") {
+	if (features.sm_supported && sm.state().isEnabled() && !sm.isActive()) {
+		if (sm.state().isResumption()) {
 			QDomElement e = doc.createElementNS(NS_STREAM_MANAGEMENT, "resume");
-			e.setAttribute("previd", sm_resumption_id);
-			qulonglong lasthandledid = getSMLastHandledId();
-			e.setAttribute("h", lasthandledid);
+			e.setAttribute("previd", sm.state().resumption_id);
+			e.setAttribute("h", sm.state().received_count);
 			send(e);
 		} else {
 			QDomElement e = doc.createElementNS(NS_STREAM_MANAGEMENT, "enable");
@@ -948,147 +928,39 @@ bool CoreProtocol::streamManagementHandl
 {
 	QString s = e.tagName();
 	if(s == "r") {
-		qulonglong last_handled_id = getSMLastHandledId();
-		QDomElement e = doc.createElementNS(NS_STREAM_MANAGEMENT, "a");
-		e.setAttribute("h", last_handled_id);
 #ifdef IRIS_SM_DEBUG
-		qWarning() << "Stream Management: Sending acknowledgment with h=" << last_handled_id;
+		qDebug() << "Stream Management: [<-?] Received request from server";
 #endif
-		send(e);
+		send(sm.makeResponseStanza(doc));
 		event = ESend;
 		return true;
 	} else if (s == "a") {
+		quint32 last_id = e.attribute("h").toULong();
 #ifdef IRIS_SM_DEBUG
-		qWarning() << "Received ack response from server";
+		qDebug() << "Stream Management: [<--] Received ack response from server with h =" << last_id;
 #endif
-		processSMAcknowlegement(e.attribute("h").toULong());
+		sm.processAcknowledgement(last_id);
+		startTimer(SM_TIMER_INTERVAL_SECS);
 		event = EAck;
 		return true;
 	} else {
+		if (sm.processNormalStanza(e))
+			startTimer(SM_TIMER_INTERVAL_SECS);
 		need = NNotify;
 		notify |= NRecv;
 		return false;
 	}
 }
 
-unsigned long CoreProtocol::getNewSMId() {
-	unsigned long sm_id = sm_receive_count;
-	sm_receive_queue.push_back(qMakePair(sm_id, false));
-	sm_receive_count++;
-	if (sm_receive_count == (unsigned long)-1) sm_receive_count = 0; /* why do we skip -1? */
-#ifdef IRIS_SM_DEBUG
-	qWarning() << "Current SM id: " << sm_id;
-#endif
-	return sm_id;
-}
-
-unsigned long CoreProtocol::getSMLastHandledId() {
-	if (sm_receive_queue.isEmpty()) {
-		return sm_receive_count - 1;
-	} else {
-		QPair<unsigned long, bool> queue_item;
-		unsigned long last_handled_id = sm_receive_count - 1;;
-		do {
-			queue_item = sm_receive_queue.front();
-			if (queue_item.second == true) {
-				last_handled_id = queue_item.first;
-				sm_receive_queue.pop_front();
-			}
-		} while (queue_item.second == true && !sm_receive_queue.isEmpty());
-		return last_handled_id;
-	}
-}
-
-void CoreProtocol::markStanzaHandled(unsigned long id) {
-	for(QList<QPair<unsigned long, bool> >::Iterator it = sm_receive_queue.begin(); it != sm_receive_queue.end(); ++it ) {
-		if (it->first == id) {
-			it->second = true;
-			return;
-		}
-	}
-#ifdef IRIS_SM_DEBUG
-	qWarning() << "Stream Management: Higher level client marked unknown stanza handled!";
-#endif
-}
-
-void CoreProtocol::markLastMessageStanzaAcked() {
-	if (sm_receive_queue.isEmpty()) {
-#ifdef IRIS_SM_DEBUG
-		qWarning() << "Stream Management: Higher level client marked unexistant stanza as acked.";
-#endif
-		return;
-	}
-#ifdef IRIS_SM_DEBUG
-	qWarning() << "Previous list: " << sm_receive_queue;
-#endif
-	for(QList<QPair<unsigned long, bool> >::Iterator it = sm_receive_queue.begin(); it != sm_receive_queue.end(); ++it ) {
-		if (it->second == false) {
-			it->second = true;
-			return;
-		}
-	}
-}
-
-bool CoreProtocol::isStreamManagementActive() const {
-	return sm_started;
-}
-
-void CoreProtocol::requestSMAcknowlegement() {
-#ifdef IRIS_SM_DEBUG
-	qDebug() << "Now I'd request acknowledgement from the server.";
-#endif
-	sendDirect(QString("<r xmlns='" NS_STREAM_MANAGEMENT "'/>"));
-	startTimer(20);
-}
-
-int CoreProtocol::getNotableStanzasAcked() {
-	return sm_stanzas_notify;
-}
-
-ClientStream::SMState CoreProtocol::getSMState() const {
-#ifdef IRIS_SM_DEBUG
-	qDebug("\tCoreProtocol::getSMState()");
-#endif
-	ClientStream::SMState state;
-	state.sm_receive_queue = sm_receive_queue;
-	state.sm_send_queue = sm_send_queue;
-	state.sm_receive_count = sm_receive_count;
-
-	state.sm_server_last_handled = sm_server_last_handled;
-	state.sm_stanzas_notify = sm_stanzas_notify;
-
-	state.sm_resumtion_supported = sm_resumption_supported;
-	state.sm_resumption_id = sm_resumption_id;
-	state.sm_resumption_location = sm_resumption_location;
-	return state;
-}
-
-void CoreProtocol::setSMState(ClientStream::SMState &state) {
-	fprintf(stderr, "\tCoreProtocol::setSMState()\n");
-	sm_receive_queue = state.sm_receive_queue;
-	sm_send_queue = state.sm_send_queue;
-	sm_receive_count = state.sm_receive_count;
-
-	sm_server_last_handled = state.sm_server_last_handled;
-	sm_stanzas_notify = state.sm_stanzas_notify;
-
-	sm_resumption_supported = state.sm_resumtion_supported;
-	sm_resumption_id = state.sm_resumption_id;
-}
-
-void CoreProtocol::processSMAcknowlegement(unsigned long last_handled) {
-	int handled_stanzas = 0;
-	int notifies = 0;
-	if (sm_server_last_handled == 0) handled_stanzas = last_handled + 1;
-	else handled_stanzas = last_handled - sm_server_last_handled;
-	sm_server_last_handled = last_handled;
-
-	for (int n = 0; n < handled_stanzas && !sm_send_queue.isEmpty() ; ++n) {
-		QPair<QDomElement, bool> entry = sm_send_queue.first();
-		sm_send_queue.pop_front();
-		if (entry.second) notifies++;
+bool CoreProtocol::needSMRequest()
+{
+	QDomElement e = sm.generateRequestStanza(doc);
+	if (!e.isNull()) {
+		send(e);
+		startTimer(SM_TIMER_INTERVAL_SECS);
+		return true;
 	}
-	sm_stanzas_notify = notifies;
+	return false;
 }
 
 bool CoreProtocol::grabPendingItem(const Jid &to, const Jid &from, int type, DBItem *item)
@@ -1317,9 +1189,8 @@ bool CoreProtocol::normalStep(const QDom
 			return true;
 		}
 
-		if (sm_resumption_supported && sm_resumption_id != "") {
+		if (sm.state().isResumption()) {
 			// try to resume;
-			fprintf(stderr, "\tResume session\n");
 			return loginComplete();
 		} else {
 			QDomElement e = doc.createElement("iq");
@@ -1900,28 +1771,29 @@ bool CoreProtocol::normalStep(const QDom
 		if (e.namespaceURI() == NS_STREAM_MANAGEMENT) {
 			if (e.localName() == "enabled") {
 #ifdef IRIS_SM_DEBUG
-				qWarning() << "Stream Management enabled";
+				qDebug() << "Stream Management: [INF] Enabled";
 #endif
-				sm_started = true;
-				if (e.attribute("resume", "false") == "true" || e.attribute("resume", "false") == "1") {
+				QString rs = e.attribute("resume");
+				QString id = (rs == "true" || rs == "1") ? e.attribute("id") : QString();
+				sm.started(id);
+				if (!id.isEmpty()) {
 #ifdef IRIS_SM_DEBUG
-					qDebug("\tResumption Supported");
+					qDebug() << "Stream Management: [INF] Resumption Supported";
 #endif
-					sm_resumption_supported = true;
-					sm_resumption_id = e.attribute("id", "");
-
-					if (!e.attribute("location").isEmpty()) {
+					QString location = e.attribute("location").trimmed();
+					if (!location.isEmpty()) {
 						int port_off = 0;
 						QStringRef sm_host;
 						int sm_port = -1;
-						QString location = e.attribute("location");
-						if (location[0] == '[') { // ipv6
+						if (location.startsWith('[')) { // ipv6
 							port_off = location.indexOf(']');
 							if (port_off != -1) { // looks valid
 								sm_host = location.midRef(1, port_off - 1);
+								if (location.length() > port_off + 2 && location.at(port_off + 1) == ':')
+									sm_port = location.mid(port_off + 2).toInt();
 							}
 						}
-						if (port_off != -1) { // -1 means previous ipv6 parse failed
+						if (port_off == 0) {
 							port_off = location.indexOf(':');
 							if (port_off != -1) {
 								sm_host = location.leftRef(port_off);
@@ -1930,25 +1802,29 @@ bool CoreProtocol::normalStep(const QDom
 								sm_host = location.midRef(0);
 							}
 						}
-						if (!sm_host.isEmpty() && sm_port) {
-							sm_resumption_location = QPair<QString,int>(sm_host.toString(), sm_port);
-						}
+						sm.setLocation(sm_host.toString(), sm_port);
 					}
 
-					startTimer(20);
+					startTimer(SM_TIMER_INTERVAL_SECS);
 					event = EReady;
 					step = Done;
 					return true;
 				}
 			} else if (e.localName() == "resumed") {
-				processSMAcknowlegement(e.attribute("h").toULong());
-				startTimer(20);
+				sm.resumed(e.attribute("h").toULong());
+				while(true) {
+					QDomElement st = sm.getUnacknowledgedStanza();
+					if (st.isNull())
+						break;
+					send(st);
+				}
+				startTimer(SM_TIMER_INTERVAL_SECS);
 				event = EReady;
 				step = Done;
 				return true;
 			} else if (e.localName() == "failed") {
-				if (!sm_resumption_id.isEmpty()) { // tried to resume? ok, then try to just enable
-					sm_resumption_id.clear();
+				if (sm.state().isResumption()) { // tried to resume? ok, then try to just enable
+					sm.state().resumption_id.clear();
 					step = HandleFeatures;
 					event = EFeatures;
 					return true;
@@ -1957,20 +1833,25 @@ bool CoreProtocol::normalStep(const QDom
 		}
 	}
 
-	if (isStreamManagementActive()) {
-		if (sm_ack_last_requested.elapsed() >= 20000) {
-			requestSMAcknowlegement();
+	if(isReady()) {
+		if (!e.isNull()) {
+			if(isValidStanza(e)) {
+				stanzaToRecv = e;
+				event = EStanzaReady;
+				setIncomingAsExternal();
+				return true;
+			} else if (sm.isActive()) {
+				return streamManagementHandleStanza(e);
+			}
 		}
-	}
-
-	if(isReady() && !e.isNull()) {
-		if(isValidStanza(e)) {
-			stanzaToRecv = e;
-			event = EStanzaReady;
-			setIncomingAsExternal();
-			return true;
-		} else if (sm_started) {
-			return streamManagementHandleStanza(e);
+		if (sm.isActive()) {
+			if (sm.lastAckElapsed() >= SM_TIMER_INTERVAL_SECS) {
+				if (needSMRequest())
+					event = ESend;
+				else
+					event = ESMConnTimeout;
+				return true;
+			}
 		}
 	}
 
--- psi.orig/iris/src/xmpp/xmpp-core/protocol.h
+++ psi/iris/src/xmpp/xmpp-core/protocol.h
@@ -29,6 +29,7 @@
 
 #include "xmlprotocol.h"
 #include "xmpp.h"
+#include "sm.h"
 
 #define NS_ETHERX   "http://etherx.jabber.org/streams"
 #define NS_CLIENT   "jabber:client"
@@ -43,7 +44,6 @@
 #define NS_COMPRESS_FEATURE "http://jabber.org/features/compress"
 #define NS_COMPRESS_PROTOCOL "http://jabber.org/protocol/compress"
 #define NS_HOSTS    "http://barracuda.com/xmppextensions/hosts"
-#define NS_STREAM_MANAGEMENT  "urn:xmpp:sm:xxx"
 
 namespace XMPP
 {
@@ -266,7 +266,7 @@ namespace XMPP
 		void startTimer(int seconds);
 
 		// reimplemented to do SM
-		void sendStanza(const QDomElement &e, bool notify = false);
+		void sendStanza(const QDomElement &e);
 
 		void startClientOut(const Jid &jid, bool oldOnly, bool tlsActive, bool doAuth, bool doCompression);
 		void startServerOut(const QString &to);
@@ -285,16 +285,6 @@ namespace XMPP
 		void setFrom(const QString &s);
 		void setDialbackKey(const QString &s);
 
-		unsigned long getNewSMId();
-		void markStanzaHandled(unsigned long id);
-		void markLastMessageStanzaAcked();
-
-		bool isStreamManagementActive() const;
-		int getNotableStanzasAcked();
-
-		ClientStream::SMState getSMState() const;
-		void setSMState(ClientStream::SMState &state);
-
 		// input
 		QString user, host;
 
@@ -306,6 +296,8 @@ namespace XMPP
 
 		//static QString xmlToString(const QDomElement &e, bool clip=false);
 
+		StreamManagement sm;
+
 		class DBItem
 		{
 		public:
@@ -337,27 +329,16 @@ namespace XMPP
 			GetAuthGetResponse, // read auth-get response
 			HandleAuthSet,      // send old-protocol auth-set
 			GetAuthSetResponse, // read auth-set response
-			GetSMResponse
+			GetSMResponse       // read SM init response
 		};
 
 		QList<DBItem> dbrequests, dbpending, dbvalidated;
 
-		QList<QPair<unsigned long, bool> > sm_receive_queue;
-		QList<QPair<QDomElement, bool> > sm_send_queue;
-		unsigned long sm_receive_count;
-		QTime sm_ack_last_requested;
-		unsigned long sm_server_last_handled;
-		int sm_stanzas_notify;
-
-		bool sm_resumption_supported;
-		QString sm_resumption_id;
-		QPair<QString,int> sm_resumption_location;
-
 		bool server, dialback, dialback_verify;
 		int step;
 
 		bool digest;
-		bool tls_started, sasl_started, compress_started, sm_started;
+		bool tls_started, sasl_started, compress_started;
 
 		Jid jid_;
 		bool oldOnly;
@@ -378,9 +359,7 @@ namespace XMPP
 		bool normalStep(const QDomElement &e);
 		bool dialbackStep(const QDomElement &e);
 
-		unsigned long getSMLastHandledId();
-		void requestSMAcknowlegement();
-		void processSMAcknowlegement(unsigned long last_handled);
+		bool needSMRequest();
 
 		// reimplemented
 		bool stepAdvancesParser() const;
--- psi.orig/iris/src/xmpp/xmpp-core/sm.cpp
+++ psi/iris/src/xmpp/xmpp-core/sm.cpp
@@ -0,0 +1,181 @@
+/*
+ * sm.cpp - XMPP Stream Management protocol
+ * Copyright (C) 2016  Aleksey Andreev
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifdef IRIS_SM_DEBUG
+#include <QDebug>
+#endif
+
+
+#include "sm.h"
+
+using namespace XMPP;
+
+SMState::SMState()
+{
+	reset();
+}
+
+void SMState::reset()
+{
+	enabled = false;
+	received_count = 0;
+	server_last_handled = 0;
+	send_queue.clear();
+	resumption_id.clear();
+	resumption_location.host.clear();
+	resumption_location.port = -1;
+}
+
+
+StreamManagement::StreamManagement(QObject *parent)
+	: QObject(parent)
+	, sm_started(false)
+	, sm_resumed(false)
+	, sm_stanzas_notify(0)
+	, sm_resend_pos(0)
+{
+}
+
+void StreamManagement::reset()
+{
+	sm_started = false;
+	sm_resumed = false;
+	sm_stanzas_notify = 0;
+	sm_resend_pos = 0;
+	sm_timeout_data.pause_mode = true;
+	sm_timeout_data.point_time = QDateTime();
+	//state_.reset();
+}
+
+void StreamManagement::started(const QString &resumption_id)
+{
+	reset();
+	state_.resumption_id = resumption_id;
+	sm_started = true;
+}
+
+void StreamManagement::resumed(quint32 last_handled)
+{
+	sm_resumed = true;
+	sm_resend_pos = 0;
+	processAcknowledgement(last_handled);
+}
+
+void StreamManagement::setLocation(const QString &host, int port)
+{
+	state_.resumption_location.host = host;
+	state_.resumption_location.port = port;
+}
+
+int StreamManagement::lastAckElapsed() const
+{
+	if (sm_timeout_data.point_time.isNull())
+		return 0;
+	return sm_timeout_data.point_time.secsTo(QDateTime::currentDateTime());
+}
+
+int StreamManagement::takeAckedCount()
+{
+	int cnt = sm_stanzas_notify;
+	sm_stanzas_notify = 0;
+	return cnt;
+}
+
+QDomElement StreamManagement::getUnacknowledgedStanza()
+{
+	if (sm_resend_pos < state_.send_queue.size())
+		return state_.send_queue.at(sm_resend_pos++);
+	return QDomElement();
+}
+
+int StreamManagement::addUnacknowledgedStanza(const QDomElement &e)
+{
+	state_.send_queue.enqueue(e);
+	int len = state_.send_queue.length();
+#ifdef IRIS_SM_DEBUG
+	qDebug() << "Stream Management: [INF] Send queue length is changed: " << len;
+#endif
+	return len;
+}
+
+void StreamManagement::processAcknowledgement(quint32 last_handled)
+{
+	sm_timeout_data.pause_mode = true;
+	sm_timeout_data.point_time = QDateTime::currentDateTime();
+#ifdef IRIS_SM_DEBUG
+	bool f = false;
+#endif
+	while (!state_.send_queue.isEmpty() && state_.server_last_handled != last_handled) {
+		state_.send_queue.dequeue();
+		++state_.server_last_handled;
+		++sm_stanzas_notify;
+#ifdef IRIS_SM_DEBUG
+		f = true;
+#endif
+	}
+#ifdef IRIS_SM_DEBUG
+	if (f) {
+		qDebug() << "Stream Management: [INF] Send queue length is changed: " << state_.send_queue.length();
+		if (state_.send_queue.isEmpty() && last_handled != state_.server_last_handled)
+			qDebug() << "Stream Management: [ERR] Send queue is empty but last_handled != server_last_handled " << last_handled << state_.server_last_handled;
+	}
+#endif
+}
+
+bool StreamManagement::processNormalStanza(const QDomElement &e)
+{
+	Q_UNUSED(e)
+	if (!sm_timeout_data.pause_mode) {
+		sm_timeout_data.point_time = QDateTime::currentDateTime();
+		return true;
+	}
+	return false;
+}
+
+void StreamManagement::markStanzaHandled()
+{
+	++state_.received_count;
+#ifdef IRIS_SM_DEBUG
+	qDebug() << "Stream Management: [INF] current received id: " << state_.received_count;
+#endif
+}
+
+QDomElement StreamManagement::generateRequestStanza(QDomDocument &doc)
+{
+	if (sm_timeout_data.pause_mode) {
+#ifdef IRIS_SM_DEBUG
+		qDebug() << "Stream Management: [?->] Sending request of acknowledgment to server";
+#endif
+		sm_timeout_data.pause_mode = false;
+		sm_timeout_data.point_time = QDateTime::currentDateTime();
+		return doc.createElementNS(NS_STREAM_MANAGEMENT, "r");
+	}
+	return QDomElement();
+}
+
+QDomElement StreamManagement::makeResponseStanza(QDomDocument &doc)
+{
+#ifdef IRIS_SM_DEBUG
+	qDebug() << "Stream Management: [-->] Sending acknowledgment with h =" << state_.received_count;
+#endif
+	QDomElement e = doc.createElementNS(NS_STREAM_MANAGEMENT, "a");
+	e.setAttribute("h", state_.received_count);
+	return e;
+}
--- psi.orig/iris/src/xmpp/xmpp-core/sm.h
+++ psi/iris/src/xmpp/xmpp-core/sm.h
@@ -0,0 +1,92 @@
+/*
+ * sm.h - XMPP Stream Management protocol
+ * Copyright (C) 2016  Aleksey Andreev
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef XMPP_SM_H
+#define XMPP_SM_H
+
+#include <QObject>
+#include <QQueue>
+#include <QDomElement>
+#include <QDateTime>
+
+#define NS_STREAM_MANAGEMENT   "urn:xmpp:sm:3"
+#define SM_TIMER_INTERVAL_SECS 20
+
+//#define IRIS_SM_DEBUG
+
+namespace XMPP
+{
+	class SMState
+	{
+	public:
+		SMState();
+		void reset();
+		bool isResumption() const { return !resumption_id.isEmpty(); }
+		bool isEnabled() const { return enabled; }
+		void setEnabled(bool e) { enabled = e; }
+
+	public:
+		bool enabled;
+		quint32 received_count;
+		quint32 server_last_handled;
+		QQueue<QDomElement> send_queue;
+		QString resumption_id;
+		struct {
+			QString host;
+			int port;
+		} resumption_location;
+	};
+
+	class StreamManagement : QObject
+	{
+	public:
+		StreamManagement(QObject *parent = 0);
+		XMPP::SMState &state() { return state_; }
+		const XMPP::SMState &state() const { return state_; }
+		bool isActive() const { return sm_started || sm_resumed; }
+		bool isResumed() const { return sm_resumed; }
+		void reset();
+		void started(const QString &resumption_id);
+		void resumed(quint32 last_handled);
+		void setLocation(const QString &host, int port);
+		int  lastAckElapsed() const;
+		int  takeAckedCount();
+		QDomElement getUnacknowledgedStanza();
+		int  addUnacknowledgedStanza(const QDomElement &e);
+		void processAcknowledgement(quint32 last_handled);
+		bool processNormalStanza(const QDomElement &e);
+		void markStanzaHandled();
+		QDomElement generateRequestStanza(QDomDocument &doc);
+		QDomElement makeResponseStanza(QDomDocument &doc);
+
+	private:
+		SMState state_;
+		bool sm_started;
+		bool sm_resumed;
+		int  sm_stanzas_notify;
+		int  sm_resend_pos;
+		struct {
+			QDateTime point_time;
+			bool pause_mode;
+		} sm_timeout_data;
+	};
+}
+
+#endif //XMPP_SM_H
--- psi.orig/iris/src/xmpp/xmpp-core/stream.cpp
+++ psi/iris/src/xmpp/xmpp-core/stream.cpp
@@ -65,6 +65,7 @@
 #include "td.h"
 #endif
 
+
 //#define XMPP_DEBUG
 
 using namespace XMPP;
@@ -175,6 +176,7 @@ public:
 		lang = "";
 
 		in_rrsig = false;
+		quiet_reconnection = false;
 
 		reset();
 	}
@@ -236,6 +238,7 @@ public:
 	QTimer timeout_timer;
 	QTimer noopTimer;
 	int noop_time;
+	bool quiet_reconnection;
 };
 
 ClientStream::ClientStream(Connector *conn, TLSHandler *tlsHandler, QObject *parent)
@@ -583,10 +586,10 @@ Stanza ClientStream::read()
 	}
 }
 
-void ClientStream::write(const Stanza &s, bool notify)
+void ClientStream::write(const Stanza &s)
 {
 	if(d->state == Active) {
-		d->client.sendStanza(s.element(), notify);
+		d->client.sendStanza(s.element());
 		processNext();
 	}
 }
@@ -625,7 +628,8 @@ void ClientStream::cr_connected()
 	d->client.doBinding = d->doBinding;*/
 
 	QPointer<QObject> self = this;
-	emit connected();
+	if (!d->quiet_reconnection)
+		emit connected();
 	if(!self)
 		return;
 
@@ -700,7 +704,8 @@ void ClientStream::ss_bytesWritten(qint6
 void ClientStream::ss_tlsHandshaken()
 {
 	QPointer<QObject> self = this;
-	securityLayerActivated(LayerTLS);
+	if (!d->quiet_reconnection)
+		securityLayerActivated(LayerTLS);
 	if(!self)
 		return;
 	d->client.setAllowPlain(d->allowPlain == AllowPlain || d->allowPlain == AllowPlainOverTLS);
@@ -1059,7 +1064,8 @@ void ClientStream::processNext()
 				d->jid = d->client.jid();
 				d->state = Active;
 				setNoopTime(d->noop_time);
-				authenticated();
+				if (!d->quiet_reconnection)
+					authenticated();
 				if(!self)
 					return;
 				break;
@@ -1079,10 +1085,10 @@ void ClientStream::processNext()
 				// store the stanza for now, announce after processing all events
 				// TODO: add a method to the stanza to mark them handled.
 				Stanza s = createStanza(d->client.recvStanza());
-				unsigned long sm_id = d->client.getNewSMId();
 				if(s.isNull())
 					break;
-				if (s.kind() == Stanza::Presence || s.kind() == Stanza::IQ) d->client.markStanzaHandled(sm_id);
+				if (d->client.sm.isActive())
+					d->client.sm.markStanzaHandled();
 				d->in.append(new Stanza(s));
 				break;
 			}
@@ -1104,10 +1110,28 @@ void ClientStream::processNext()
 				return;
 			}
 			case CoreProtocol::EAck: {
+				int ack_cnt = d->client.sm.takeAckedCount();
+#ifdef XMPP_DEBUG
+				qDebug() << "Stream Management: [INF] Received ack amount: " << ack_cnt;
+#endif
+				emit stanzasAcked(ack_cnt);
+				break;
+			}
+			case CoreProtocol::ESMConnTimeout: {
 #ifdef XMPP_DEBUG
-				qDebug() << "Received ack response: " << d->client.getNotableStanzasAcked();
+				qDebug() << "Stream Management: [INF] Connection timeout";
 #endif
-				emit stanzasAcked(d->client.getNotableStanzasAcked());
+				reset();
+				if (d->client.sm.state().isResumption()) {
+					d->state = Connecting;
+					emit warning(WarnSMReconnection);
+					d->quiet_reconnection = true;
+					d->conn->connectToServer(d->server);
+				} else {
+					d->quiet_reconnection = false;
+					emit connectionClosed();
+				}
+				return;
 			}
 		}
 	}
@@ -1215,7 +1239,8 @@ bool ClientStream::handleNeed()
 			d->ss->setLayerSASL(d->sasl, d->client.spare);
 			if(d->sasl_ssf > 0) {
 				QPointer<QObject> self = this;
-				securityLayerActivated(LayerSASL);
+				if (!d->quiet_reconnection)
+					securityLayerActivated(LayerSASL);
 				if(!self)
 					return false;
 			}
@@ -1269,18 +1294,6 @@ void ClientStream::doNoop()
 	}
 }
 
-// SM stuff
-bool ClientStream::isStreamManagementActive() {
-	return d->client.isStreamManagementActive();
-}
-
-void ClientStream::ackLastMessageStanza() {
-	 d->client.markLastMessageStanzaAcked();
-#ifdef XMPP_DEBUG
-	 qDebug() << "StreamManagement: markLastMessageStanzaAcked";
-#endif
-}
-
 void ClientStream::writeDirect(const QString &s)
 {
 	if(d->state == Active) {
@@ -1414,12 +1427,14 @@ void ClientStream::handleError()
 	}
 }
 
-ClientStream::SMState ClientStream::getSMState() const {
-	return d->client.getSMState();
+bool ClientStream::isResumed() const
+{
+	return d->client.sm.isResumed();
 }
 
-void ClientStream::setSMState(ClientStream::SMState state) {
-	d->client.setSMState(state);
+void ClientStream::setSMEnabled(bool e)
+{
+	d->client.sm.state().setEnabled(e);
 }
 
 
--- psi.orig/iris/src/xmpp/xmpp-core/xmlprotocol.h
+++ psi/iris/src/xmpp/xmpp-core/xmlprotocol.h
@@ -43,6 +43,7 @@ namespace XMPP
 			ERecvOpen,    // breakpoint after root element open tag is received
 			EPeerClosed,  // root element close tag received
 			EClosed,      // finished closing
+			ESMConnTimeout, // absence of responses to <r/> query
 			ECustom = 10
 		};
 		enum Error {
--- psi.orig/iris/src/xmpp/xmpp-core/xmpp_clientstream.h
+++ psi/iris/src/xmpp/xmpp-core/xmpp_clientstream.h
@@ -51,7 +51,8 @@ namespace XMPP
 		};
 		enum Warning {
 			WarnOldVersion,             // server uses older XMPP/Jabber "0.9" protocol
-			WarnNoTLS                   // there is no chance for TLS at this point
+			WarnNoTLS,                  // there is no chance for TLS at this point
+			WarnSMReconnection          // SM started a quiet stream reconnection
 		};
 		enum NegCond {
 			HostGone,                   // host no longer hosted
@@ -91,18 +92,6 @@ namespace XMPP
 			AllowPlainOverTLS
 		};
 
-		struct SMState {
-			QList<QPair<unsigned long, bool> > sm_receive_queue;
-			QList<QPair<QDomElement, bool> > sm_send_queue;
-			unsigned long sm_receive_count;
-			unsigned long sm_server_last_handled;
-			int sm_stanzas_notify;
-
-			bool sm_resumtion_supported;
-			QString sm_resumption_id;
-			QPair<QString,int> sm_resumption_location;
-		};
-
 		ClientStream(Connector *conn, TLSHandler *tlsHandler=0, QObject *parent=0);
 		ClientStream(const QString &host, const QString &defRealm, ByteStream *bs, QCA::TLS *tls=0, QObject *parent=0); // server
 		~ClientStream();
@@ -152,7 +141,7 @@ namespace XMPP
 		void close();
 		bool stanzaAvailable() const;
 		Stanza read();
-		void write(const Stanza &s, bool notify = false);
+		void write(const Stanza &s);
 
 		int errorCondition() const;
 		QString errorText() const;
@@ -162,12 +151,9 @@ namespace XMPP
 		void writeDirect(const QString &s);
 		void setNoopTime(int mills);
 
-		// session management stuff
-		bool isStreamManagementActive();
-		void ackLastMessageStanza();
-
-		SMState getSMState() const;
-		void setSMState(SMState state);
+		// Stream management
+		bool isResumed() const;
+		void setSMEnabled(bool enable);
 
 		// barracuda extension
 		QStringList hosts() const;
--- psi.orig/iris/src/xmpp/xmpp-core/xmpp_stream.h
+++ psi/iris/src/xmpp/xmpp-core/xmpp_stream.h
@@ -58,7 +58,7 @@ namespace XMPP
 		virtual void close()=0;
 		virtual bool stanzaAvailable() const=0;
 		virtual Stanza read()=0;
-		virtual void write(const Stanza &s, bool notify = false)=0;
+		virtual void write(const Stanza &s)=0;
 
 		virtual int errorCondition() const=0;
 		virtual QString errorText() const=0;
--- psi.orig/iris/src/xmpp/xmpp-im/client.cpp
+++ psi/iris/src/xmpp/xmpp-im/client.cpp
@@ -410,14 +410,6 @@ QString Client::groupChatNick(const QStr
 	return QString();
 }
 
-bool Client::isStreamManagementActive() const {
-	ClientStream *cs = qobject_cast<ClientStream*>(d->stream);
-	if(cs)
-		return cs->isStreamManagementActive();
-	return false;
-}
-
-
 /*void Client::start()
 {
 	if(d->stream->old()) {
@@ -609,7 +601,7 @@ void Client::distribute(const QDomElemen
 	}
 }
 
-void Client::send(const QDomElement &x, bool want_notify)
+void Client::send(const QDomElement &x)
 {
 	if(!d->stream)
 		return;
@@ -635,7 +627,7 @@ void Client::send(const QDomElement &x,
 	emit xmlOutgoing(out);
 
 	//printf("x[%s] x2[%s] s[%s]\n", Stream::xmlToString(x).toLatin1(), Stream::xmlToString(e).toLatin1(), s.toString().toLatin1());
-	d->stream->write(s, want_notify);
+	d->stream->write(s);
 }
 
 void Client::send(const QString &str)
@@ -1021,9 +1013,9 @@ void Client::importRosterItem(const Rost
 	debug(dstr + str);
 }
 
-void Client::sendMessage(const Message &m, bool want_notify)
+void Client::sendMessage(const Message &m)
 {
-	JT_Message *j = new JT_Message(rootTask(), m, want_notify);
+	JT_Message *j = new JT_Message(rootTask(), m);
 	j->go(true);
 }
 
--- psi.orig/iris/src/xmpp/xmpp-im/xmpp_client.h
+++ psi/iris/src/xmpp/xmpp-im/xmpp_client.h
@@ -70,7 +70,7 @@ namespace XMPP
 		const LiveRoster & roster() const;
 		const ResourceList & resourceList() const;
 
-		void send(const QDomElement &, bool want_notify = false);
+		void send(const QDomElement &);
 		void send(const QString &);
 
 		QString host() const;
@@ -80,7 +80,7 @@ namespace XMPP
 		Jid jid() const;
 
 		void rosterRequest(bool withGroupsDelimiter = true);
-		void sendMessage(const Message &, bool want_notify = false);
+		void sendMessage(const Message &);
 		void sendSubscription(const Jid &, const QString &, const QString& nick = QString());
 		void setPresence(const Status &);
 
@@ -133,7 +133,6 @@ namespace XMPP
 		void groupChatLeaveAll(const QString &statusStr = QString());
 		QString groupChatNick(const QString &host, const QString &room) const;
 
-		bool isStreamManagementActive() const;
 	signals:
 		void activated();
 		void disconnected();
@@ -199,7 +198,6 @@ namespace XMPP
 		void handleIncoming(BSConnection *);
 
 		void sendAckRequest();
-		void smQueueStanza(const QDomElement &e, bool notify = false);
 
 		class ClientPrivate;
 		ClientPrivate *d;
--- psi.orig/iris/src/xmpp/xmpp-im/xmpp_task.cpp
+++ psi/iris/src/xmpp/xmpp-im/xmpp_task.cpp
@@ -196,9 +196,9 @@ void Task::onTimeout()
 	}
 }
 
-void Task::send(const QDomElement &x, bool want_notify)
+void Task::send(const QDomElement &x)
 {
-	client()->send(x, want_notify);
+	client()->send(x);
 }
 
 void Task::setSuccess(int code, const QString &str)
--- psi.orig/iris/src/xmpp/xmpp-im/xmpp_task.h
+++ psi/iris/src/xmpp/xmpp-im/xmpp_task.h
@@ -63,7 +63,7 @@ namespace XMPP {
 		virtual void onGo();
 		virtual void onDisconnect();
 		virtual void onTimeout();
-		void send(const QDomElement &, bool want_notify = false);
+		void send(const QDomElement &);
 		void setSuccess(int code=0, const QString &str="");
 		void setError(const QDomElement &);
 		void setError(int code=0, const QString &str="");
--- psi.orig/iris/src/xmpp/xmpp-im/xmpp_tasks.cpp
+++ psi/iris/src/xmpp/xmpp-im/xmpp_tasks.cpp
@@ -920,13 +920,12 @@ static QDomElement oldStyleNS(const QDom
 	return i;
 }
 
-JT_Message::JT_Message(Task *parent, const Message &msg, bool want_notify)
+JT_Message::JT_Message(Task *parent, const Message &msg)
 :Task(parent)
 {
 	m = msg;
 	if (m.id().isEmpty())
 		m.setId(id());
-	w_notify = want_notify;
 }
 
 JT_Message::~JT_Message()
@@ -937,7 +936,7 @@ void JT_Message::onGo()
 {
 	Stanza s = m.toStanza(&(client()->stream()));
 	QDomElement e = oldStyleNS(s.element());
-	send(e, w_notify);
+	send(e);
 	setSuccess();
 }
 
--- psi.orig/iris/src/xmpp/xmpp-im/xmpp_tasks.h
+++ psi/iris/src/xmpp/xmpp-im/xmpp_tasks.h
@@ -189,14 +189,13 @@ namespace XMPP
 	{
 		Q_OBJECT
 	public:
-		JT_Message(Task *parent, const Message &, bool want_notify = false);
+		JT_Message(Task *parent, const Message &);
 		~JT_Message();
 
 		void onGo();
 
 	private:
 		Message m;
-		bool w_notify;
 
 		class Private;
 		Private *d;
--- psi.orig/iris/src/xmpp/xmpp.pri
+++ psi/iris/src/xmpp/xmpp.pri
@@ -30,6 +30,7 @@ HEADERS += \
 	$$PWD/xmpp-core/parser.h \
 	$$PWD/xmpp-core/xmlprotocol.h \
 	$$PWD/xmpp-core/protocol.h \
+	$$PWD/xmpp-core/sm.h \
 	$$PWD/xmpp-core/compressionhandler.h \
 	$$PWD/xmpp-core/td.h \
 	$$PWD/xmpp-im/xmpp_tasks.h \
@@ -78,6 +79,7 @@ SOURCES += \
 	$$PWD/xmpp-core/parser.cpp \
 	$$PWD/xmpp-core/xmlprotocol.cpp \
 	$$PWD/xmpp-core/protocol.cpp \
+	$$PWD/xmpp-core/sm.cpp \
 	$$PWD/xmpp-core/compressionhandler.cpp \
 	$$PWD/xmpp-core/stream.cpp \
 	$$PWD/xmpp-core/simplesasl.cpp \
--- psi.orig/options/default.xml
+++ psi/options/default.xml
@@ -71,6 +71,9 @@
 			<account comment="Account options">
 				<data-proxy comment="Allow changing the data transfer proxy" type="bool">true</data-proxy>
 				<keepalive comment="Show the keepalive option" type="bool">true</keepalive>
+				<sm comment="Option related to the Stream Management UI">
+					<show comment="Show the Stream Management UI" type="bool">true</show>
+				</sm>
 				<legacy-ssl-probe comment="Show legacy SSL probe option" type="bool">true</legacy-ssl-probe>
 				<manual-host comment="Enable manual host configuration" type="bool">true</manual-host>
 				<priority comment="Allow changing the priority" type="bool">true</priority>
--- psi.orig/src/accountmodifydlg.cpp
+++ psi/src/accountmodifydlg.cpp
@@ -150,6 +150,7 @@ void AccountModifyDlg::init()
 	ck_autoSameStatus->setChecked(acc.opt_autoSameStatus);
 	ck_log->setChecked(acc.opt_log);
 	ck_keepAlive->setChecked(acc.opt_keepAlive);
+	ck_enableSM->setChecked(acc.opt_sm);
 	ck_ibbOnly->setChecked(acc.ibbOnly);
 	le_dtProxy->setText(acc.dtProxy.full());
 
@@ -250,6 +251,10 @@ void AccountModifyDlg::init()
 		"automatically disconnected after a certain period of "
 		"inactivity (for example, by your ISP) and you want to keep it "
 		"up all the time."));
+	ck_enableSM->setWhatsThis(
+		tr("Enables Stream Management protocol if possible. It is useful, "
+		   "if you have an unstable connection. Your server must support "
+		   "this option. To learn more, see XEP-0184."));
 	cb_ssl->setWhatsThis(
 		tr("Check this option to use an encrypted SSL connection to "
 		"the XMPP server.  You may use this option if your "
@@ -320,6 +325,9 @@ void AccountModifyDlg::init()
 	if (!PsiOptions::instance()->getOption("options.ui.account.keepalive").toBool())
 		ck_keepAlive->hide();
 
+	if (!PsiOptions::instance()->getOption("options.ui.account.sm.show").toBool())
+		ck_enableSM->hide();
+
 	if (!PsiOptions::instance()->getOption("options.ui.account.security.show").toBool()) {
 		lb_plain->hide();
 		cb_plain->hide();
@@ -328,7 +336,7 @@ void AccountModifyDlg::init()
 		cb_security_level->hide();
 	}
 
-	if (!PsiOptions::instance()->getOption("options.ui.account.security.show").toBool() && !PsiOptions::instance()->getOption("options.ui.account.keepalive").toBool() && !PsiOptions::instance()->getOption("options.ui.account.manual-host").toBool() && !PsiOptions::instance()->getOption("options.ui.account.proxy.show").toBool()) {
+	if (!PsiOptions::instance()->getOption("options.ui.account.security.show").toBool() && !PsiOptions::instance()->getOption("options.ui.account.keepalive").toBool() && !PsiOptions::instance()->getOption("options.ui.account.sm.show").toBool() && !PsiOptions::instance()->getOption("options.ui.account.manual-host").toBool() && !PsiOptions::instance()->getOption("options.ui.account.proxy.show").toBool()) {
 		tab_main->removeTab(tab_main->indexOf(tab_connection));
 	}
 
@@ -567,6 +575,7 @@ void AccountModifyDlg::save()
 	acc.opt_reconn = ck_reconn->isChecked();
 	acc.opt_log = ck_log->isChecked();
 	acc.opt_keepAlive = ck_keepAlive->isChecked();
+	acc.opt_sm = ck_enableSM->isChecked();
 	acc.ibbOnly = ck_ibbOnly->isChecked();
 	acc.dtProxy = le_dtProxy->text();
 	acc.stunHost = cb_stunHost->currentIndex() ? cb_stunHost->currentText().trimmed() : "";
--- psi.orig/src/accountmodify.ui
+++ psi/src/accountmodify.ui
@@ -580,6 +580,13 @@
         </widget>
        </item>
        <item>
+        <widget class="QCheckBox" name="ck_enableSM">
+         <property name="text">
+          <string>Enable Stream Management if possible</string>
+         </property>
+        </widget>
+       </item>
+       <item>
         <widget class="QCheckBox" name="ck_host">
          <property name="text">
           <string>Manually Specify Server Host/Port:</string>
@@ -1099,6 +1106,7 @@ When you enable this option you will not
   <tabstop>pb_privacy</tabstop>
   <tabstop>ck_compress</tabstop>
   <tabstop>ck_keepAlive</tabstop>
+  <tabstop>ck_enableSM</tabstop>
   <tabstop>ck_host</tabstop>
   <tabstop>le_host</tabstop>
   <tabstop>le_port</tabstop>
--- psi.orig/src/chatdlg.cpp
+++ psi/src/chatdlg.cpp
@@ -213,12 +213,6 @@ void ChatDlg::initActions()
 	connect(act_scrolldown_, SIGNAL(triggered()), chatView(), SLOT(scrollDown()));
 }
 
-void ChatDlg::ackLastMessages(int a)
-{
-	Q_UNUSED(a);
-}
-
-
 void ChatDlg::setShortcuts()
 {
 	act_send_->setShortcuts(ShortcutManager::instance()->shortcuts("chat.send"));
--- psi.orig/src/chatdlg.h
+++ psi/src/chatdlg.h
@@ -82,8 +82,6 @@ public:
 	virtual QString desiredCaption() const;
 	virtual void ensureTabbedCorrectly();
 
-	virtual void ackLastMessages(int);
-
 public:
 	PsiAccount* account() const;
 	void setInputText(const QString &text);
--- psi.orig/src/dummystream.h
+++ psi/src/dummystream.h
@@ -34,7 +34,7 @@ public:
 	void close() { }
 	bool stanzaAvailable() const { return false; }
 	XMPP::Stanza read() { return XMPP::Stanza(); }
-	void write(const XMPP::Stanza &, bool notify = false) { }
+	void write(const XMPP::Stanza &) { }
 
 	int errorCondition() const { return 0; }
 	QString errorText() const { return QString::null; }
--- psi.orig/src/profiles.h
+++ psi/src/profiles.h
@@ -59,7 +59,7 @@ public:
 	bool storeSaltedHashedPassword;
 	QString scramSaltedHashPassword;
 	int port, priority;
-	bool opt_enabled, opt_pass, opt_host, opt_auto, opt_keepAlive, opt_log, opt_connectAfterSleep, opt_autoSameStatus, opt_reconn, opt_ignoreSSLWarnings, opt_compress;
+	bool opt_enabled, opt_pass, opt_host, opt_auto, opt_keepAlive, opt_log, opt_connectAfterSleep, opt_autoSameStatus, opt_reconn, opt_ignoreSSLWarnings, opt_compress, opt_sm;
 	XMPP::ClientStream::AllowPlainType allow_plain;
 	bool req_mutual_auth;
 	bool legacy_ssl_probe;
--- psi.orig/src/psiaccount.cpp
+++ psi/src/psiaccount.cpp
@@ -543,9 +543,6 @@ public:
 	QList<PsiContact*> contacts;
 	int onlineContactsCount;
 
-	// Stream management
-	QQueue<ChatDlg*> chatdlg_ack_interest;
-	ClientStream::SMState smState;
 private:
 	bool doPopups_;
 
@@ -1140,8 +1137,6 @@ PsiAccount::PsiAccount(const UserAccount
 	d->stream = 0;
 	d->usingSSL = false;
 
-	d->smState.sm_resumtion_supported = false;
-
 	// create XMPP::Client
 	d->client = new Client;
 
@@ -1436,7 +1431,6 @@ void PsiAccount::cleanupStream()
 {
 	// GSOC: Get SM state out of stream
 	if (d->stream) {
-		d->smState = d->stream->getSMState();
 		delete d->stream;
 	}
 
@@ -1795,12 +1789,7 @@ void PsiAccount::login()
 		connect(d->tlsHandler, SIGNAL(tlsHandshaken()), SLOT(tls_handshaken()));
 	}
 	d->conn->setProxy(p);
-	if (d->smState.sm_resumtion_supported && !d->smState.sm_resumption_location.first.isEmpty()) {
-		useHost = true;
-		host = d->smState.sm_resumption_location.first;
-		port = d->smState.sm_resumption_location.second;
-		d->smState.sm_resumption_location.first.clear(); // we don't want to try it again if failed
-	}
+
 	if (useHost) {
 		d->conn->setOptHostPort(host, port);
 		d->conn->setOptSSL(d->acc.ssl == UserAccount::SSL_Legacy);
@@ -1825,10 +1814,9 @@ void PsiAccount::login()
 	connect(d->stream, SIGNAL(delayedCloseFinished()), SLOT(cs_delayedCloseFinished()));
 	connect(d->stream, SIGNAL(warning(int)), SLOT(cs_warning(int)));
 	connect(d->stream, SIGNAL(error(int)), SLOT(cs_error(int)), Qt::QueuedConnection);
-	connect(d->stream, SIGNAL(stanzasAcked(int)), SLOT(messageStanzasAcked(int)));
 
 	Jid j = d->jid.withResource((d->acc.opt_automatic_resource ? localHostName() : d->acc.resource ));
-	if (d->smState.sm_resumtion_supported) d->stream->setSMState(d->smState);
+	d->stream->setSMEnabled(d->acc.opt_sm);
 	d->client->connectToServer(d->stream, j);
 }
 
@@ -1864,9 +1852,6 @@ void PsiAccount::forceDisconnect(bool fa
 		// send logout status
 		d->client->groupChatLeaveAll(PsiOptions::instance()->getOption("options.muc.leave-status-message").toString());
 		d->client->setPresence(s);
-
-		// we are not going to restore session if we a here?
-		d->stream->setSMState(ClientStream::SMState());
 	}
 
 	isDisconnecting = true;
@@ -2062,6 +2047,9 @@ void PsiAccount::cs_delayedCloseFinished
 
 void PsiAccount::cs_warning(int w)
 {
+	if (w == ClientStream::WarnSMReconnection)
+		return;
+
 	bool showNoTlsWarning = w == ClientStream::WarnNoTLS && d->acc.ssl == UserAccount::SSL_Yes;
 	bool doCleanupStream = !d->stream || showNoTlsWarning;
 
@@ -2765,11 +2753,6 @@ void PsiAccount::client_messageReceived(
 #endif
 
 	processIncomingMessage(_m);
-
-	XMPP::ClientStream *cs = qobject_cast<XMPP::ClientStream*>(&(d->client->stream()));
-	if (cs) {
-		cs->ackLastMessageStanza();
-	}
 }
 
 #ifdef WHITEBOARDING
@@ -4752,17 +4735,7 @@ void PsiAccount::dj_sendMessage(const Me
 	}
 #endif
 
-	// GSOC: stream management
-	// check whether message came from a ChatDlg
-	if (d->client->isStreamManagementActive()) {
-		ChatDlg *chat_dlg = qobject_cast<ChatDlg*>(sender());
-		if (chat_dlg) {
-			d->chatdlg_ack_interest.enqueue(chat_dlg);
-			d->client->sendMessage(nm, true);
-		}
-		else d->client->sendMessage(nm);
-	}
-	else d->client->sendMessage(nm);
+	d->client->sendMessage(nm);
 
 	// only toggle if not an invite or body is not empty
 	if(m.invite().isEmpty() && !m.body().isEmpty())
@@ -5728,14 +5701,6 @@ void PsiAccount::processReadNext(const U
 	updateReadNext(u.jid());
 }
 
-void PsiAccount::messageStanzasAcked(int n) {
-	for (int i=0; i < n; i++) {
-		ChatDlg *chatdlg = d->chatdlg_ack_interest.dequeue();
-		chatdlg->ackLastMessages(1);
-		qWarning() << "Inform chat dialog that message has been acked by the server.";
-	}
-}
-
 void PsiAccount::processChatsHelper(const Jid& j, bool removeEvents)
 {
 	//printf("processing chats for [%s]\n", j.full().latin1());
--- psi.orig/src/psiaccount.h
+++ psi/src/psiaccount.h
@@ -479,7 +479,6 @@ private slots:
 	void processReadNext(const Jid &);
 	void queryVersionFinished();
 
-	void messageStanzasAcked(int n);
 protected:
 	bool validRosterExchangeItem(const RosterExchangeItem&);
 	QString localHostName();
--- psi.orig/src/psichatdlg.cpp
+++ psi/src/psichatdlg.cpp
@@ -279,7 +279,6 @@ void PsiChatDlg::initUi()
 	if (throbber_icon == 0) {
 		throbber_icon = (PsiIcon *)IconsetFactory::iconPtr("psi/throbber");
 	}
-	unacked_messages = 0;
 #ifdef PSI_PLUGINS
 	PluginManager::instance()->setupChatTab(this, account(), jid().full());
 #endif
@@ -590,12 +589,7 @@ void PsiChatDlg::activated()
 
 void PsiChatDlg::setContactToolTip(QString text)
 {
-	last_contact_tooltip = text;
-	QString sm_info;
-	if (unacked_messages > 0) {
-		sm_info = QString().sprintf("\nUnacked messages: %d", unacked_messages);
-	}
-	ui_.lb_status->setToolTip(text + sm_info);
+	ui_.lb_status->setToolTip(text);
 	ui_.avatar->setToolTip(text);
 }
 
@@ -716,21 +710,12 @@ void PsiChatDlg::contactUpdated(UserList
 	Q_UNUSED(statusString);
 
 	if (status == -1 || !u) {
-		current_status_icon = IconsetFactory::iconPtr("status/noauth");
+		ui_.lb_status->setPsiIcon(IconsetFactory::iconPtr("status/noauth"));
+		setTabIcon(IconsetFactory::iconPtr("status/noauth")->icon());
 	}
 	else {
-		current_status_icon = PsiIconset::instance()->statusPtr(jid(), status);
-		if (status == 0 && unacked_messages != 0) {
-			appendSysMsg(QString().sprintf("The last %d message/messages hasn't/haven't been acked by the server and may have been lost!", unacked_messages));
-			unacked_messages = 0;
-		}
-	}
-
-	if (unacked_messages == 0) {
-		ui_.lb_status->setPsiIcon(current_status_icon);
-		setTabIcon(current_status_icon->icon());//FIXME
-	} else {
-		ui_.lb_status->setPsiIcon(throbber_icon);
+		ui_.lb_status->setPsiIcon(PsiIconset::instance()->statusPtr(jid(), status));
+		setTabIcon(PsiIconset::instance()->statusPtr(jid(), status)->icon());
 	}
 
 	if (u) {
@@ -969,22 +954,6 @@ void PsiChatDlg::doSend() {
 	} else {
 		ChatDlg::doSend();
 	}
-	if (account()->loggedIn() && account()->client()->isStreamManagementActive()) {
-		unacked_messages++;
-		//qDebug("Show throbber instead of status icon.");
-		ui_.lb_status->setPsiIcon(throbber_icon);
-		setContactToolTip(last_contact_tooltip);
-	}
-}
-
-void PsiChatDlg::ackLastMessages(int msgs) {
-	unacked_messages = unacked_messages - msgs;
-	unacked_messages = unacked_messages < 0 ? 0 : unacked_messages;
-	if (unacked_messages == 0) {
-		//qDebug("Show status icon instead of throbber.");
-		ui_.lb_status->setPsiIcon(current_status_icon);
-		setContactToolTip(last_contact_tooltip);
-	}
 }
 
 void PsiChatDlg::doMiniCmd()
--- psi.orig/src/psichatdlg.h
+++ psi/src/psichatdlg.h
@@ -30,7 +30,6 @@ protected:
 	void contextMenuEvent(QContextMenuEvent *);
 	void doSend();
 	bool eventFilter(QObject *obj, QEvent *event);
-	void ackLastMessages(int msgs);
 
 private:
 	void setContactToolTip(QString text);
@@ -107,10 +106,6 @@ private:
 	bool smallChat_;
 	class ChatDlgMCmdProvider;
 
-	const PsiIcon *current_status_icon;
-	QString last_contact_tooltip;
-	int unacked_messages;
-
 	static PsiIcon *throbber_icon;
 	bool tabmode;
 	QPointer <PsiWindowHeader> winHeader_;
--- psi.orig/src/psi_profiles.cpp
+++ psi/src/psi_profiles.cpp
@@ -141,6 +141,7 @@ void UserAccount::reset()
 	priority = 55;
 	ibbOnly = false;
 	opt_keepAlive = true;
+	opt_sm = true;
 	allow_plain = XMPP::ClientStream::AllowPlainOverTLS;
 	opt_compress = true;
 	opt_log = true;
@@ -205,6 +206,7 @@ void UserAccount::fromOptions(OptionsTre
 	opt_enabled = o->getOption(base + ".enabled").toBool();
 	opt_auto = o->getOption(base + ".auto").toBool();
 	opt_keepAlive = o->getOption(base + ".keep-alive").toBool();
+	opt_sm = o->getOption(base + ".enable-sm", true).toBool();
 	opt_compress = o->getOption(base + ".compress").toBool();
 	req_mutual_auth = o->getOption(base + ".require-mutual-auth").toBool();
 	legacy_ssl_probe = o->getOption(base + ".legacy-ssl-probe").toBool();
@@ -371,6 +373,7 @@ void UserAccount::toOptions(OptionsTree
 	o->setOption(base + ".enabled", opt_enabled);
 	o->setOption(base + ".auto", opt_auto);
 	o->setOption(base + ".keep-alive", opt_keepAlive);
+	o->setOption(base + ".enable-sm", opt_sm);
 	o->setOption(base + ".compress", opt_compress);
 	o->setOption(base + ".require-mutual-auth", req_mutual_auth);
 	o->setOption(base + ".legacy-ssl-probe", legacy_ssl_probe);
@@ -517,6 +520,7 @@ void UserAccount::fromXml(const QDomElem
 	readBoolAttribute(a, "showAgents", &tog_agents);
 	readBoolAttribute(a, "showSelf", &tog_self);
 	readBoolAttribute(a, "keepAlive", &opt_keepAlive);
+	readBoolAttribute(a, "enableSM", &opt_sm);
 	readBoolAttribute(a, "compress", &opt_compress);
 	readBoolAttribute(a, "require-mutual-auth", &req_mutual_auth);
 	readBoolAttribute(a, "legacy-ssl-probe", &legacy_ssl_probe);
--- psi.orig/src/xmlconsole.cpp
+++ psi/src/xmlconsole.cpp
@@ -99,13 +99,14 @@ bool XmlConsole::filtered(const QString&
 {
 	if(ui_.ck_enable->isChecked()) {
 		// Only do parsing if needed
-		if (!ui_.le_jid->text().isEmpty() || !ui_.ck_iq->isChecked() || !ui_.ck_message->isChecked() || !ui_.ck_presence->isChecked()) {
+		if (!ui_.le_jid->text().isEmpty() || !ui_.ck_iq->isChecked() || !ui_.ck_message->isChecked() || !ui_.ck_presence->isChecked() || !ui_.ck_sm->isChecked()) {
 			QDomDocument doc;
 			if (!doc.setContent(str))
 				return true;
 
 			QDomElement e = doc.documentElement();
-			if ((e.tagName() == "iq" && !ui_.ck_iq->isChecked()) || (e.tagName() == "message" && !ui_.ck_message->isChecked()) || ((e.tagName() == "presence" && !ui_.ck_presence->isChecked())))
+			QString tn = e.tagName();
+			if ((tn == "iq" && !ui_.ck_iq->isChecked()) || (tn == "message" && !ui_.ck_message->isChecked()) || (tn == "presence" && !ui_.ck_presence->isChecked()) || ((tn == "a" || tn == "r") && !ui_.ck_sm->isChecked()))
 				return true;
 
 			if (!ui_.le_jid->text().isEmpty()) {
--- psi.orig/src/xmlconsole.ui
+++ psi/src/xmlconsole.ui
@@ -65,6 +65,16 @@
        </widget>
       </item>
       <item>
+       <widget class="QCheckBox" name="ck_sm" >
+        <property name="text" >
+         <string>SM</string>
+        </property>
+        <property name="checked" >
+         <bool>true</bool>
+        </property>
+       </widget>
+      </item>
+       <item>
        <spacer>
         <property name="orientation" >
          <enum>Qt::Horizontal</enum>
