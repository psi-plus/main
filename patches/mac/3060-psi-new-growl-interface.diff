--- psi.orig/src/libpsi/tools/growlnotifier/growlnotifier.cpp
+++ psi/src/libpsi/tools/growlnotifier/growlnotifier.cpp
@@ -1,330 +0,0 @@
-/*
- * growlnotifier.cpp - A simple Qt interface to Growl
- *
- * Copyright (C) 2005  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * You can also redistribute and/or modify this program under the
- * terms of the Psi License, specified in the accompanied COPYING
- * file, as published by the Psi Project; either dated January 1st,
- * 2005, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-
-/**
- * \class GrowlNotifier
- * \todo Write a destructor, which CFReleases all datastructures
- */ 
-
-extern "C" {
-	#include <CoreFoundation/CoreFoundation.h>
-	#include <Growl/Growl.h>
-}
-
-#include <QStringList>
-#include <QPixmap>
-#include <QBuffer>
-
-//#include <sys/types.h>
-//#include <unistd.h>
-
-#include "growlnotifier.h"
-
-//------------------------------------------------------------------------------ 
-
-/**
- * \brief A class for emitting a clicked signal to the interested party.
- */
-class GrowlNotifierSignaler : public QObject
-{
-	Q_OBJECT
-
-public: 
-	GrowlNotifierSignaler() { };
-	void emitNotificationClicked(void* context) { emit notificationClicked(context); }
-	void emitNotificationTimeout(void* context) { emit notificationTimedOut(context); }
-
-signals:
-	void notificationClicked(void*);
-	void notificationTimedOut(void*);
-};
-
-//------------------------------------------------------------------------------ 
-
-/**
- * \brief Converts a QString to a CoreFoundation string, preserving Unicode.
- *
- * \param s the string to be converted.
- * \return a reference to a CoreFoundation string.
- */
-static CFStringRef qString2CFString(const QString& s)
-{
-	if (s.isNull())
-		return 0;
-	
-	ushort* buffer = new ushort[s.length()];
-	for (int i = 0; i < s.length(); ++i)
-		buffer[i] = s[i].unicode();
-	CFStringRef result = CFStringCreateWithBytes ( NULL, 
-		(UInt8*) buffer, 
-		s.length()*sizeof(ushort),
-		kCFStringEncodingUnicode, false);
-
-	delete[] buffer;
-	return result;
-}
-
-//------------------------------------------------------------------------------ 
-
-/**
- * \brief Retrieves the values from the context.
- *
- * \param context the context
- * \param receiver the receiving object which will be signaled when the
- *	notification is clicked. May be NULL.
- * \param clicked_slot the slot to be signaled when the notification is clicked.
- * \param timeout_slot the slot to be signaled when the notification isn't clicked.
- * \param context the context which will be passed back to the slot
- *	May be NULL.
- */
-void getContext( CFPropertyListRef context, GrowlNotifierSignaler** signaler, const QObject** receiver, const char** clicked_slot, const char** timeout_slot, void** qcontext/*, pid_t* pid*/)
-{
-	CFDataRef data;
-
-	if (signaler) {
-		data = (CFDataRef) CFArrayGetValueAtIndex((CFArrayRef) context, 0);
-		CFDataGetBytes(data, CFRangeMake(0,CFDataGetLength(data)), (UInt8*) signaler);
-	}
-
-	if (receiver){
-		data = (CFDataRef) CFArrayGetValueAtIndex((CFArrayRef) context, 1);
-		CFDataGetBytes(data, CFRangeMake(0,CFDataGetLength(data)), (UInt8*) receiver);
-	}
-	
-	if (clicked_slot) {
-		data = (CFDataRef) CFArrayGetValueAtIndex((CFArrayRef) context, 2);
-		CFDataGetBytes(data, CFRangeMake(0,CFDataGetLength(data)), (UInt8*) clicked_slot);
-	}
-	
-	if (timeout_slot) {
-		data = (CFDataRef) CFArrayGetValueAtIndex((CFArrayRef) context, 3);
-		CFDataGetBytes(data, CFRangeMake(0,CFDataGetLength(data)), (UInt8*) timeout_slot);
-	}
-	
-	if (qcontext) {
-		data = (CFDataRef) CFArrayGetValueAtIndex((CFArrayRef) context, 4);
-		CFDataGetBytes(data, CFRangeMake(0,CFDataGetLength(data)), (UInt8*) qcontext);
-	}
-
-	//if (pid) {
-	//	data = (CFDataRef) CFArrayGetValueAtIndex((CFArrayRef) context, 5);
-	//	CFDataGetBytes(data, CFRangeMake(0,CFDataGetLength(data)), (UInt8*) pid);
-	//}
-}
-
-//------------------------------------------------------------------------------ 
-
-/**
- * Creates a context for a notification, which will be sent back by Growl
- * when a notification is clicked.
- *
- * \param receiver the receiving object which will be signaled when the
- *	notification is clicked. May be NULL.
- * \param clicked_slot the slot to be signaled when the notification is clicked.
- * \param timeout_slot the slot to be signaled when the notification isn't clicked.
- * \param context the context which will be passed back to the slot
- *	May be NULL.
- * \return the context
- */
-CFPropertyListRef createContext( GrowlNotifierSignaler* signaler, const QObject* receiver, const char* clicked_slot, const char* timeout_slot, void* qcontext /*, pid_t pid*/)
-{
-	CFDataRef context[5];
-
-	context[0] = CFDataCreate(kCFAllocatorDefault, (const UInt8*) &signaler, sizeof(GrowlNotifierSignaler*));
-	context[1] = CFDataCreate(kCFAllocatorDefault, (const UInt8*) &receiver, sizeof(const QObject *));
-	context[2] = CFDataCreate(kCFAllocatorDefault, (const UInt8*) &clicked_slot, sizeof(const char*));
-	context[3] = CFDataCreate(kCFAllocatorDefault, (const UInt8*) &timeout_slot, sizeof(const char*));
-	context[4] = CFDataCreate(kCFAllocatorDefault, (const UInt8*) &qcontext, sizeof(void*));
-	//context[5] = CFDataCreate(kCFAllocatorDefault, (const UInt8*) &pid, sizeof(pid_t));
-
-	CFArrayRef array = CFArrayCreate( kCFAllocatorDefault, 
-                (const void **)context, 5, &kCFTypeArrayCallBacks );
-
-	// Cleaning up
-	CFRelease(context[0]);
-	CFRelease(context[1]);
-	CFRelease(context[2]);
-	CFRelease(context[3]);
-	CFRelease(context[4]);
-	//CFRelease(context[5]);
-
-	return array;
-}
-
-//------------------------------------------------------------------------------ 
-
-/**
- * The callback function, used by Growl to notify that a notification was
- * clicked.
- * \param context the context of the notification
- */
-void notification_clicked(CFPropertyListRef context)
-{
-	GrowlNotifierSignaler* signaler;
-	const QObject* receiver;
-	const char* slot;
-	void* qcontext;
-	//pid_t pid;
-
-	getContext(context, &signaler, &receiver, &slot, 0, &qcontext/*, &pid*/);
-	
-	//if (pid == getpid()) {
-	QObject::connect(signaler,SIGNAL(notificationClicked(void*)),receiver,slot);
-	signaler->emitNotificationClicked(qcontext);
-	QObject::disconnect(signaler,SIGNAL(notificationClicked(void*)),receiver,slot);
-	//}
-}
-
-//------------------------------------------------------------------------------ 
-
-/**
- * The callback function, used by Growl to notify that a notification has
- * timed out.
- * \param context the context of the notification
- */
-void notification_timeout(CFPropertyListRef context)
-{
-	GrowlNotifierSignaler* signaler;
-	const QObject* receiver;
-	const char* slot;
-	void* qcontext;
-	//pid_t pid;
-
-	getContext(context, &signaler, &receiver, 0, &slot, &qcontext /*, &pid*/);
-	
-	//if (pid == getpid()) {
-	QObject::connect(signaler,SIGNAL(notificationTimedOut(void*)),receiver,slot);
-	signaler->emitNotificationTimeout(qcontext);
-	QObject::disconnect(signaler,SIGNAL(notificationTimedOut(void*)),receiver,slot);
-	//}
-}
-
-//------------------------------------------------------------------------------ 
-
-/**
- * Constructs a GrowlNotifier.
- *
- * \param notifications the list names of all notifications that can be sent
- *	by this notifier.
- * \param default_notifications the list of names of the notifications that
- *  should be enabled by default.
- * \param app the name of the application under which the notifier should 
- *	register with growl.
- */
-GrowlNotifier::GrowlNotifier(
-	const QStringList& notifications, const QStringList& default_notifications,
-	const QString& app)
-{
-	// Initialize signaler
-	signaler_ = new GrowlNotifierSignaler();
-
-	// All Notifications
-	QStringList::ConstIterator it;
-	CFMutableArrayRef allNotifications = CFArrayCreateMutable(
-		kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
-	for ( it = notifications.begin(); it != notifications.end(); ++it ) 
-		CFArrayAppendValue(allNotifications, qString2CFString(*it));
-
-	// Default Notifications
-	CFMutableArrayRef defaultNotifications = CFArrayCreateMutable(
-		kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
-	for ( it = default_notifications.begin(); it != default_notifications.end(); ++it ) 
-		CFArrayAppendValue(defaultNotifications, qString2CFString(*it));
-	
-	// Initialize delegate
-	InitGrowlDelegate(&delegate_);
-	if (!app.isEmpty())
-		delegate_.applicationName = qString2CFString(app);
-	CFTypeRef keys[] = { GROWL_NOTIFICATIONS_ALL, GROWL_NOTIFICATIONS_DEFAULT };
-	CFTypeRef values[] = { allNotifications, defaultNotifications };
-	delegate_.registrationDictionary = CFDictionaryCreate(
-		kCFAllocatorDefault, keys, values, 2, 
-		&kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
-	delegate_.growlNotificationWasClicked = &notification_clicked;
-	delegate_.growlNotificationTimedOut = &notification_timeout;
-
-	// Register with Growl
-	Growl_SetDelegate(&delegate_);
-}
-	
-
-/**
- * \brief Sends a notification to Growl.
- *
- * \param name the registered name of the notification.
- * \param title the title for the notification.
- * \param description the description of the notification.
- * \param icon the icon of the notification.
- * \param sticky whether the notification should be sticky (i.e. require a 
- *	click to discard.
- * \param receiver the receiving object which will be signaled when the
- *	notification is clicked. May be NULL.
- * \param slot the slot to be signaled when the notification is clicked.
- * \param context the context which will be passed back to the slot
- *	May be NULL.
- */
-void GrowlNotifier::notify(const QString& name, const QString& title, 
-	const QString& description, const QPixmap& p, bool sticky, 
-	const QObject* receiver, 
-	const char* clicked_slot, const char* timeout_slot, 
-	void* qcontext)
-{
-	// Convert the image if necessary
-	CFDataRef icon = 0;
-	if (!p.isNull()) {
-		QByteArray img_data;
-		QBuffer buffer(&img_data);
-		buffer.open(QIODevice::WriteOnly);
-		p.save(&buffer, "PNG");
-		icon = CFDataCreate( NULL, (UInt8*) img_data.data(), img_data.size());
-	}
-
-	// Convert strings
-	CFStringRef cf_title = qString2CFString(title);
-	CFStringRef cf_description = qString2CFString(description);
-	CFStringRef cf_name = qString2CFString(name);
-
-	// Do notification
-	CFPropertyListRef context = createContext(signaler_, receiver, clicked_slot, timeout_slot, qcontext/*, getpid()*/);
-	Growl_NotifyWithTitleDescriptionNameIconPriorityStickyClickContext(
-		cf_title, cf_description, cf_name, icon, 0, sticky, context);
-	
-	// Release intermediary datastructures
-	CFRelease(context);
-	if (icon) 
-		CFRelease(icon);
-	if (cf_title) 
-		CFRelease(cf_title);
-	if (cf_description) 
-		CFRelease(cf_description);
-	if (cf_name) 
-		CFRelease(cf_name);
-}
-
-//----------------------------------------------------------------------------- 
-
-#include "growlnotifier.moc"
--- psi.orig/src/libpsi/tools/growlnotifier/growlnotifier.h
+++ psi/src/libpsi/tools/growlnotifier/growlnotifier.h
@@ -2,6 +2,7 @@
  * growlnotifier.h - A simple Qt interface to Growl
  *
  * Copyright (C) 2005  Remko Troncon
+ *               2012  Khryukin Evgeny
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -27,11 +28,7 @@
 #ifndef GROWLNOTIFIER_H
 #define GROWLNOTIFIER_H
 
-#include <CoreFoundation/CoreFoundation.h>
-#include <Growl/Growl.h>
-
 #include <QPixmap>
-#include <QString>
 #include <QStringList>
 
 class GrowlNotifierSignaler;
@@ -42,21 +39,23 @@ class GrowlNotifierSignaler;
 class GrowlNotifier
 {
 public:
-	GrowlNotifier(
-		const QStringList& notifications, 
-		const QStringList& default_notifications,
-		const QString& app_name = "");
+	GrowlNotifier(  const QStringList& notifications,
+			const QStringList& default_notifications,
+			const QString& app_name = "");
+
+	virtual ~GrowlNotifier();
 	
-	void notify(const QString& name, const QString& title, 
-		const QString& description, const QPixmap& icon = QPixmap(), 
-		bool sticky = false, const QObject* receiver = 0, 
-		const char* clicked_slot = 0, const char* timeout_slot = 0,
-		void* context = 0);
+	void notify(const QString& name, const QString& title,
+		    const QString& description, const QPixmap& icon = QPixmap(),
+		    bool sticky = false, const QObject* receiver = 0,
+		    const char* clicked_slot = 0, const char* timeout_slot = 0,
+		    void* context = 0);
+
+	static bool isRunning();
 
 private:
-	struct Growl_Delegate delegate_;
-	
-	GrowlNotifierSignaler* signaler_;
+	class Private;
+	Private* d;
 };
 
 #endif
--- psi.orig/src/libpsi/tools/growlnotifier/growlnotifier.mm
+++ psi/src/libpsi/tools/growlnotifier/growlnotifier.mm
@@ -0,0 +1,258 @@
+/*
+ * growlnotifier.mm - A simple Qt interface to Growl
+ *
+ * Copyright (C) 2005  Remko Troncon
+ *               2012  Khryukin Evgeny
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * You can also redistribute and/or modify this program under the
+ * terms of the Psi License, specified in the accompanied COPYING
+ * file, as published by the Psi Project; either dated January 1st,
+ * 2005, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <AppKit/AppKit.h>
+#include <Cocoa/Cocoa.h>
+#include <Growl/GrowlApplicationBridge.h>
+
+#include <QBuffer>
+#include "growlnotifier.h"
+
+//------------------------------------------------------------------------------ 
+
+/**
+ * \brief A class for emitting a clicked signal to the interested party.
+ */
+class GrowlNotifierSignaler : public QObject
+{
+	Q_OBJECT
+public:
+	GrowlNotifierSignaler() : QObject() {}
+	~GrowlNotifierSignaler() {}
+
+	void emitNotification(void* context) { emit notification(context); }
+
+signals:
+	void notification(void*);
+};
+
+NSString* qString2NSString(const QString& str)
+{
+	return  [ NSString stringWithUTF8String: str.toUtf8().constData() ];
+}
+
+NSArray *qStringList2NSArray(const QStringList& list)
+{
+	int cnt = list.count();
+	if(!cnt)
+		return nil;
+
+	NSString *strings[cnt];
+	for(int i = 0; i < cnt; i++) {
+		strings[i] = qString2NSString(list.at(i));
+	}
+	return [ NSArray arrayWithObjects: strings count: cnt ];
+}
+
+NSData *qPixmap2NSData(const QPixmap& p)
+{
+	if (p.isNull()) {
+		return nil;
+	}
+
+	QByteArray img_data;
+	QBuffer buffer(&img_data);
+	buffer.open(QIODevice::WriteOnly);
+	p.save(&buffer, "PNG");
+	return [ NSData dataWithBytes: img_data.constData() length: img_data.size() ];
+}
+
+@interface GrowlController : NSObject <GrowlApplicationBridgeDelegate> {
+@private
+	NSArray* allNotifications;
+	NSArray* defaultNotifications;
+	NSString* appName;
+}
+-(void) setAllNotifications:(NSArray*)all setDefaultNotifications:(NSArray*) def setName:(NSString*) name;
+@end
+
+@implementation GrowlController
+
+-(id) init {
+	self = [super init];
+	if(self) {
+		allNotifications = nil;
+		defaultNotifications = nil;
+		appName = nil;
+	}
+	return self;
+}
+
+-(void)dealloc {
+	if(allNotifications)
+		[allNotifications release];
+	if(defaultNotifications)
+		[defaultNotifications release];
+	if(appName)
+		[appName release];
+	[super dealloc];
+}
+
+-(void) setAllNotifications:(NSArray*)all setDefaultNotifications:(NSArray*) def setName:(NSString*) name {
+	allNotifications = all;
+	defaultNotifications = def;
+	appName = name;
+	if(allNotifications)
+		[allNotifications retain];
+	if(defaultNotifications)
+		[defaultNotifications retain];
+	if(appName)
+		[appName retain];
+}
+
+-(NSDictionary*) registrationDictionaryForGrowl {
+
+	NSDictionary *dict = [ NSDictionary dictionaryWithObjectsAndKeys:
+			allNotifications, GROWL_NOTIFICATIONS_ALL,
+			defaultNotifications, GROWL_NOTIFICATIONS_DEFAULT,
+			nil ];
+	return dict;
+}
+
+-(NSString*) applicatioNameForGrowl {
+	return appName;
+}
+
+-(NSData*) applicationIconDataForGrowl {
+	return nil;
+}
+
+-(void) growlNotificationWasClicked:(id)clickContext {
+	if(!clickContext)
+		return;
+
+	GrowlNotifierSignaler* signaler = *(GrowlNotifierSignaler**)([[clickContext objectAtIndex: 0] bytes]);
+	const QObject* receiver = *(const QObject**)([[clickContext objectAtIndex: 1] bytes]);
+	const char* slot = *(const char**)([[clickContext objectAtIndex: 3] bytes]);
+	void* qcontext = *(void**)([[clickContext objectAtIndex: 2] bytes]);
+
+	QObject::connect(signaler,SIGNAL(notification(void*)),receiver,slot);
+	signaler->emitNotification(qcontext);
+	QObject::disconnect(signaler,SIGNAL(notification(void*)),receiver,slot);
+}
+
+-(void) growlNotificationTimedOut:(id)clickContext {
+	if(!clickContext)
+		return;
+
+	GrowlNotifierSignaler* signaler = *(GrowlNotifierSignaler**)([[clickContext objectAtIndex: 0] bytes]);
+	const QObject* receiver = *(const QObject**)([[clickContext objectAtIndex: 1] bytes]);
+	const char* slot = *(const char**)([[clickContext objectAtIndex: 4] bytes]);
+	void* qcontext = *(void**)([[clickContext objectAtIndex: 2] bytes]);
+
+	QObject::connect(signaler,SIGNAL(notification(void*)),receiver,slot);
+	signaler->emitNotification(qcontext);
+	QObject::disconnect(signaler,SIGNAL(notification(void*)),receiver,slot);
+}
+
+@end
+
+//------------------------------------------------------------------------------ 
+class GrowlNotifier::Private : public GrowlNotifierSignaler
+{
+public:
+	Private() : GrowlNotifierSignaler() {}
+	~Private() {}
+
+	GrowlController* controller_;
+};
+
+
+/**
+ * Constructs a GrowlNotifier.
+ *
+ * \param notifications the list names of all notifications that can be sent
+ *	by this notifier.
+ * \param default_notifications the list of names of the notifications that
+ *  should be enabled by default.
+ * \param app the name of the application under which the notifier should
+ *	register with growl.
+ */
+GrowlNotifier::GrowlNotifier(const QStringList& notifications,
+			     const QStringList& default_notifications,
+			     const QString& app)
+{
+	d = new Private;
+	d->controller_ = [ [ GrowlController alloc ] init ];
+	[ d->controller_ setAllNotifications: qStringList2NSArray(notifications)
+	      setDefaultNotifications: qStringList2NSArray(default_notifications)
+	      setName: qString2NSString(app) ];
+
+	[ GrowlApplicationBridge setGrowlDelegate: d->controller_ ];
+}
+
+GrowlNotifier::~GrowlNotifier()
+{
+	[ d->controller_ release ];
+	delete d;
+}
+
+/**
+ * \brief Sends a notification to Growl.
+ *
+ * \param name the registered name of the notification.
+ * \param title the title for the notification.
+ * \param description the description of the notification.
+ * \param icon the icon of the notification.
+ * \param sticky whether the notification should be sticky (i.e. require a
+ *	click to discard.
+ * \param receiver the receiving object which will be signaled when the
+ *	notification is clicked. May be NULL.
+ * \param slot the slot to be signaled when the notification is clicked.
+ * \param context the context which will be passed back to the slot
+ *	May be NULL.
+ */
+void GrowlNotifier::notify(const QString& name, const QString& title, 
+			   const QString& description, const QPixmap& p, bool sticky,
+			   const QObject* receiver,
+			   const char* clicked_slot, const char* timeout_slot,
+			   void* qcontext)
+{
+	NSArray *con = [ NSArray arrayWithObjects:
+			[NSData dataWithBytes: &d length: sizeof(GrowlNotifierSignaler*)],
+			[NSData dataWithBytes: &receiver length: sizeof(const QObject*)],
+			[NSData dataWithBytes: &qcontext length: sizeof(void*)],
+			[NSData dataWithBytes: &clicked_slot length: sizeof(const char*)],
+			[NSData dataWithBytes: &timeout_slot length: sizeof(const char*)],
+			nil ];
+	[ GrowlApplicationBridge notifyWithTitle: qString2NSString(title)
+	      description: qString2NSString(description)
+	      notificationName: qString2NSString(name)
+	      iconData: qPixmap2NSData(p)
+	      priority: 0
+	      isSticky: sticky ? YES : NO
+	      clickContext: con ];
+}
+
+bool GrowlNotifier::isRunning()
+{
+	return [ GrowlApplicationBridge isGrowlRunning ];
+}
+
+//----------------------------------------------------------------------------- 
+
+#include "growlnotifier.moc"
--- psi.orig/src/libpsi/tools/growlnotifier/growlnotifier.pri
+++ psi/src/libpsi/tools/growlnotifier/growlnotifier.pri
@@ -1,5 +1,5 @@
 DEPENDPATH  += $$PWD
 
 HEADERS += $$PWD/growlnotifier.h
-SOURCES += $$PWD/growlnotifier.cpp
-QMAKE_LFLAGS += -framework Growl -framework CoreFoundation
+OBJECTIVE_SOURCES  += $$PWD/growlnotifier.mm
+QMAKE_LFLAGS += -framework Growl -framework Cocoa
--- psi.orig/src/popupmanager.cpp
+++ psi/src/popupmanager.cpp
@@ -239,7 +239,8 @@ QList< PopupManager::NotificationsType >
 	if(availableTypes_.isEmpty()) {
 		availableTypes_ << Default;
 #if defined(Q_WS_MAC) && defined(HAVE_GROWL)
-		availableTypes_ << Growl;
+		if(PsiGrowlNotifier::isAvailable())
+			availableTypes_ << Growl;
 #endif
 #ifdef USE_DBUS
 		if(PsiDBusNotifier::isAvailable())
--- psi.orig/src/psigrowlnotifier.cpp
+++ psi/src/psigrowlnotifier.cpp
@@ -287,4 +287,9 @@ void PsiGrowlNotifier::notificationTimed
 	tryDeleteContext(context);
 }
 
+bool  PsiGrowlNotifier::isAvailable()
+{
+	return GrowlNotifier::isRunning();
+}
+
 PsiGrowlNotifier* PsiGrowlNotifier::instance_ = 0;
--- psi.orig/src/psigrowlnotifier.h
+++ psi/src/psigrowlnotifier.h
@@ -47,6 +47,7 @@ class PsiGrowlNotifier : public QObject
 
 public:
 	static PsiGrowlNotifier* instance();
+	static bool isAvailable();
 	void popup(PsiAccount* account, PopupManager::PopupType type, const Jid& j, const Resource& r, const UserListItem* = 0, PsiEvent* = 0);
 	void popup(PsiAccount *account, const Jid &j, const PsiIcon *titleIcon, const QString& titleText, const QString& text);
 
