--- psi.orig/iris/src/xmpp/xmpp-im/client.cpp
+++ psi/iris/src/xmpp/xmpp-im/client.cpp
@@ -628,6 +628,7 @@ void Client::send(const QDomElement &x,
 		//printf("bad stanza??\n");
 		return;
 	}
+	emit stanzaElementOutgoing(e);
 	QString out = s.toString();
 	//qWarning() << "Out: " << out;
 	debug(QString("Client: outgoing: [\n%1]\n").arg(out));
--- psi.orig/iris/src/xmpp/xmpp-im/xmpp_client.h
+++ psi/iris/src/xmpp/xmpp-im/xmpp_client.h
@@ -151,6 +151,7 @@ namespace XMPP
 		void debugText(const QString &);
 		void xmlIncoming(const QString &);
 		void xmlOutgoing(const QString &);
+		void stanzaElementOutgoing(QDomElement &);
 		void groupChatJoined(const Jid &);
 		void groupChatLeft(const Jid &);
 		void groupChatPresence(const Jid &, const Status &);
--- psi.orig/src/applicationinfo.cpp
+++ psi/src/applicationinfo.cpp
@@ -27,6 +27,7 @@
 
 #include "psiapplication.h"
 #include "applicationinfo.h"
+#include "systeminfo.h"
 #include "profiles.h"
 #include "homedirmigration.h"
 #include "activeprofiles.h"
@@ -88,6 +89,11 @@ QString ApplicationInfo::capsVersion()
 	return PROG_CAPS_VERSION;
 }
 
+QString ApplicationInfo::osName()
+{
+	return SystemInfo::instance()->os();
+}
+
 QString ApplicationInfo::IPCName()
 {
 	return PROG_IPC_NAME;
--- psi.orig/src/applicationinfo.h
+++ psi/src/applicationinfo.h
@@ -20,6 +20,7 @@ public:
 	static QString version();
 	static QString capsNode();
 	static QString capsVersion();
+	static QString osName();
 	static QString IPCName();
 
 	// URLs
--- psi.orig/src/chatdlg.cpp
+++ psi/src/chatdlg.cpp
@@ -81,6 +81,10 @@
 #include <windows.h>
 #endif
 
+#ifdef PSI_PLUGINS
+#include "pluginmanager.h"
+#endif
+
 #include "psichatdlg.h"
 
 static const QString geometryOption = "options.ui.chat.size";
@@ -894,10 +898,26 @@ void ChatDlg::appendMessage(const Messag
 	}
 
 	MessageView mv(MessageView::Message);
-	if (m.containsHTML() && PsiOptions::instance()->getOption("options.html.chat.render").toBool() && !m.html().body().firstChild().isNull()) {
-		mv.setHtml(m.html().toString("span"));
+
+	QString body = m.body();
+	HTMLElement htmlElem;
+	if (m.containsHTML())
+		htmlElem = m.html();
+
+#ifdef PSI_PLUGINS
+	QDomElement html = htmlElem.body();
+
+	PluginManager::instance()->appendingChatMessage(account(), jid().full(), body, html, local);
+
+	if(!html.isNull())
+		htmlElem.setBody(html);
+#endif
+
+	if (PsiOptions::instance()->getOption("options.html.chat.render").toBool() && !htmlElem.body().isNull()
+			&& !htmlElem.body().firstChild().isNull()) {
+		mv.setHtml(htmlElem.toString("span"));
 	} else {
-		mv.setPlainText(m.body());
+		mv.setPlainText(body);
 	}
 	mv.setMessageId(m.id());
 	mv.setLocal(local);
--- psi.orig/src/chatdlg.h
+++ psi/src/chatdlg.h
@@ -170,7 +170,11 @@ protected:
 
 	void appendMessage(const Message &, bool local = false);
 	virtual bool isEncryptionEnabled() const;
+
+public:
 	virtual void appendSysMsg(const QString& txt) = 0;
+
+protected:
 	virtual void nicksChanged();
 
 	QString whoNick(bool local) const;
--- psi.orig/src/common.cpp
+++ psi/src/common.cpp
@@ -25,6 +25,7 @@
 #include "psiiconset.h"
 #include "applicationinfo.h"
 #include "psioptions.h"
+#include "tabdlg.h"
 
 #include <QUrl>
 #include <QProcess>
@@ -427,6 +428,32 @@ void reorderGridLayout(QGridLayout* layo
 	}
 }
 
+TabbableWidget* findActiveTab()
+{
+	QWidget* chat = QApplication::activeWindow();
+	TabbableWidget* tw = 0;
+	if(chat) {
+		TabDlg* td = qobject_cast<TabDlg*>(chat);
+		if(td) {
+			tw = td->getCurrentTab();
+		}
+		else {
+			tw = qobject_cast<TabbableWidget*>(chat);
+			if (!tw) {
+				QList<TabDlg*> tmp = chat->findChildren<TabDlg*>(); // all-in-one
+				while(!tmp.isEmpty()) {
+					TabDlg* td = tmp.takeFirst();
+					tw = td->getCurrentTab();
+					if(tw) {
+						break;
+					}
+				}
+			}
+		}
+	}
+	return tw;
+}
+
 #ifdef HAVE_X11
 #include <X11/Xlib.h>
 #include <X11/Xutil.h> // needed for WM_CLASS hinting
--- psi.orig/src/common.h
+++ psi/src/common.h
@@ -30,6 +30,7 @@
 #include <QGridLayout>
 
 class QMenu;
+class TabbableWidget;
 
 #include "statuspreset.h"
 
@@ -150,6 +151,7 @@ void clearMenu(QMenu *m); // deletes all
 void bringToFront(QWidget *w, bool grabFocus = true);
 void replaceWidget(QWidget *, QWidget *);
 void closeDialogs(QWidget *);
+TabbableWidget* findActiveTab();
 #ifdef HAVE_X11
 #include <QWidget>
 #include <QX11Info>
--- psi.orig/src/contactlistaccountmenu.cpp
+++ psi/src/contactlistaccountmenu.cpp
@@ -22,6 +22,8 @@
 
 #include <QPointer>
 
+#include "pluginmanager.h"
+#include "psiiconset.h"
 #include "psiaccount.h"
 #include "contactlistaccountgroup.h"
 #include "accountstatusmenu.h"
@@ -64,6 +66,7 @@ class ContactListAccountMenu::Private :
 	QAction* adminUpdateMotdAction_;
 	QAction* adminDeleteMotdAction_;
 	QAction *doGroupChatAction_;
+	QMenu* pluginsMenu_;
 
 public:
 	Private(ContactListAccountMenu* menu, ContactListAccountGroup* _account)
@@ -166,6 +169,12 @@ public:
 		menu->addAction(xmlConsoleAction_);
 		menu->addSeparator();
 		menu->addAction(modifyAccountAction_);
+
+#ifdef PSI_PLUGINS
+		pluginsMenu_ = menu->addMenu(IconsetFactory::icon("psi/plugins").icon(), tr("Plugins"));
+		PluginManager::instance()->addAccountMenu(pluginsMenu_, account->account());
+#endif
+
 		adminMenu_ = menu->addMenu(tr("&Admin"));
 		adminMenu_->addAction(adminOnlineUsersAction_);
 		adminMenu_->addAction(adminSendServerMessageAction_);
@@ -235,6 +244,12 @@ private slots:
 		adminSetMotdAction_->setVisible(newMessageAction_->isVisible());
 		adminUpdateMotdAction_->setVisible(newMessageAction_->isVisible());
 		adminDeleteMotdAction_->setVisible(newMessageAction_->isVisible());
+
+#ifdef PSI_PLUGINS
+		if(pluginsMenu_->isEmpty())
+			pluginsMenu_->menuAction()->setVisible(false);
+		pluginsMenu_->setEnabled(account->account()->isAvailable() && !pluginsMenu_->isEmpty());
+#endif
 	}
 
 	void statusChanged(XMPP::Status::Type statusType, bool forceDialog)
--- psi.orig/src/groupchatdlg.cpp
+++ psi/src/groupchatdlg.cpp
@@ -85,6 +85,9 @@
 #include "mucreasonseditor.h"
 #include "mcmdmanager.h"
 #include "lastactivitytask.h"
+#ifdef PSI_PLUGINS
+#include "pluginmanager.h"
+#endif
 #include "psirichtext.h"
 #include "psiwindowheader.h"
 #include "avatars.h"
@@ -904,6 +907,10 @@ GCMainDlg::GCMainDlg(PsiAccount *pa, con
 	connect(ui_.log->textWidget(), SIGNAL(quote(const QString &)), ui_.mle->chatEdit(), SLOT(insertAsQuote(const QString &)));
 
 	connect(pa->avatarFactory(), SIGNAL(avatarChanged(Jid)), SLOT(avatarUpdated(Jid)));
+
+#ifdef PSI_PLUGINS
+	PluginManager::instance()->setupGCTab(this, account(), jid().full());
+#endif
 }
 
 GCMainDlg::~GCMainDlg()
@@ -2037,6 +2044,14 @@ void GCMainDlg::setToolbuttons()
 	PsiOptions *options = PsiOptions::instance();
 	QStringList actionsNames = options->getOption("options.ui.contactlist.toolbars.m1.actions").toStringList();
 	foreach (const QString &actionName, actionsNames) {
+#ifdef PSI_PLUGINS
+		if (actionName.endsWith("-plugin")) {
+			QString name = PluginManager::instance()->nameByShortName(actionName.mid(0, actionName.length() - 7));
+			PluginManager::instance()->addGCToolBarButton(this, ui_.toolbar, account(), jid().full(), name);
+			continue;
+		}
+#endif
+
 		// Hack. separator action can be added only once.
 		if (actionName == "separator") {
 			ui_.toolbar->addSeparator();
@@ -2198,6 +2213,12 @@ void GCMainDlg::buildMenu()
 	d->pm_settings->addAction(d->actions->action("gchat_ps"));
 	d->pm_settings->addAction(d->act_nick);
 	d->pm_settings->addAction(d->act_bookmark);
+#ifdef PSI_PLUGINS
+	if(!PsiOptions::instance()->getOption("options.ui.contactlist.toolbars.m1.visible").toBool()) {
+		d->pm_settings->addSeparator();
+		PluginManager::instance()->addGCToolBarButton(this, d->pm_settings, account(), jid().full());
+	}
+#endif
 }
 
 void GCMainDlg::chatEditCreated()
--- psi.orig/src/options/optionsdlg.cpp
+++ psi/src/options/optionsdlg.cpp
@@ -196,6 +196,7 @@ private slots:
 
 	//void addWidgetChangedSignal(QString widgetName, QCString signal);
 	void connectDataChanged(QWidget *);
+	void connectSignalsToWidget(QWidget *, QObject *, const char *);
 
 public:
 	OptionsDlg *dlg;
@@ -236,6 +237,9 @@ OptionsDlg::Private::Private(OptionsDlg
 		//connect(opttab, SIGNAL(addWidgetChangedSignal(QString, QCString)), SLOT(addWidgetChangedSignal(QString, QCString)));
 		connect(opttab, SIGNAL(noDirty(bool)), SLOT(noDirtySlot(bool)));
 		connect(opttab, SIGNAL(connectDataChanged(QWidget *)), SLOT(connectDataChanged(QWidget *)));
+		connect(opttab,
+			SIGNAL(connectSignalsToWidget(QWidget*,QObject*,const char*)),
+			SLOT(connectSignalsToWidget(QWidget*,QObject*,const char*)));
 
 		if ( opttab->id().isEmpty() )
 			continue;
@@ -444,6 +448,11 @@ void OptionsDlg::Private::enableCommonWi
 
 void OptionsDlg::Private::connectDataChanged(QWidget *widget)
 {
+	connectSignalsToWidget(widget, this, SLOT(dataChanged()));
+}
+
+void OptionsDlg::Private::connectSignalsToWidget(QWidget *widget, QObject *object, const char *slot)
+{
 	foreach(QWidget* w, widget->findChildren<QWidget*>()) {
 		QVariant isOption = w->property("isOption");
 		if (isOption.isValid() && !isOption.toBool()) {
@@ -451,8 +460,8 @@ void OptionsDlg::Private::connectDataCha
 		}
 		QMap<QString, QByteArray>::Iterator it2 = changedMap.find( w->metaObject()->className() );
 		if ( it2 != changedMap.end() ) {
-			disconnect(w, changedMap[w->metaObject()->className()], this, SLOT(dataChanged()));
-			connect(w, changedMap[w->metaObject()->className()], SLOT(dataChanged()));
+			disconnect(w, changedMap[w->metaObject()->className()], object, slot);
+			connect(w, changedMap[w->metaObject()->className()], object, slot);
 		}
 	}
 }
--- psi.orig/src/options/options.pri
+++ psi/src/options/options.pri
@@ -79,7 +79,9 @@ FORMS += \
 	$$PWD/opt_iconset_roster.ui \
 	$$PWD/opt_general_groupchat.ui \
 	$$PWD/opt_shortcuts.ui \
-	$$PWD/opt_statuspep.ui
+	$$PWD/opt_statuspep.ui \
+	$$PWD/plugininfodialog.ui \
+	$$PWD/pluginsettsdialog.ui
 
 psi_plugins {
 	FORMS += $$PWD/opt_plugins.ui
--- psi.orig/src/options/optionstab.cpp
+++ psi/src/options/optionstab.cpp
@@ -241,6 +241,9 @@ void MetaOptionsTab::addTab(OptionsTab *
 	//connect(tab, SIGNAL(addWidgetChangedSignal(QString, QCString)), SIGNAL(addWidgetChangedSignal(QString, QCString)));
 	connect(tab, SIGNAL(noDirty(bool)), SIGNAL(noDirty(bool)));
 	connect(tab, SIGNAL(connectDataChanged(QWidget *)), SIGNAL(connectDataChanged(QWidget *)));
+	connect(tab,
+		SIGNAL(connectSignalsToWidget(QWidget*,QObject*,const char*)),
+		SIGNAL(connectSignalsToWidget(QWidget*,QObject*,const char*)));
 
 	tabs.append(tab);
 }
@@ -262,6 +265,9 @@ QWidget *MetaOptionsTab::widget()
 
 	connect(w, SIGNAL(connectDataChanged(QWidget *)), SIGNAL(connectDataChanged(QWidget *)));
 	connect(w, SIGNAL(noDirty(bool)), SIGNAL(noDirty(bool)));
+	connect(w,
+		SIGNAL(connectSignalsToWidget(QWidget*,QObject*,const char*)),
+		SIGNAL(connectSignalsToWidget(QWidget*,QObject*,const char*)));
 
 	foreach(OptionsTab* tab, tabs) {
 		t->addTab(tab);
--- psi.orig/src/options/optionstab.h
+++ psi/src/options/optionstab.h
@@ -36,6 +36,7 @@ signals:
 	//void addWidgetChangedSignal(QString widgetName, QCString signal);
 	void noDirty(bool);
 	void connectDataChanged(QWidget *);
+	void connectSignalsToWidget(QWidget *, QObject *, const char *);
 
 public slots:
 	virtual void setData(PsiCon *, QWidget *parentDialog);
--- psi.orig/src/options/opt_plugins.cpp
+++ psi/src/options/opt_plugins.cpp
@@ -3,12 +3,11 @@
 #include "iconwidget.h"
 #include "pluginmanager.h"
 #include "psioptions.h"
+#include "psiiconset.h"
 
 #include <QWhatsThis>
-#include <QCheckBox>
-#include <QComboBox>
-#include <QButtonGroup>
-#include <QRadioButton>
+#include <QToolButton>
+#include <QHeaderView>
 
 #include "ui_opt_plugins.h"
 
@@ -23,13 +22,17 @@ public:
 //----------------------------------------------------------------------------
 
 OptionsTabPlugins::OptionsTabPlugins(QObject *parent)
-: OptionsTab(parent, "plugins", "", tr("Plugins"), tr("Options for Psi plugins"), "psi/plugins")
+	: OptionsTab(parent, "plugins", "", tr("Plugins"), tr("Options for Psi plugins"), "psi/plugins")
+	, w(0)
 {
-	w = 0;
 }
 
 OptionsTabPlugins::~OptionsTabPlugins()
 {
+	if( infoDialog )
+		delete(infoDialog);
+	if( settingsDialog )
+		delete(settingsDialog);
 }
 
 QWidget *OptionsTabPlugins::widget()
@@ -41,117 +44,183 @@ QWidget *OptionsTabPlugins::widget()
 	OptPluginsUI *d = (OptPluginsUI *)w;
 
 	listPlugins();
-
-
-	/*d->ck_messageevents->setWhatsThis(
-		tr("Enables the sending and requesting of message events such as "
-		"'Contact is Typing', ..."));*/
-
-	connect(d->cb_plugins,SIGNAL(currentIndexChanged(int)),SLOT(pluginSelected(int)));
-	connect(d->cb_loadPlugin,SIGNAL(stateChanged(int)),SLOT(loadToggled(int)));
+	connect(d->tw_Plugins, SIGNAL(itemChanged(QTreeWidgetItem*,int)), this, SLOT(itemChanged(QTreeWidgetItem*,int)));
 
 	return w;
 }
 
-void OptionsTabPlugins::applyOptions(Options *opt)
+void OptionsTabPlugins::applyOptions()
 {
-	if ( !w )
-		return;
-
-	OptPluginsUI *d = (OptPluginsUI *)w;
-	Q_UNUSED(d);
-	Q_UNUSED(opt);
 }
 
-void OptionsTabPlugins::restoreOptions(const Options *opt)
+void OptionsTabPlugins::restoreOptions()
 {
-	if ( !w )
-		return;
+}
 
-	OptPluginsUI *d = (OptPluginsUI *)w;
-	Q_UNUSED(opt);
-	Q_UNUSED(d);
+bool OptionsTabPlugins::stretchable() const
+{
+	return true;
 }
 
+
 void OptionsTabPlugins::listPlugins()
 {
-  	if ( !w )
+	if ( !w )
 		return;
 
 	OptPluginsUI *d = (OptPluginsUI *)w;
 
-	d->cb_plugins->clear();
+	d->tw_Plugins->clear();
 
 	PluginManager *pm=PluginManager::instance();
 
-	QStringList plugins=pm->availablePlugins();
-		foreach (QString plugin, plugins){
-		d->cb_plugins->addItem(plugin);
+	QStringList plugins = pm->availablePlugins();
+	plugins.sort();
+	const QSize buttonSize = QSize(21,21);
+	foreach ( const QString& plugin, plugins ){
+		QIcon icon = pm->icon(plugin);
+		bool enabled = pm->isEnabled(plugin);
+		const QString path = pm->pathToPlugin(plugin);
+		QString toolTip = tr("Plugin Path:\n%1").arg(path);
+		Qt::CheckState state = enabled ? Qt::Checked : Qt::Unchecked;
+		QTreeWidgetItem *item = new QTreeWidgetItem(d->tw_Plugins, QTreeWidgetItem::Type);
+		item->setFlags(item->flags() | Qt::ItemIsUserCheckable);
+		item->setText(C_NAME, plugin);
+		item->setText(C_VERSION, pm->version(plugin));
+		item->setTextAlignment(C_VERSION, Qt::AlignHCenter);
+		item->setToolTip(C_NAME, toolTip);
+		item->setCheckState(C_NAME, state);
+		if ( !enabled ) {
+			icon = QIcon(icon.pixmap(icon.availableSizes().at(0), QIcon::Disabled));
+		}
+		item->setIcon(C_NAME,icon);
+		QString shortName = PluginManager::instance()->shortName(plugin);
+
+		QToolButton *aboutbutton = new QToolButton(d->tw_Plugins);
+		aboutbutton->setIcon(QIcon(IconsetFactory::iconPixmap("psi/info")));
+		aboutbutton->resize(buttonSize);
+		aboutbutton->setObjectName("ab_" + shortName);
+		aboutbutton->setToolTip(tr("Show information about plugin"));
+		connect(aboutbutton, SIGNAL(clicked()), this, SLOT(showPluginInfo()));
+		d->tw_Plugins->setItemWidget(item, C_ABOUT, aboutbutton);
+
+		QToolButton *settsbutton = new QToolButton(d->tw_Plugins);
+		settsbutton->setIcon(QIcon(IconsetFactory::iconPixmap("psi/options")));
+		settsbutton->resize(buttonSize);
+		settsbutton->setObjectName("sb_" + shortName);
+		settsbutton->setToolTip(tr("Open plugin settings dialog"));
+		connect(settsbutton, SIGNAL(clicked()), this, SLOT(settingsClicked()));
+		settsbutton->setEnabled(enabled);
+		d->tw_Plugins->setItemWidget(item, C_SETTS, settsbutton);
+	}
+	if ( d->tw_Plugins->topLevelItemCount() > 0 ) {
+#ifdef HAVE_QT5
+		d->tw_Plugins->header()->setSectionResizeMode(C_NAME, QHeaderView::Stretch);
+#else
+		d->tw_Plugins->header()->setResizeMode(C_NAME, QHeaderView::Stretch);
+#endif
+		d->tw_Plugins->resizeColumnToContents(C_VERSION);
+		d->tw_Plugins->resizeColumnToContents(C_ABOUT);
+		d->tw_Plugins->resizeColumnToContents(C_SETTS);
 	}
-	pluginSelected(0);
 }
 
-void OptionsTabPlugins::loadToggled(int state)
+void OptionsTabPlugins::itemChanged(QTreeWidgetItem *item, int column)
 {
-	Q_UNUSED(state);
+	Q_UNUSED(column);
 	if ( !w )
 		return;
-
 	OptPluginsUI *d = (OptPluginsUI *)w;
+	bool enabled = item->checkState(C_NAME) == Qt::Checked;
+	d->tw_Plugins->setCurrentItem(item);
 
+	PluginManager *pm = PluginManager::instance();
+	QString name = item->text(C_NAME);
 	QString option=QString("%1.%2")
 		.arg(PluginManager::loadOptionPrefix)
-		.arg(PluginManager::instance()->shortName(d->cb_plugins->currentText()));
-	bool value=d->cb_loadPlugin->isChecked();
-	PsiOptions::instance()->setOption(option, value);
+		.arg(pm->shortName(name));
+	PsiOptions::instance()->setOption(option, enabled);
+
+	d->tw_Plugins->blockSignals(true); //Block signalls to change item elements
+	d->tw_Plugins->itemWidget(item, C_SETTS)->setEnabled(enabled);
+	QIcon icon = pm->icon(name);
+	if ( !enabled ) {
+		icon = QIcon(icon.pixmap(icon.availableSizes().at(0), QIcon::Disabled));
+	}
+	item->setIcon(C_NAME, icon);
+	d->tw_Plugins->blockSignals(false); //Release signals blocking
+}
+
+void OptionsTabPlugins::showPluginInfo()
+{
+	if ( !w || !sender()->inherits("QToolButton") )
+		return;
+	OptPluginsUI *d = (OptPluginsUI *)w;
+	QToolButton *btn = static_cast<QToolButton*>(sender());
+	const QPoint coords(btn->x(),btn->y());
+	d->tw_Plugins->setCurrentItem(d->tw_Plugins->itemAt(coords));
+	if ( d->tw_Plugins->selectedItems().size() > 0 ) {
+		if( infoDialog )
+			delete(infoDialog);
+
+		infoDialog = new QDialog(d);
+		ui_.setupUi(infoDialog);
+		QString name = d->tw_Plugins->currentItem()->text(C_NAME);
+		infoDialog->setWindowTitle(QString("%1 %2").arg(infoDialog->windowTitle()).arg(name));
+		infoDialog->setWindowIcon(QIcon(IconsetFactory::iconPixmap("psi/logo_128")));
+		ui_.te_info->setText(PluginManager::instance()->pluginInfo(name));
+		infoDialog->setAttribute(Qt::WA_DeleteOnClose);
+		infoDialog->show();
+	}
 }
 
-void OptionsTabPlugins::pluginSelected(int index)
+void OptionsTabPlugins::settingsClicked()
 {
-	Q_UNUSED(index);
-  	if ( !w )
+	if ( !w || !sender()->inherits("QToolButton") )
 		return;
 
 	OptPluginsUI *d = (OptPluginsUI *)w;
-	d->le_location->setText(tr("No plugin selected."));
-	d->cb_loadPlugin->setEnabled(false);
-	delete d->pluginOptions;
-	d->pluginOptions = new QLabel(tr("This plugin has no user configurable options"));
-
-	if ( d->cb_plugins->count() > 0 ) {
-		QString pluginName=d->cb_plugins->currentText();
-		d->le_location->setText(PluginManager::instance()->pathToPlugin( pluginName ));
-		d->cb_loadPlugin->setEnabled(true);
+	QToolButton *btn = static_cast<QToolButton*>(sender());
+	const QPoint coords(btn->x(),btn->y());
+	d->tw_Plugins->setCurrentItem(d->tw_Plugins->itemAt(coords));
+	if ( d->tw_Plugins->selectedItems().size() > 0 ) {
+		const QString pluginName = d->tw_Plugins->currentItem()->text(C_NAME);
+		const QString shortName = PluginManager::instance()->shortName(pluginName);
+		const QString geometryOption = QString("plugins.options.%1.dialog-size").arg(shortName);
 		QWidget* pluginOptions = PluginManager::instance()->optionsWidget( pluginName );
-		d->cb_plugins->setEnabled(true);
+		PluginManager::instance()->restoreOptions( pluginName );
+		pluginOptions->setParent(d);
 
-		QString option=QString("%1.%2")
-			.arg(PluginManager::loadOptionPrefix)
-			.arg(PluginManager::instance()->shortName(pluginName));
-		int value=PsiOptions::instance()->getOption(option, false).toBool();
-		if (value)
-			value=Qt::Checked;
-		else
-			value=Qt::Unchecked;
-		d->cb_loadPlugin->setChecked(value);
-
-		d->vboxLayout1->removeWidget(d->pluginOptions);
-		delete d->pluginOptions;
-		d->pluginOptions=NULL;
-		if (pluginOptions)
-		{
-			d->pluginOptions = pluginOptions;
-			d->pluginOptions->setParent(d);
-			qWarning("Showing Plugin options");
-		}
-		else
-		{
-			d->pluginOptions = new QLabel(tr("This plugin has no user configurable options"),d);
-			qWarning("Plugin has no options");
-		}
+		if( settingsDialog )
+			delete(settingsDialog);
 
-		d->vboxLayout1->addWidget(d->pluginOptions);
-		//d->pluginOptions->show();
-		//d->updateGeometry();
+		settingsDialog = new AdvancedWidget<QDialog>(d);
+		settsUi_.setupUi(settingsDialog);
+		settingsDialog->setWindowIcon(QIcon(IconsetFactory::iconPixmap("psi/logo_128")));
+		settingsDialog->setWindowTitle(tr("Settings of %1").arg(pluginName));
+		settsUi_.verticalLayout->insertWidget(0, pluginOptions);
+		connectSignalsToWidget(pluginOptions, this, SLOT(onDataChanged()));
+		connect(settsUi_.buttonBox->button(QDialogButtonBox::Ok), SIGNAL(clicked()), this, SLOT(onSettingsOk()));
+		connect(settsUi_.buttonBox->button(QDialogButtonBox::Apply), SIGNAL(clicked()), this, SLOT(onSettingsOk()));
+		settsUi_.buttonBox->button(QDialogButtonBox::Apply)->setEnabled(false);
+		settingsDialog->setGeometryOptionPath(geometryOption);
+		settingsDialog->setAttribute(Qt::WA_DeleteOnClose);
+		settingsDialog->show();
 	}
 }
+
+void OptionsTabPlugins::onSettingsOk()
+{
+	if ( !w )
+		return;
+	OptPluginsUI *d = (OptPluginsUI *)w;
+	if ( d->tw_Plugins->currentItem()->isSelected() ) {
+		PluginManager::instance()->applyOptions( d->tw_Plugins->currentItem()->text(C_NAME) );
+	}
+	settsUi_.buttonBox->button(QDialogButtonBox::Apply)->setEnabled(false);
+}
+
+void OptionsTabPlugins::onDataChanged()
+{
+	settsUi_.buttonBox->button(QDialogButtonBox::Apply)->setEnabled(true);
+}
--- psi.orig/src/options/opt_plugins.h
+++ psi/src/options/opt_plugins.h
@@ -2,6 +2,11 @@
 #define OPT_PLUGINS_H
 
 #include "optionstab.h"
+#include "advwidget.h"
+#include "ui_plugininfodialog.h"
+#include "ui_pluginsettsdialog.h"
+#include <QPointer>
+#include <QTreeWidgetItem>
 
 class QWidget;
 class Options;
@@ -9,22 +14,35 @@ class Options;
 class OptionsTabPlugins : public OptionsTab
 {
 	Q_OBJECT
+	enum ColumnName {
+		C_NAME = 0,
+		C_VERSION = 1,
+		C_ABOUT = 2,
+		C_SETTS = 3
+	};
 public:
 	OptionsTabPlugins(QObject *parent);
 	~OptionsTabPlugins();
 
 	QWidget *widget();
-	void applyOptions(Options *opt);
-	void restoreOptions(const Options *opt);
+	void applyOptions();
+	void restoreOptions();
+	bool stretchable() const;
 
 private:
 	QWidget *w;
-	QWidget *pluginWidget;
+	QPointer<QDialog> infoDialog;
+	QPointer<AdvancedWidget<QDialog> > settingsDialog;
+	Ui::PluginInfoDialog ui_;
+	Ui::PluginSettingsDialog settsUi_;
 
 private slots:
 	void listPlugins();
-	void pluginSelected(int index);
-	void loadToggled(int state);
+	void showPluginInfo();
+	void itemChanged(QTreeWidgetItem *item, int column);
+	void settingsClicked();
+	void onSettingsOk();
+	void onDataChanged();
 };
 
 #endif
--- psi.orig/src/options/opt_plugins.ui
+++ psi/src/options/opt_plugins.ui
@@ -1,133 +1,98 @@
-<ui version="4.0" >
- <author></author>
- <comment></comment>
- <exportmacro></exportmacro>
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
  <class>OptPlugins</class>
- <widget class="QWidget" name="OptPlugins" >
-  <property name="geometry" >
+ <widget class="QWidget" name="OptPlugins">
+  <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>362</width>
+    <width>411</width>
     <height>400</height>
    </rect>
   </property>
-  <property name="windowTitle" >
+  <property name="windowTitle">
    <string>OptPluginsUI</string>
   </property>
-  <layout class="QVBoxLayout" >
-   <property name="margin" >
-    <number>9</number>
+  <layout class="QVBoxLayout" stretch="0">
+   <property name="bottomMargin">
+    <number>3</number>
    </property>
-   <property name="spacing" >
-    <number>6</number>
-   </property>
-   <item>
-    <widget class="QLabel" name="TextLabel2" >
-     <property name="text" >
-      <string>Plugin Name:</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QComboBox" name="cb_plugins" >
-     <property name="enabled" >
-      <bool>false</bool>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QLabel" name="label" >
-     <property name="text" >
-      <string>Plugin Location:</string>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QLineEdit" name="le_location" >
-     <property name="enabled" >
-      <bool>false</bool>
-     </property>
-     <property name="text" >
-      <string>No plugin selected</string>
-     </property>
-    </widget>
-   </item>
    <item>
-    <layout class="QHBoxLayout" >
-     <property name="margin" >
-      <number>0</number>
-     </property>
-     <property name="spacing" >
-      <number>6</number>
-     </property>
+    <layout class="QVBoxLayout" name="mainLayout">
      <item>
-      <widget class="QCheckBox" name="cb_loadPlugin" >
-       <property name="enabled" >
+      <widget class="QTreeWidget" name="tw_Plugins">
+       <property name="layoutDirection">
+        <enum>Qt::LeftToRight</enum>
+       </property>
+       <property name="horizontalScrollBarPolicy">
+        <enum>Qt::ScrollBarAlwaysOff</enum>
+       </property>
+       <property name="editTriggers">
+        <set>QAbstractItemView::NoEditTriggers</set>
+       </property>
+       <property name="showDropIndicator" stdset="0">
         <bool>false</bool>
        </property>
-       <property name="text" >
-        <string>Load this plugin</string>
+       <property name="alternatingRowColors">
+        <bool>true</bool>
        </property>
-      </widget>
-     </item>
-     <item>
-      <spacer>
-       <property name="orientation" >
-        <enum>Qt::Horizontal</enum>
-       </property>
-       <property name="sizeHint" >
-        <size>
-         <width>40</width>
-         <height>20</height>
-        </size>
+       <property name="rootIsDecorated">
+        <bool>false</bool>
        </property>
-      </spacer>
-     </item>
-    </layout>
-   </item>
-   <item>
-    <spacer>
-     <property name="orientation" >
-      <enum>Qt::Vertical</enum>
-     </property>
-     <property name="sizeHint" >
-      <size>
-       <width>20</width>
-       <height>40</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-   <item>
-    <layout class="QVBoxLayout" >
-     <property name="margin" >
-      <number>0</number>
-     </property>
-     <property name="spacing" >
-      <number>6</number>
-     </property>
-     <item>
-      <widget class="QWidget" name="pluginOptions" />
+       <property name="itemsExpandable">
+        <bool>false</bool>
+       </property>
+       <property name="expandsOnDoubleClick">
+        <bool>false</bool>
+       </property>
+       <attribute name="headerVisible">
+        <bool>false</bool>
+       </attribute>
+       <attribute name="headerDefaultSectionSize">
+        <number>100</number>
+       </attribute>
+       <attribute name="headerMinimumSectionSize">
+        <number>21</number>
+       </attribute>
+       <attribute name="headerStretchLastSection">
+        <bool>false</bool>
+       </attribute>
+       <column>
+        <property name="text">
+         <string>Plugin Name</string>
+        </property>
+        <property name="whatsThis">
+         <string>Available plugins</string>
+        </property>
+        <property name="textAlignment">
+         <set>AlignHCenter|AlignVCenter|AlignCenter</set>
+        </property>
+       </column>
+       <column>
+        <property name="text">
+         <string>Version</string>
+        </property>
+        <property name="textAlignment">
+         <set>AlignHCenter|AlignVCenter|AlignCenter</set>
+        </property>
+       </column>
+       <column>
+        <property name="text">
+         <string>A</string>
+        </property>
+       </column>
+       <column>
+        <property name="text">
+         <string>S</string>
+        </property>
+       </column>
+      </widget>
      </item>
     </layout>
    </item>
-   <item>
-    <spacer>
-     <property name="orientation" >
-      <enum>Qt::Vertical</enum>
-     </property>
-     <property name="sizeHint" >
-      <size>
-       <width>20</width>
-       <height>40</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
   </layout>
  </widget>
- <layoutdefault spacing="6" margin="11" />
+ <layoutdefault spacing="6" margin="11"/>
  <resources/>
  <connections/>
 </ui>
--- psi.orig/src/options/plugininfodialog.ui
+++ psi/src/options/plugininfodialog.ui
@@ -0,0 +1,96 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>PluginInfoDialog</class>
+ <widget class="QDialog" name="PluginInfoDialog">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>400</width>
+    <height>300</height>
+   </rect>
+  </property>
+  <property name="sizePolicy">
+   <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="minimumSize">
+   <size>
+    <width>400</width>
+    <height>300</height>
+   </size>
+  </property>
+  <property name="maximumSize">
+   <size>
+    <width>400</width>
+    <height>300</height>
+   </size>
+  </property>
+  <property name="windowTitle">
+   <string>About</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <item>
+    <widget class="QTextEdit" name="te_info">
+     <property name="sizePolicy">
+      <sizepolicy hsizetype="MinimumExpanding" vsizetype="MinimumExpanding">
+       <horstretch>0</horstretch>
+       <verstretch>0</verstretch>
+      </sizepolicy>
+     </property>
+     <property name="readOnly">
+      <bool>true</bool>
+     </property>
+     <property name="acceptRichText">
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" name="horizontalLayout">
+     <item>
+      <spacer name="horizontalSpacer">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QPushButton" name="pb_close">
+       <property name="text">
+        <string>Close</string>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>pb_close</sender>
+   <signal>released()</signal>
+   <receiver>PluginInfoDialog</receiver>
+   <slot>close()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>347</x>
+     <y>276</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>199</x>
+     <y>149</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
--- psi.orig/src/options/pluginsettsdialog.ui
+++ psi/src/options/pluginsettsdialog.ui
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>PluginSettingsDialog</class>
+ <widget class="QDialog" name="PluginSettingsDialog">
+  <property name="windowModality">
+   <enum>Qt::WindowModal</enum>
+  </property>
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>266</width>
+    <height>37</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>SettingsDialog</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox">
+     <property name="standardButtons">
+      <set>QDialogButtonBox::Apply|QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>PluginSettingsDialog</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>248</x>
+     <y>254</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>157</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>PluginSettingsDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
--- psi.orig/src/pluginhost.cpp
+++ psi/src/pluginhost.cpp
@@ -6,17 +6,52 @@
 #include "pluginhost.h"
 
 #include <QPluginLoader>
-
+#include <QWidget>
+#include <QSplitter>
+#include <QAction>
+#include <QByteArray>
+#include <QDomElement>
+#include <QKeySequence>
+#include <QObject>
+#include <QRegExp>
+#include <QString>
+#include <QStringList>
+#include <QTextEdit>
 //#include "xmpp_message.h"
 #include "psioptions.h"
+#include "psiaccount.h"
+#include "chatdlg.h"
+#include "globalshortcut/globalshortcutmanager.h"
+#include "grepshortcutkeydialog.h"
 #include "pluginmanager.h"
 #include "psiplugin.h"
+#include "applicationinfo.h"
 #include "stanzasender.h"
 #include "stanzafilter.h"
 #include "iqfilter.h"
 #include "iqnamespacefilter.h"
 #include "eventfilter.h"
 #include "optionaccessor.h"
+#include "shortcutaccessor.h"
+#include "iconfactoryaccessor.h"
+#include "activetabaccessor.h"
+#include "groupchatdlg.h"
+#include "tabmanager.h"
+#include "popupaccessor.h"
+#include "applicationinfoaccessor.h"
+#include "accountinfoaccessor.h"
+#include "toolbariconaccessor.h"
+#include "gctoolbariconaccessor.h"
+#include "widgets/iconaction.h"
+#include "menuaccessor.h"
+#include "contactstateaccessor.h"
+#include "plugininfoprovider.h"
+#include "psiaccountcontroller.h"
+#include "eventcreator.h"
+#include "contactinfoaccessor.h"
+#include "soundaccessor.h"
+#include "textutil.h"
+#include "chattabaccessor.h"
 
 /**
  * \brief Constructs a host/wrapper for a plugin.
@@ -32,12 +67,16 @@
  */
 PluginHost::PluginHost(PluginManager* manager, const QString& pluginFile)
 	: manager_(manager)
-	, file_(pluginFile)
 	, plugin_(0)
+	, file_(pluginFile)
+	, priority_(PsiPlugin::PriorityNormal)
 	, loader_(0)
+	, iconset_(0)
+	, valid_(false)
 	, connected_(false)
 	, enabled_(false)
-	, valid_(false)
+	, hasInfo_(false)
+	, infoString_(QString())
 {
 	load();	// reads plugin name, etc
 	unload();
@@ -107,6 +146,26 @@ const QString& PluginHost::version() con
 }
 
 /**
+ * \brief Returns plugin priority.
+ *
+ * Data is available also when plugin is not loaded.
+ */
+int PluginHost::priority() const
+{
+	return priority_;
+}
+
+/**
+ * \brief Returns plugin icon.
+ *
+ * Data is available also when plugin is not loaded.
+ */
+const QIcon& PluginHost::icon() const
+{
+	return icon_;
+}
+
+/**
  * \brief Returns plugin options widget.
  *
  * Always returns null if plugin is not currently loaded.
@@ -136,21 +195,29 @@ QWidget* PluginHost::optionsWidget() con
  */
 bool PluginHost::load()
 {
-  	qDebug() << "Loading Plugin " << file_;
+#ifndef PLUGINS_NO_DEBUG
+	qDebug() << "Loading Plugin " << file_;
+#endif
 	if (plugin_) {
-		qWarning() << QString("Plugin %1 was already loaded.").arg(file_);
+#ifndef PLUGINS_NO_DEBUG
+		qDebug() << QString("Plugin %1 was already loaded.").arg(file_);
+#endif
 	}
 	else {
 		if (!loader_) {
 			loader_ = new QPluginLoader(file_);
+			//loader_->setLoadHints(QLibrary::ResolveAllSymbolsHint);
 		}
 
 		QObject* plugin = loader_->instance();
 		if (!loader_->isLoaded()) {
 			delete loader_;
+			loader_ = 0;
 		}
 		else if (plugin) {
+#ifndef PLUGINS_NO_DEBUG
 			qDebug("Trying to load plugin");
+#endif
 			//Check it's the right sort of plugin
 			PsiPlugin* psiPlugin = qobject_cast<PsiPlugin*>(plugin);
 			if (psiPlugin) {
@@ -161,6 +228,15 @@ bool PluginHost::load()
 				name_ = psiPlugin->name();
 				shortName_ = psiPlugin->shortName();
 				version_ = psiPlugin->version();
+				priority_ = psiPlugin->priority();
+				icon_ = QIcon(psiPlugin->icon());
+				hasToolBarButton_ = qobject_cast<ToolbarIconAccessor*>(plugin_) ? true : false;
+				hasGCToolBarButton_ = qobject_cast<GCToolbarIconAccessor*>(plugin_) ? true : false;
+				PluginInfoProvider *pip = qobject_cast<PluginInfoProvider*>(plugin_);
+				if (pip) {
+					hasInfo_ = true;
+					infoString_ = pip->pluginInfo();
+				}
 			} else  {
 				qWarning("Attempted to load %s, but it is not a valid plugin.", qPrintable(file_));
 				if (loader_->isLoaded()) {
@@ -168,6 +244,8 @@ bool PluginHost::load()
 					loader_->unload();
 				}
 				delete loader_;
+				loader_ = 0;
+				valid_ = false;
 			}
 		}
 	}
@@ -187,20 +265,24 @@ bool PluginHost::load()
  */
 bool PluginHost::unload()
 {
-	return false; // TODO(mck): loading plugin again after unloading fails for some reason
-	              //            so I disabled unloading for now.
-
 	if (plugin_ && disable()) {
+#ifndef PLUGINS_NO_DEBUG
+		qDebug("Try to unload plugin %s", qPrintable(name_));
+#endif
 		if (!loader_) {
 			qWarning("Plugin %s's loader wasn't found when trying to unload", qPrintable(name_));
 			return false;
 		}
 		else if (loader_->unload()) {
-	  		//if we're done with the plugin completely and it's unloaded
-	  		// we can delete the loader;
+			//if we're done with the plugin completely and it's unloaded
+			// we can delete the loader;
 			delete plugin_;
 			delete loader_;
 			plugin_ = 0;
+			loader_ = 0;
+			delete iconset_;
+			iconset_ = 0;
+			connected_ = false;
 		}
 	}
 	return plugin_ == 0;
@@ -231,26 +313,135 @@ bool PluginHost::enable()
 {
 	if (!enabled_ && load()) {
 		if (!connected_) {
+#ifndef PLUGINS_NO_DEBUG
 			qDebug() << "connecting plugin " << name_;
+#endif
 
 			StanzaSender* s = qobject_cast<StanzaSender*>(plugin_);
 			if (s) {
+#ifndef PLUGINS_NO_DEBUG
 				qDebug("connecting stanza sender");
+#endif
 				s->setStanzaSendingHost(this);
 			}
 
 			IqFilter* f = qobject_cast<IqFilter*>(plugin_);
 			if (f) {
+#ifndef PLUGINS_NO_DEBUG
 				qDebug("connecting iq filter");
+#endif
 				f->setIqFilteringHost(this);
 			}
 
 			OptionAccessor* o = qobject_cast<OptionAccessor*>(plugin_);
 			if (o) {
+#ifndef PLUGINS_NO_DEBUG
 				qDebug("connecting option accessor");
+#endif
 				o->setOptionAccessingHost(this);
 			}
 
+			ShortcutAccessor* sa = qobject_cast<ShortcutAccessor*>(plugin_);
+			if (sa) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting shortcut accessor");
+#endif
+				sa->setShortcutAccessingHost(this);
+			}
+			PopupAccessor* pa = qobject_cast<PopupAccessor*>(plugin_);
+			if (pa) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting popup accessor");
+#endif
+				pa->setPopupAccessingHost(this);
+			}
+
+			IconFactoryAccessor* ia = qobject_cast<IconFactoryAccessor*>(plugin_);
+			if (ia) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting iconfactory accessor");
+#endif
+				ia->setIconFactoryAccessingHost(this);
+			}
+			ActiveTabAccessor* ta = qobject_cast<ActiveTabAccessor*>(plugin_);
+			if (ta) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting activetab accessor");
+#endif
+				ta->setActiveTabAccessingHost(this);
+			}
+			ApplicationInfoAccessor* aia = qobject_cast<ApplicationInfoAccessor*>(plugin_);
+			if (aia) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting applicationinfo accessor");
+#endif
+				aia->setApplicationInfoAccessingHost(this);
+			}
+			AccountInfoAccessor* ai = qobject_cast<AccountInfoAccessor*>(plugin_);
+			if (ai) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting accountinfo accessor");
+#endif
+				ai->setAccountInfoAccessingHost(this);
+			}
+			ToolbarIconAccessor *tia = qobject_cast<ToolbarIconAccessor*>(plugin_);
+			if (tia) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("load toolbaricon param");
+#endif
+				buttons_ = tia->getButtonParam();
+			}
+			GCToolbarIconAccessor *gtia = qobject_cast<GCToolbarIconAccessor*>(plugin_);
+			if (gtia) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("load gctoolbaricon param");
+#endif
+				gcbuttons_ = gtia->getGCButtonParam();
+			}
+			MenuAccessor *ma = qobject_cast<MenuAccessor*>(plugin_);
+			if (ma) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("load menu actions param");
+#endif
+				accMenu_ = ma->getAccountMenuParam();
+				contactMenu_ = ma->getContactMenuParam();
+			}
+			ContactStateAccessor *csa = qobject_cast<ContactStateAccessor*>(plugin_);
+			if (csa) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting contactstate accessor");
+#endif
+				csa->setContactStateAccessingHost(this);
+			}
+			PsiAccountController *pac = qobject_cast<PsiAccountController*>(plugin_);
+			if (pac) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connectint psiaccount controller");
+#endif
+				pac->setPsiAccountControllingHost(this);
+			}
+			EventCreator *ecr = qobject_cast<EventCreator*>(plugin_);
+			if (ecr) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connectint event creator");
+#endif
+				ecr->setEventCreatingHost(this);
+			}
+			ContactInfoAccessor *cia = qobject_cast<ContactInfoAccessor*>(plugin_);
+			if (cia) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting contactinfo accessor");
+#endif
+				cia->setContactInfoAccessingHost(this);
+			}
+			SoundAccessor *soa = qobject_cast<SoundAccessor*>(plugin_);
+			if(soa) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("connecting sound accessor");
+#endif
+				soa->setSoundAccessingHost(this);
+			}
+
 			connected_ = true;
 		}
 
@@ -271,7 +462,7 @@ bool PluginHost::enable()
 bool PluginHost::disable()
 {
 	if (enabled_) {
-		enabled_ = qobject_cast<PsiPlugin*>(plugin_)->disable();
+		enabled_ = !qobject_cast<PsiPlugin*>(plugin_)->disable();
 	}
 	return !enabled_;
 }
@@ -356,6 +547,16 @@ bool PluginHost::incomingXml(int account
 }
 
 
+bool PluginHost::outgoingXml(int account, QDomElement &e)
+{
+	bool handled = false;
+	StanzaFilter *ef = qobject_cast<StanzaFilter*>(plugin_);
+	if (ef && ef->outgoingStanza(account, e)) {
+		handled = true;
+	}
+	return handled;
+}
+
 //-- for EventFilter ------------------------------------------------
 
 /**
@@ -365,13 +566,12 @@ bool PluginHost::incomingXml(int account
  * this will call its processEvent() handler.
  * Handler may then modify the event and may cause the event to be
  * silently discarded.
- * TODO: modification doesn't work
  *
  * \param account Identifier of the PsiAccount responsible
  * \param e Event XML
  * \return Continue processing the event; true if the stanza should be silently discarded.
  */
-bool PluginHost::processEvent(int account, const QDomElement& e)
+bool PluginHost::processEvent(int account, QDomElement& e)
 {
 	bool handled = false;
 	EventFilter *ef = qobject_cast<EventFilter*>(plugin_);
@@ -406,6 +606,23 @@ bool PluginHost::processMessage(int acco
 	return handled;
 }
 
+bool PluginHost::processOutgoingMessage(int account, const QString& jidTo, QString& body, const QString& type, QString& subject)
+{
+	bool handled = false;
+	EventFilter *ef = qobject_cast<EventFilter*>(plugin_);
+	if (ef && ef->processOutgoingMessage(account, jidTo, body, type, subject)) {
+		handled = true;
+	}
+	return handled;
+}
+
+void PluginHost::logout(int account)
+{
+	EventFilter *ef = qobject_cast<EventFilter*>(plugin_);
+	if (ef) {
+		ef->logout(account);
+	}
+}
 
 //-- StanzaSender ---------------------------------------------------
 
@@ -456,7 +673,8 @@ void PluginHost::sendMessage(int account
 	//manager_->sendXml(account, m.toStanza(...).toString());
 
 	//TODO(mck): yeah, that's sick..
-	manager_->sendXml(account, QString("<message to='%1' type='%4'><subject>%3</subject><body>%2</body></message>").arg(to).arg(body).arg(subject).arg(type));
+	manager_->sendXml(account, QString("<message to='%1' type='%4'><subject>%3</subject><body>%2</body></message>")
+			  .arg(escape(to)).arg(escape(body)).arg(escape(subject)).arg(escape(type)));
 
 }
 
@@ -471,6 +689,10 @@ QString PluginHost::uniqueId(int account
 	return manager_->uniqueId(account);
 }
 
+QString PluginHost::escape(const QString &str)
+{
+	return TextUtil::escape(str);
+}
 
 //-- IqFilter -------------------------------------------------------
 
@@ -494,7 +716,9 @@ QString PluginHost::uniqueId(int account
 void PluginHost::addIqNamespaceFilter(const QString &ns, IqNamespaceFilter *filter)
 {
 	if (iqNsFilters_.values(ns).contains(filter)) {
-		qWarning("pluginmanager: blocked attempt to register the same filter again");
+#ifndef PLUGINS_NO_DEBUG
+		qDebug("pluginmanager: blocked attempt to register the same filter again");
+#endif
 	} else {
 		iqNsFilters_.insert(ns, filter);
 	}
@@ -519,9 +743,13 @@ void PluginHost::addIqNamespaceFilter(co
  */
 void PluginHost::addIqNamespaceFilter(const QRegExp &ns, IqNamespaceFilter *filter)
 {
+#ifndef PLUGINS_NO_DEBUG
 	qDebug("add nsx");
+#endif
 	if (iqNsxFilters_.values(ns).contains(filter)) {
-		qWarning("pluginmanager: blocked attempt to register the same filter again");
+#ifndef PLUGINS_NO_DEBUG
+		qDebug("pluginmanager: blocked attempt to register the same filter again");
+#endif
 	} else {
 		iqNsxFilters_.insert(ns, filter);
 	}
@@ -570,9 +798,8 @@ void PluginHost::setPluginOption( const
 	//
 	//if (!plugin)
 	//	return;
-	//QString pluginName = plugin->name();
-	//QString optionKey=QString("%1.%2.%3").arg(pluginOptionPrefix).arg(shortNames_[pluginName]).arg(option);
-	//PsiOptions::instance()->setOption(optionKey,value);
+	QString optionKey=QString("%1.%2.%3").arg(PluginManager::pluginOptionPrefix).arg(shortName()).arg(option);
+	PsiOptions::instance()->setOption(optionKey, value);
 }
 
 /**
@@ -585,9 +812,11 @@ void PluginHost::setPluginOption( const
  * \param  option Option to set
  * \param value Return value
  */
-QVariant PluginHost::getPluginOption(const QString& option)
+QVariant PluginHost::getPluginOption(const QString &option, const QVariant &defValue)
 {
-	return QVariant();	// TODO(mck)
+	QString pluginName = name();
+	QString optionKey=QString("%1.%2.%3").arg(PluginManager::pluginOptionPrefix).arg(shortName()).arg(option);
+	return PsiOptions::instance()->getOption(optionKey, defValue);
 }
 
 /**
@@ -616,6 +845,478 @@ QVariant PluginHost::getGlobalOption(con
 	return PsiOptions::instance()->getOption(option);
 }
 
+void PluginHost::optionChanged(const QString& option)
+{
+	OptionAccessor *oa = qobject_cast<OptionAccessor*>(plugin_);
+	if(oa)
+		oa->optionChanged(option);
+}
+
+void PluginHost::applyOptions()
+{
+	PsiPlugin* pp = qobject_cast<PsiPlugin*>(plugin_);
+	if(pp)
+		pp->applyOptions();
+}
+
+void PluginHost::restoreOptions()
+{
+	PsiPlugin* pp = qobject_cast<PsiPlugin*>(plugin_);
+	if(pp)
+		pp->restoreOptions();
+}
+
+
+/**
+ * Shortcut accessing host
+ */
+void PluginHost::setShortcuts()
+{
+	ShortcutAccessor *sa = qobject_cast<ShortcutAccessor*>(plugin_);
+	if (sa) {
+		sa->setShortcuts();
+	}
+}
+
+void PluginHost::connectShortcut(const QKeySequence& shortcut, QObject *receiver, const char* slot)
+{
+	GlobalShortcutManager::instance()->connect(shortcut, receiver, slot);
+}
+
+void PluginHost::disconnectShortcut(const QKeySequence& shortcut, QObject *receiver, const char* slot)
+{
+	GlobalShortcutManager::instance()->disconnect(shortcut, receiver, slot);
+}
+
+void PluginHost::requestNewShortcut(QObject *receiver, const char* slot)
+{
+	GrepShortcutKeyDialog* grep = new GrepShortcutKeyDialog();
+	connect(grep, SIGNAL(newShortcutKey(QKeySequence)), receiver, slot);
+	grep->show();
+}
+
+/**
+ * IconFactory accessing host
+ */
+QIcon PluginHost::getIcon(const QString& name)
+{
+	return IconsetFactory::icon(name).icon();
+}
+
+void PluginHost::addIcon(const QString& name, const QByteArray& ba)
+{
+	QPixmap pm;
+	pm.loadFromData(ba);
+	PsiIcon icon;
+	icon.setImpix(pm);
+	icon.setName(name);
+	if (!iconset_) {
+		iconset_ = new Iconset();
+	}
+	iconset_->setIcon(name,icon);
+	iconset_->addToFactory();
+}
+
+QTextEdit* PluginHost::getEditBox()
+{
+	QTextEdit* ed = 0;
+	TabbableWidget* tw = findActiveTab();
+	if(tw) {
+		QWidget* chatEditProxy = tw->findChild<QWidget*>("mle");
+		if(chatEditProxy) {
+			ed = (QTextEdit *)chatEditProxy->children().at(1);
+		}
+	}
+
+	return ed;
+}
+
+QString PluginHost::getJid()
+{
+	QString jid;
+	TabbableWidget* tw = findActiveTab();
+	if(tw) {
+		jid = tw->jid().full();
+	}
+
+	return jid;
+}
+
+QString PluginHost::getYourJid()
+{
+	QString jid;
+	TabbableWidget* tw = findActiveTab();
+	if(tw) {
+		jid = tw->account()->jid().full();
+	}
+
+	return jid;
+}
+
+/**
+ * ApplicationInfo accessing host
+ */
+Proxy PluginHost::getProxyFor(const QString &obj)
+{
+	Proxy prx;
+	ProxyItem it = ProxyManager::instance()->getItemForObject(obj);
+	prx.type = it.type;
+	prx.host = it.settings.host;
+	prx.port = it.settings.port;
+	prx.user = it.settings.user;
+	prx.pass = it.settings.pass;
+	return prx;
+}
+
+QString PluginHost::appName()
+{
+	return ApplicationInfo::name();
+}
+
+QString PluginHost::appVersion()
+{
+	return ApplicationInfo::version();
+}
+
+QString PluginHost::appCapsNode()
+{
+	return ApplicationInfo::capsNode();
+}
+
+QString PluginHost::appCapsVersion()
+{
+	return ApplicationInfo::capsVersion();
+}
+
+QString PluginHost::appOsName()
+{
+	return ApplicationInfo::osName();
+}
+
+QString PluginHost::appHomeDir(ApplicationInfoAccessingHost::HomedirType type)
+{
+	return ApplicationInfo::homeDir((ApplicationInfo::HomedirType)type);
+}
+
+QString PluginHost::appResourcesDir()
+{
+	return ApplicationInfo::resourcesDir();
+}
+
+QString PluginHost::appLibDir()
+{
+	return ApplicationInfo::libDir();
+}
+
+QString PluginHost::appProfilesDir(ApplicationInfoAccessingHost::HomedirType type)
+{
+	return ApplicationInfo::profilesDir((ApplicationInfo::HomedirType)type);
+}
+
+QString PluginHost::appHistoryDir()
+{
+	return ApplicationInfo::historyDir();
+}
+
+QString PluginHost::appCurrentProfileDir(ApplicationInfoAccessingHost::HomedirType type)
+{
+	return ApplicationInfo::currentProfileDir((ApplicationInfo::HomedirType)type);
+}
+
+QString PluginHost::appVCardDir()
+{
+	return ApplicationInfo::vCardDir();
+}
+
+//AccountInfoAcsessingHost
+QString PluginHost::getStatus(int account)
+{
+	return manager_->getStatus(account);
+}
+
+QString PluginHost::getStatusMessage(int account)
+{
+	return manager_->getStatusMessage(account);
+}
+
+QString PluginHost::proxyHost(int account)
+{
+	return manager_->proxyHost(account);
+}
+
+int PluginHost::proxyPort(int account)
+{
+	return manager_->proxyPort(account);
+}
+
+QString PluginHost::proxyUser(int account)
+{
+	return manager_->proxyUser(account);
+}
+
+QString PluginHost::proxyPassword(int account)
+{
+	return manager_->proxyPassword(account);
+}
+
+QStringList PluginHost::getRoster(int account)
+{
+	return manager_->getRoster(account);
+}
+
+QString PluginHost::getJid(int account)
+{
+	return manager_->getJid(account);
+}
+
+QString PluginHost::getId(int account)
+{
+	return manager_->getId(account);
+}
+
+QString PluginHost::getName(int account)
+{
+	return manager_->getName(account);
+}
+
+int PluginHost::findOnlineAccountForContact(const QString &jid) const
+{
+	return manager_->findOnlineAccountForContact(jid);
+}
+
+bool PluginHost::setActivity(int account, const QString& Jid, QDomElement xml)
+{
+	return manager_->setActivity(account, Jid, xml);
+}
+
+bool PluginHost::setMood(int account, const QString& Jid, QDomElement xml)
+{
+	return manager_->setMood(account, Jid, xml);
+}
+bool PluginHost::setTune(int account, const QString& Jid, QString tune)
+{
+	return manager_->setTune(account, Jid, tune);
+}
+
+void PluginHost::addToolBarButton(QObject* parent, QWidget* toolbar, int account, const QString& contact)
+{
+	ToolbarIconAccessor *ta = qobject_cast<ToolbarIconAccessor*>(plugin_);
+	if (ta) {
+		if(!buttons_.isEmpty()) {
+			for (int i = 0; i < buttons_.size(); ++i) {
+				QVariantHash param = buttons_.at(i);
+				QString th = param.value("tooltip").value<QString>();
+				IconAction *button = new IconAction(th, param.value("icon").value<QString>(), th, 0, parent);
+				connect(button, SIGNAL(triggered()),param.value("reciver").value<QObject *>(), param.value("slot").value<QString>().toLatin1());
+				toolbar->addAction(button);
+			}
+		}
+		QAction *act = ta->getAction(parent, account, contact);
+		if(act) {
+			act->setObjectName(shortName_);
+			toolbar->addAction(act);
+		}
+	}
+}
+
+bool PluginHost::hasToolBarButton()
+{
+	return hasToolBarButton_;
+}
+
+void PluginHost::addGCToolBarButton(QObject* parent, QWidget* toolbar, int account, const QString& contact)
+{
+	GCToolbarIconAccessor *ta = qobject_cast<GCToolbarIconAccessor*>(plugin_);
+	if (ta) {
+		if(!gcbuttons_.isEmpty()) {
+			for (int i = 0; i < gcbuttons_.size(); ++i) {
+				QVariantHash param = gcbuttons_.at(i);
+				QString th = param.value("tooltip").value<QString>();
+				IconAction *button = new IconAction(th, param.value("icon").value<QString>(), th, 0, parent);
+				connect(button, SIGNAL(triggered()),param.value("reciver").value<QObject *>(), param.value("slot").value<QString>().toLatin1());
+				toolbar->addAction(button);
+			}
+		}
+		QAction *act = ta->getGCAction(parent, account, contact);
+		if(act)
+			toolbar->addAction(act);
+	}
+}
+
+bool PluginHost::hasGCToolBarButton()
+{
+	return hasGCToolBarButton_;
+}
+
+void PluginHost::initPopup(const QString& text, const QString& title, const QString& icon, int type)
+{
+	manager_->initPopup(text, title, icon, type);
+}
+
+void PluginHost::initPopupForJid(int account, const QString &jid, const QString &text, const QString &title, const QString &icon, int type)
+{
+	manager_->initPopupForJid(account, jid, text, title, icon, type);
+}
+
+int PluginHost::registerOption(const QString& name, int initValue, const QString& path)
+{
+	return manager_->registerOption(name, initValue, path);
+}
+
+void PluginHost::unregisterOption(const QString &name)
+{
+	manager_->unregisterOption(name);
+}
+
+int PluginHost::popupDuration(const QString& name)
+{
+	return manager_->popupDuration(name);
+}
+
+void PluginHost::setPopupDuration(const QString& name, int value)
+{
+	manager_->setPopupDuration(name, value);
+}
+
+void PluginHost::addAccountMenu(QMenu *menu, int account)
+{
+	MenuAccessor *ma = qobject_cast<MenuAccessor*>(plugin_);
+	if(ma) {
+		if( !accMenu_.isEmpty()) {
+			for (int i = 0; i < accMenu_.size(); ++i) {
+				QVariantHash param = accMenu_.at(i);
+				IconAction *act = new IconAction(param.value("name").value<QString>(), menu, param.value("icon").value<QString>());
+				act->setProperty("account", QVariant(account));
+				connect(act, SIGNAL(triggered()), param.value("reciver").value<QObject *>(), param.value("slot").value<QString>().toLatin1());
+				menu->addAction(act);
+			}
+		}
+		QAction *act = ma->getAccountAction(menu, account);
+		if(act)
+			menu->addAction(act);
+	}
+}
+
+void PluginHost::addContactMenu(QMenu *menu, int account, const QString& jid)
+{
+	MenuAccessor *ma = qobject_cast<MenuAccessor*>(plugin_);
+	if(ma) {
+		if(!contactMenu_.isEmpty()) {
+			for (int i = 0; i < contactMenu_.size(); ++i) {
+				QVariantHash param = contactMenu_.at(i);
+				IconAction *act = new IconAction(param.value("name").value<QString>(), menu, param.value("icon").value<QString>());
+				act->setProperty("account", QVariant(account));
+				act->setProperty("jid", QVariant(jid));
+				connect(act, SIGNAL(triggered()), param.value("reciver").value<QObject *>(), param.value("slot").value<QString>().toLatin1());
+				menu->addAction(act);
+			}
+		}
+		QAction *act = ma->getContactAction(menu, account, jid);
+		if(act)
+			menu->addAction(act);
+	}
+}
+
+void PluginHost::setupChatTab(QWidget* tab, int account, const QString& contact)
+{
+	ChatTabAccessor *cta = qobject_cast<ChatTabAccessor*>(plugin_);
+	if(cta) {
+		cta->setupChatTab(tab, account, contact);
+	}
+}
+
+void PluginHost::setupGCTab(QWidget* tab, int account, const QString& contact)
+{
+	ChatTabAccessor *cta = qobject_cast<ChatTabAccessor*>(plugin_);
+	if(cta) {
+		cta->setupGCTab(tab, account, contact);
+	}
+}
+
+bool PluginHost::appendingChatMessage(int account, const QString &contact,
+				      QString &body, QDomElement &html, bool local)
+{
+	ChatTabAccessor *cta = qobject_cast<ChatTabAccessor*>(plugin_);
+	if(cta) {
+		return cta->appendingChatMessage(account, contact, body, html, local);
+	}
+	return false;
+}
+
+bool PluginHost::isSelf(int account, const QString& jid)
+{
+	return manager_->isSelf(account, jid);
+}
+
+bool PluginHost::isAgent(int account, const QString& jid)
+{
+	return manager_->isAgent(account, jid);
+}
+
+bool PluginHost::inList(int account, const QString& jid)
+{
+	return manager_->inList(account, jid);
+}
+
+bool PluginHost::isPrivate(int account, const QString& jid)
+{
+	return manager_->isPrivate(account, jid);
+}
+
+bool PluginHost::isConference(int account, const QString& jid)
+{
+	return manager_->isConference(account, jid);
+}
+
+QString PluginHost::name(int account, const QString& jid)
+{
+	return manager_->name(account, jid);
+}
+
+QString PluginHost::status(int account, const QString& jid)
+{
+	return manager_->status(account, jid);
+}
+
+QString PluginHost::statusMessage(int account, const QString& jid)
+{
+	return manager_->statusMessage(account, jid);
+}
+
+QStringList PluginHost::resources(int account, const QString& jid)
+{
+	return manager_->resources(account, jid);
+}
+
+bool PluginHost::hasInfoProvider()
+{
+	return hasInfo_;
+}
+
+QString PluginHost::pluginInfo()
+{
+	return infoString_;
+}
+
+void PluginHost::setStatus(int account, const QString& status, const QString& statusMessage)
+{
+	manager_->setStatus(account, status, statusMessage);
+}
+
+bool PluginHost::appendSysMsg(int account, const QString& jid, const QString& message)
+{
+	return manager_->appendSysMsg(account, jid, message);
+}
+
+void PluginHost::createNewEvent(int account, const QString& jid, const QString& descr, QObject *receiver, const char* slot)
+{
+	manager_->createNewEvent(account, jid, descr, receiver, slot);
+}
+
+void PluginHost::playSound(const QString &fileName)
+{
+	soundPlay(fileName);
+}
 
 //-- helpers --------------------------------------------------------
 
--- psi.orig/src/pluginhost.h
+++ psi/src/pluginhost.h
@@ -10,10 +10,28 @@
 #include <QVariant>
 #include <QRegExp>
 #include <QMultiMap>
+#include <QPointer>
+#include <QTextEdit>
 
+#include "applicationinfo.h"
+#include "userlist.h"
+#include "iconset.h"
 #include "stanzasendinghost.h"
 #include "iqfilteringhost.h"
 #include "optionaccessinghost.h"
+#include "shortcutaccessinghost.h"
+#include "iconfactoryaccessinghost.h"
+#include "activetabaccessinghost.h"
+#include "applicationinfoaccessinghost.h"
+#include "accountinfoaccessinghost.h"
+#include "tabdlg.h"
+#include "tabbablewidget.h"
+#include "popupaccessinghost.h"
+#include "contactstateaccessinghost.h"
+#include "psiaccountcontrollinghost.h"
+#include "eventcreatinghost.h"
+#include "contactinfoaccessinghost.h"
+#include "soundaccessinghost.h"
 
 class QWidget;
 class QPluginLoader;
@@ -21,10 +39,14 @@ class QPluginLoader;
 class PluginManager;
 class IqNamespaceFilter;
 
-class PluginHost: public QObject, public StanzaSendingHost, public IqFilteringHost, public OptionAccessingHost
+class PluginHost: public QObject, public StanzaSendingHost, public IqFilteringHost, public OptionAccessingHost, public ShortcutAccessingHost, public IconFactoryAccessingHost,
+	public ActiveTabAccessingHost, public ApplicationInfoAccessingHost, public AccountInfoAccessingHost, public PopupAccessingHost, public ContactStateAccessingHost
+	, public PsiAccountControllingHost, public EventCreatingHost, public ContactInfoAccessingHost, public SoundAccessingHost
 {
 	Q_OBJECT
-	Q_INTERFACES(StanzaSendingHost IqFilteringHost OptionAccessingHost);
+	Q_INTERFACES(StanzaSendingHost IqFilteringHost OptionAccessingHost ShortcutAccessingHost IconFactoryAccessingHost
+		ActiveTabAccessingHost ApplicationInfoAccessingHost AccountInfoAccessingHost PopupAccessingHost ContactStateAccessingHost
+		PsiAccountControllingHost EventCreatingHost ContactInfoAccessingHost SoundAccessingHost)
 
 public:
 	PluginHost(PluginManager* manager, const QString& pluginFile);
@@ -38,6 +60,8 @@ public:
 	const QString& name() const;
 	const QString& shortName() const;
 	const QString& version() const;
+	int priority() const;
+	const QIcon& icon() const;
 
 	// loading
 	bool load();
@@ -51,16 +75,20 @@ public:
 
 	// for StanzaFilter and IqNamespaceFilter
 	bool incomingXml(int account, const QDomElement& e);
+	bool outgoingXml(int account, QDomElement &e);
 
 	// for EventFilter
-	bool processEvent(int account, const QDomElement& e);
+	bool processEvent(int account, QDomElement& e);
 	bool processMessage(int account, const QString& jidFrom, const QString& body, const QString& subject);
+	bool processOutgoingMessage(int account, const QString& jidTo, QString& body, const QString& type, QString& subject);
+	void logout(int account);
 
 	// StanzaSendingHost
 	void sendStanza(int account, const QDomElement& xml);
 	void sendStanza(int account, const QString& xml);
 	void sendMessage(int account, const QString& to, const QString& body, const QString& subject, const QString& type);
 	QString uniqueId(int account);
+	QString escape(const QString &str);
 
 	// IqFilteringHost
 	void addIqNamespaceFilter(const QString& ns, IqNamespaceFilter* filter);
@@ -70,25 +98,137 @@ public:
 
 	// OptionAccessingHost
 	void setPluginOption(const QString& option, const QVariant& value);
-	QVariant getPluginOption(const QString& option);
+	QVariant getPluginOption(const QString &option, const QVariant &defValue = QVariant::Invalid);
 	void setGlobalOption(const QString& option, const QVariant& value);
 	QVariant getGlobalOption(const QString& option);
+	void optionChanged(const QString& option);
+
+	// ShortcutAccessingHost
+	void setShortcuts();
+	void connectShortcut(const QKeySequence& shortcut, QObject *receiver, const char* slot) ;
+	void disconnectShortcut(const QKeySequence& shortcut, QObject *receiver, const char* slot);
+	void requestNewShortcut(QObject *receiver, const char* slot);
+
+	// IconFacrotyAccessingHost
+	QIcon getIcon(const QString& name);
+	void addIcon(const QString& name, const QByteArray& icon);
+
+	//ActiveTabHost
+	QTextEdit* getEditBox();
+	QString getJid();
+	QString getYourJid();
+
+	//ApplicationInfoAccessingHost
+	Proxy getProxyFor(const QString &obj);
+	QString appName();
+	QString appVersion();
+	QString appCapsNode();
+	QString appCapsVersion();
+	QString appOsName();
+	QString appHomeDir(HomedirType type);
+	QString appResourcesDir();
+	QString appLibDir();
+	QString appProfilesDir(HomedirType type);
+	QString appHistoryDir();
+	QString appCurrentProfileDir(HomedirType type);
+	QString appVCardDir();
+
+	//AccountInfoAcsessingHost
+	QString getStatus(int account);
+	QString getStatusMessage(int account);
+	QString proxyHost(int account);
+	int proxyPort(int account);
+	QString proxyUser(int account);
+	QString proxyPassword(int account);
+	QString getJid(int account);
+	QString getId(int account);
+	QString getName(int account);
+	QStringList getRoster(int account);
+	int findOnlineAccountForContact(const QString &jid) const;
+
+	//ContactInfoAccessingHost
+	bool isSelf(int account, const QString& jid);
+	bool isAgent(int account, const QString& jid);
+	bool inList(int account, const QString& jid);
+	bool isPrivate(int account, const QString& jid);
+	bool isConference(int account, const QString& jid);
+	QString name(int account, const QString& jid);
+	QString status(int account, const QString& jid);
+	QString statusMessage(int account, const QString& jid);
+	QStringList resources(int account, const QString& jid);
+
+	//ContactStateAccessor
+	bool setActivity(int account, const QString& Jid, QDomElement xml);
+	bool setMood(int account, const QString& Jid, QDomElement xml);
+	bool setTune(int account, const QString& Jid, QString tune);
+
+	//PopupAccessingHost
+	void initPopup(const QString& text, const QString& title, const QString& icon, int type);
+	void initPopupForJid(int account, const QString& jid, const QString& text, const QString& title, const QString& icon, int type);
+	int registerOption(const QString& name, int initValue = 5, const QString& path = QString());
+	int popupDuration(const QString& name);
+	void setPopupDuration(const QString& name, int value);
+	void unregisterOption(const QString& name);
+
+	void addToolBarButton(QObject* parent, QWidget* toolbar, int account, const QString& contact);
+	bool hasToolBarButton();
+
+	void addGCToolBarButton(QObject* parent, QWidget* toolbar, int account, const QString& contact);
+	bool hasGCToolBarButton();
+
+	void addAccountMenu(QMenu *menu, int account);
+	void addContactMenu(QMenu *menu, int account, const QString& jid);
+
+	//ChatTabAccessor
+	void setupChatTab(QWidget* tab, int account, const QString& contact);
+
+	// GCTabAccessor
+	void setupGCTab(QWidget* tab, int account, const QString& contact);
+
+	bool appendingChatMessage(int account, const QString& contact,
+				  QString& body, QDomElement& html, bool local);
+
+	void applyOptions();
+	void restoreOptions();
+
+	QString pluginInfo();
+	bool hasInfoProvider();
+
+	void setStatus(int account, const QString& status, const QString& statusMessage);
+
+	bool appendSysMsg(int account, const QString& jid, const QString& message);
+
+	void createNewEvent(int account, const QString& jid, const QString& descr, QObject *receiver, const char* slot);
+
+	void playSound(const QString& fileName);
 
 private:
 	PluginManager* manager_;
-	QObject* plugin_;
+	QPointer<QObject> plugin_;
 	QString file_;
 	QString name_;
 	QString shortName_;
 	QString version_;
+	int priority_;
+	QIcon icon_;
 	QPluginLoader* loader_;
+	Iconset* iconset_;
+	bool hasToolBarButton_;
+	bool hasGCToolBarButton_;
 
 	bool valid_;
 	bool connected_;
 	bool enabled_;
+	bool hasInfo_;
+	QString infoString_;
 
 	QMultiMap<QString, IqNamespaceFilter*> iqNsFilters_;
 	QMultiMap<QRegExp, IqNamespaceFilter*> iqNsxFilters_;
+	QList< QVariantHash > buttons_;
+	QList< QVariantHash > gcbuttons_;
+
+	QList< QVariantHash > accMenu_;
+	QList< QVariantHash > contactMenu_;
 
 	bool loadPlugin(QObject* pluginObject);
 
--- psi.orig/src/pluginmanager.cpp
+++ psi/src/pluginmanager.cpp
@@ -8,7 +8,7 @@
 #include <QtCore>
 #include <QtCrypto>
 #include <QPluginLoader>
-#include <QDebug>
+#include <QLabel>
 
 #include "xmpp_client.h"
 #include "xmpp_task.h"
@@ -18,6 +18,8 @@
 #include "psioptions.h"
 
 #include "pluginhost.h"
+#include "psicon.h"
+#include "psicontact.h"
 #include "psiplugin.h"
 #include "psiaccount.h"
 #include "stanzafilter.h"
@@ -26,10 +28,14 @@
 #include "iqnamespacefilter.h"
 #include "eventfilter.h"
 #include "optionaccessor.h"
+#include "avatars.h"
+#include "psiiconset.h"
+#include "popupmanager.h"
+
+#include "chatdlg.h"
 
 
 //TODO(mck)
-// - make sure PluginManager works correctly when changing profiles
 // - use native separators when displaying file path
 
 
@@ -80,10 +86,9 @@ PluginManager* PluginManager::instance()
  * Default constructor. Locates all plugins, sets watchers on those directories to
  * locate new ones and loads those enabled in the config.
  */
-PluginManager::PluginManager() : QObject(NULL)
+PluginManager::PluginManager() : QObject(NULL), psi_(0)
 {
 	updatePluginsList();
-	loadEnabledPlugins();
 	foreach (QString path, pluginDirs()) {
 		QCA::DirWatch *dw = new QCA::DirWatch(path, this);
 		connect(dw, SIGNAL(changed()), SLOT(dirsChanged()));
@@ -92,38 +97,74 @@ PluginManager::PluginManager() : QObject
 	connect(PsiOptions::instance(), SIGNAL(optionChanged(const QString&)), this, SLOT(optionChanged(const QString&)));
 }
 
+void PluginManager::initNewSession(PsiCon *psi)
+{
+	psi_ = psi;
+	clients_.clear();
+	accountIds_.clear();
+	loadEnabledPlugins();
+}
+
 /**
  * Updates list of known plugins by reading all plugin directories
+ * and returns the list of new plugins
  */
-void PluginManager::updatePluginsList()
+QList<PluginHost*> PluginManager::updatePluginsList()
 {
-	foreach (QString d, pluginDirs()) {
+	QList<PluginHost*> newPlugins;
+
+	foreach (const QString& d, pluginDirs()) {
 		QDir dir(d);
-		foreach (QString file, dir.entryList()) {
+		foreach (QString file, dir.entryList(QDir::Files)) {
 			file = dir.absoluteFilePath(file);
-			qWarning("Found plugin: %s", qPrintable(file));
-			if (!pluginByFile_.contains(file)) {
-				PluginHost* host = new PluginHost(this, file);
-				if (host->isValid()) {
-					hosts_[host->name()] = host;
-					pluginByFile_[file] = host;
+			if (QLibrary::isLibrary(file)) {
+#ifndef PLUGINS_NO_DEBUG
+				qDebug("Found plugin: %s", qPrintable(file));
+#endif
+				if (!pluginByFile_.contains(file)) {
+					PluginHost* host = new PluginHost(this, file);
+					if (host->isValid() && !hosts_.contains(host->name())) {
+						hosts_[host->name()] = host;
+						pluginByFile_[file] = host;
+						newPlugins.append(host);
+						if (host->priority() == PsiPlugin::PriorityHighest || !pluginsByPriority_.size()) {
+							pluginsByPriority_.push_front(host);
+						} else {
+							// find position for insertion
+							int i = pluginsByPriority_.size();
+							while (i && host->priority() > pluginsByPriority_[i - 1]->priority()) {
+								i--;
+							}
+							pluginsByPriority_.insert(i, host);
+						}
+					}
+				} else {
+#ifndef PLUGINS_NO_DEBUG
+					qDebug("Which we already knew about");
+#endif
 				}
-			} else {
-				qWarning("Which we already knew about");
 			}
 		}
 	}
+
+	return newPlugins;
 }
 
 /**
  * This slot is executed when the contents of a plugin directory changes
  * It causes the available plugin list to be refreshed.
- *
- * TODO: it should also load the plugins if they're on the autoload list
  */
 void PluginManager::dirsChanged()
 {
-	updatePluginsList();
+	foreach(PluginHost* plugin, updatePluginsList()) {
+		loadPluginIfEnabled(plugin);
+	}
+}
+
+void PluginManager::accountDestroyed()
+{
+	PsiAccount* pa = static_cast<PsiAccount*>(sender());
+	accountIds_.removeAccount(pa);
 }
 
 /**
@@ -132,14 +173,27 @@ void PluginManager::dirsChanged()
  */
 void PluginManager::loadEnabledPlugins()
 {
+#ifndef PLUGINS_NO_DEBUG
 	qDebug("Loading enabled plugins");
-	foreach (PluginHost* plugin, hosts_.values()) {
-		QString option = QString("%1.%2").arg(loadOptionPrefix).arg(plugin->shortName());
-		if (PsiOptions::instance()->getOption(option).toBool()) {
-			qWarning("Plugin %s is enabled in config: loading", qPrintable(plugin->shortName()));
-			plugin->load();
-			plugin->enable();
-		}
+#endif
+	foreach (PluginHost* plugin, pluginsByPriority_) {
+		loadPluginIfEnabled(plugin);
+	}
+}
+
+void PluginManager::loadPluginIfEnabled(PluginHost *plugin)
+{
+	const QString option = QString("%1.%2").arg(loadOptionPrefix).arg(plugin->shortName());
+	QVariant load = PsiOptions::instance()->getOption(option);
+	if(!load.isValid()) {
+		PsiOptions::instance()->setOption(option, false);
+		load = QVariant(false);
+	}
+	if (load.toBool()) {
+#ifndef PLUGINS_NO_DEBUG
+		qDebug("Plugin %s is enabled in config: loading", qPrintable(plugin->shortName()));
+#endif
+		plugin->enable();
 	}
 }
 
@@ -150,9 +204,21 @@ void PluginManager::loadEnabledPlugins()
  */
 void PluginManager::optionChanged(const QString& option)
 {
-	//QString("%1.%2").arg(loadOptionPrefix).arg(shortNames_[plugin]);
-
-	//TODO(mck): implement this... for now, enabling/disabling requires psi restart
+	bool pluginOpt = option.startsWith(loadOptionPrefix);
+	const QString shortName = option.split(".").last();
+	foreach (PluginHost* plugin, pluginByFile_.values()) {
+		plugin->optionChanged(option);
+		if(pluginOpt && plugin->shortName() == shortName) {
+			if(PsiOptions::instance()->getOption(option).toBool()) {
+				plugin->enable();
+			}
+			else {
+				if(optionsWidget_)
+					delete optionsWidget_;
+				plugin->unload();
+			}
+		}
+	}
 }
 
 /**
@@ -160,7 +226,9 @@ void PluginManager::optionChanged(const
  */
 void PluginManager::loadAllPlugins()
 {
+#ifndef PLUGINS_NO_DEBUG
 	qDebug("Loading all plugins");
+#endif
   	//Any static (compiled in) plugins we happen to have
 	/*foreach( QObject* plugin, QPluginLoader::staticInstances() ) {
 		loadPlugin( plugin );
@@ -180,25 +248,34 @@ void PluginManager::loadAllPlugins()
  */
 bool PluginManager::unloadAllPlugins()
 {
+#ifndef PLUGINS_NO_DEBUG
 	qDebug("Unloading all plugins");
+#endif
 	bool ok = true;
 	foreach (PluginHost* plugin, hosts_.values()) {
-		if (!plugin->disable()) {
-			ok = false;
-		} else if (plugin->unload()) {
+		if (!plugin->unload()) {
 			ok = false;
 		}
 	}
 	return ok;
 }
 
+bool PluginManager::isEnabled(const QString& plugin) const
+{
+	bool enabled = false;
+	if (hosts_.contains(plugin)) {
+		enabled = hosts_[plugin]->isEnabled();
+	}
+	return enabled;
+}
+
 /**
  * Find the file which provides the named plugin. If the named plugin is not
  * known, an empty string is provided.
  * \param plugin Name of the plugin.
  * \return Path to the plugin file.
  */
-QString PluginManager::pathToPlugin(const QString& plugin)
+QString PluginManager::pathToPlugin(const QString& plugin) const
 {
 	QString path;
 	if (hosts_.contains(plugin)) {
@@ -213,7 +290,7 @@ QString PluginManager::pathToPlugin(cons
  * \param plugin Name of the plugin.
  * \return Path to the plugin file.
  */
-QString PluginManager::shortName(const QString& plugin)
+QString PluginManager::shortName(const QString& plugin) const
 {
 	QString name;
 	if (hosts_.contains(plugin)) {
@@ -222,10 +299,31 @@ QString PluginManager::shortName(const Q
 	return name;
 }
 
+QString PluginManager::nameByShortName(const QString& shortName) const
+{
+	QString name;
+	foreach (PluginHost* host, pluginsByPriority_) {
+		if (host->shortName() == shortName) {
+			name = host->name();
+			break;
+		}
+	}
+	return name;
+}
+
+QString PluginManager::version(const QString& plugin) const
+{
+	QString name;
+	if (hosts_.contains(plugin)) {
+		name = hosts_[plugin]->version();
+	}
+	return name;
+}
+
 /**
  * Returns a list of available plugin names found in all plugin directories.
  */
-QStringList PluginManager::availablePlugins()
+QStringList PluginManager::availablePlugins() const
 {
 	return hosts_.keys();
 }
@@ -238,13 +336,33 @@ QStringList PluginManager::availablePlug
  */
 QWidget* PluginManager::optionsWidget(const QString& plugin)
 {
-	QWidget* widget = 0;
+	if(optionsWidget_) {
+		delete optionsWidget_;
+	}
+
 	if (hosts_.contains(plugin)) {
-		widget = hosts_[plugin]->optionsWidget();
-	} else {
+		optionsWidget_ = hosts_[plugin]->optionsWidget();
+	}
+
+	if(!optionsWidget_) {
+#ifndef PLUGINS_NO_DEBUG
 		qWarning("Attempting to get options for %s which doesn't exist", qPrintable(plugin));
+#endif
+		optionsWidget_ = new QLabel(tr("This plugin has no user configurable options"));
+	}
+	return optionsWidget_;
+}
+
+/**
+ * \brief Give each plugin the opportunity to set shortcuts
+ *
+ * Each plugin can set its own global shortcuts
+ */
+void PluginManager::setShortcuts()
+{
+	foreach (PluginHost* host, pluginByFile_.values()) {
+		host->setShortcuts();
 	}
-	return widget;
 }
 
 /**
@@ -257,11 +375,11 @@ QWidget* PluginManager::optionsWidget(co
  * \param event Incoming event
  * \return Continue processing the event; true if the event should be silently discarded.
  */
-bool PluginManager::processMessage(const PsiAccount* account, const QString& jidFrom, const QString& body, const QString& subject)
+bool PluginManager::processMessage(PsiAccount* account, const QString& jidFrom, const QString& body, const QString& subject)
 {
 	bool handled = false;
-	foreach (PluginHost* host, hosts_.values()) {
-		if (host->processMessage(accountIds_[account], jidFrom, body, subject)) {
+	foreach (PluginHost* host, pluginsByPriority_) {
+		if (host->processMessage(accountIds_.id(account), jidFrom, body, subject)) {
 			handled = true;
 			break;
 		}
@@ -279,11 +397,28 @@ bool PluginManager::processMessage(const
  * \param event Incoming event
  * \return Continue processing the event; true if the event should be silently discarded.
  */
-bool PluginManager::processEvent(const PsiAccount* account, QDomElement& event)
+bool PluginManager::processEvent(PsiAccount* account, QDomElement& event)
+{
+	bool handled = false;
+	const int acc_id = accountIds_.id(account);
+	foreach (PluginHost* host, pluginsByPriority_) {
+		if (host->processEvent(acc_id, event)) {
+			handled = true;
+			break;
+		}
+	}
+	return handled;
+}
+
+/**
+ * process an outgoing message
+ */
+bool PluginManager::processOutgoingMessage(PsiAccount* account, const QString& jidTo, QString& body, const QString& type, QString& subject)
 {
 	bool handled = false;
-	foreach (PluginHost* host, hosts_.values()) {
-		if (host->processEvent(accountIds_[account], event)) {
+	const int acc_id = accountIds_.id(account);
+	foreach (PluginHost* host, pluginByFile_.values()) {
+		if (host->processOutgoingMessage(acc_id, jidTo, body, type, subject)) {
 			handled = true;
 			break;
 		}
@@ -291,6 +426,27 @@ bool PluginManager::processEvent(const P
 	return handled;
 }
 
+void PluginManager::processOutgoingStanza(PsiAccount* account, QDomElement &stanza)
+{
+	const int acc_id = accountIds_.id(account);
+	foreach (PluginHost* host, pluginByFile_.values()) {
+		if (host->outgoingXml(acc_id, stanza)) {
+			break;
+		}
+	}
+}
+
+/**
+ * Notify to plugins that an account will go offline now.
+ */
+void PluginManager::logout(PsiAccount* account)
+{
+	const int acc_id = accountIds_.id(account);
+	foreach (PluginHost* host, pluginByFile_.values()) {
+		host->logout(acc_id);
+	}
+}
+
 /**
  * \brief Give each plugin the opportunity to process the incoming xml
  *
@@ -306,7 +462,7 @@ bool PluginManager::processEvent(const P
 bool PluginManager::incomingXml(int account, const QDomElement &xml)
 {
 	bool handled = false;
-	foreach (PluginHost* host, hosts_.values()) {
+	foreach (PluginHost* host, pluginsByPriority_) {
 		if (host->incomingXml(account, xml)) {
 			handled = true;
 			break;
@@ -342,7 +498,7 @@ void PluginManager::sendXml(int account,
  * \param account Identifier of the PsiAccount responsible
  * \return Unique ID to be used for when sending a stanza
  */
-QString PluginManager::uniqueId(int account)
+QString PluginManager::uniqueId(int account) const
 {
 	QString id;
 	if (account < clients_.size()) {
@@ -351,15 +507,301 @@ QString PluginManager::uniqueId(int acco
 	return id;
 }
 
+QString PluginManager::getStatus(int account) const
+{
+	Status S;
+	PsiAccount *pa = accountIds_.account(account);
+	if(pa)
+		S = pa->status();
+	return S.typeString();
+}
+
+QString PluginManager::getStatusMessage(int account) const
+{
+	Status S;
+	PsiAccount *pa = accountIds_.account(account);
+	if(pa)
+			S = pa->status();
+	return S.status();
+}
+
+static inline const QString getProxyId(PsiAccount* pa)
+{
+	return pa->accountOptions().proxyID;
+}
+
+QString PluginManager::proxyHost(int account) const
+{
+	QString host;
+	PsiAccount *pa = accountIds_.account(account);
+	if(pa)
+		host = ProxyManager::instance()->getItem(getProxyId(pa)).settings.host;
+	return host;
+}
+
+int PluginManager::proxyPort(int account) const
+{
+	int port = -1;
+	PsiAccount *pa = accountIds_.account(account);
+	if(pa)
+		port = ProxyManager::instance()->getItem(getProxyId(pa)).settings.port;
+	return port;
+}
+
+QString PluginManager::proxyUser(int account) const
+{
+	QString user;
+	PsiAccount *pa = accountIds_.account(account);
+	if(pa)
+		user = ProxyManager::instance()->getItem(getProxyId(pa)).settings.user;
+	return user;
+}
+
+QString PluginManager::proxyPassword(int account) const
+{
+	QString pass;
+	PsiAccount *pa = accountIds_.account(account);
+	if(pa)
+		pass = ProxyManager::instance()->getItem(getProxyId(pa)).settings.pass;
+	return pass;
+}
+
+QStringList PluginManager::getRoster(int account) const
+{
+	QStringList list;
+	list << "-1";
+	if (accountIds_.isValidRange(account)) {
+		list.clear();
+		PsiAccount *pa = accountIds_.account(account);
+		if(pa) {
+			QList<PsiContact*> roster = pa->contactList();
+			for(int i = 0; i < roster.size(); i++) {
+				list.push_back(roster.at(i)->jid().bare());
+			}
+		}
+	}
+	return list;
+}
+
+QString PluginManager::getJid(int account) const
+{
+	QString Jid = "-1";
+	if (accountIds_.isValidRange(account)) {
+		Jid.clear();
+		PsiAccount *pa = accountIds_.account(account);
+		if(pa)
+			Jid = pa->jid().bare();
+	}
+	return Jid;
+}
+
+QString PluginManager::getId(int account) const
+{
+	QString id = "-1";
+	if (accountIds_.isValidRange(account)) {
+		id.clear();
+		PsiAccount *pa = accountIds_.account(account);
+		if(pa)
+			id = pa->id();
+	}
+	return id;
+}
+
+QString PluginManager::getName(int account) const
+{
+	QString nm;
+	PsiAccount *pa = accountIds_.account(account);
+	if(pa)
+		nm = pa->name();
+	return nm;
+}
+
+int PluginManager::findOnlineAccountForContact(const QString &jid) const
+{
+	Jid j(jid);
+	for (int acc_id = 0; accountIds_.isValidRange(acc_id); ++acc_id) {
+		PsiAccount *pa = accountIds_.account(acc_id);
+		if (pa && pa->isAvailable() && pa->findContact(j))
+			return acc_id;
+	}
+	return -1;
+}
+
+bool PluginManager::setActivity(int account, const QString& jid, QDomElement xml)
+{
+	PsiAccount *pa = accountIds_.account(account);
+	if(!pa)
+		return false;
+
+	XMPP::Jid userJid(jid);
+	UserListItem *item =  pa->userList()->find(userJid);
+
+	if(!item)
+		return false;
+
+	Activity act = Activity();
+	if(!xml.isNull())
+		act = Activity(xml);
+	item->setActivity(act);
+	return true;
+}
+
+bool PluginManager::setMood(int account, const QString& jid, QDomElement xml)
+{
+	PsiAccount *pa = accountIds_.account(account);
+	if(!pa)
+		return false;
+
+	XMPP::Jid userJid(jid);
+	UserListItem *item =  pa->userList()->find(userJid);
+
+	if(!item)
+		return false;
+
+	Mood mood = Mood();
+	if(!xml.isNull())
+		mood = Mood(xml);
+	item->setMood(mood);
+	return true;
+}
+
+bool PluginManager::setTune(int account, const QString& jid, const QString& tune)
+{
+	PsiAccount *pa = accountIds_.account(account);
+	if(!pa)
+		return false;
+
+	XMPP::Jid userJid(jid);
+	UserListItem *item =  pa->userList()->find(userJid);
+
+	if(!item)
+		return false;
+
+	item->setTune(tune);
+	return true;
+}
+
+void PluginManager::initPopup(const QString& text, const QString& title, const QString& icon, int type)
+{
+	const PsiIcon* ico = IconsetFactory::iconPtr(icon);
+	psi_->popupManager()->doPopup(0, Jid(), ico, title, 0, 0, text, true, (PopupManager::PopupType)type);
+}
+
+void PluginManager::initPopupForJid(int account, const QString &jid, const QString &text, const QString &title, const QString &icon, int type)
+{
+	XMPP::Jid j(jid);
+	const PsiIcon* ico = IconsetFactory::iconPtr(icon);
+	PsiAccount * pa = accountIds_.account(account);
+	if(pa) {
+		UserListItem *i = pa->findFirstRelevant(j);
+		PsiIcon *statusIco = PsiIconset::instance()->statusPtr(i);
+		const QPixmap pix = pa->avatarFactory()->getAvatar(j);
+		psi_->popupManager()->doPopup(pa, j, ico, title, &pix, statusIco, text, true, (PopupManager::PopupType)type);
+		return;
+	}
+	psi_->popupManager()->doPopup(0, Jid(), ico, title, 0, 0, text, true, (PopupManager::PopupType)type);
+}
+
+int PluginManager::registerOption(const QString& name, int initValue, const QString& path)
+{
+	return psi_->popupManager()->registerOption(name, initValue, path);
+}
+
+void PluginManager::unregisterOption(const QString &name)
+{
+	psi_->popupManager()->unregisterOption(name);
+}
+
+int PluginManager::popupDuration(const QString& name) const
+{
+	return psi_->popupManager()->value(name);
+}
+
+void PluginManager::setPopupDuration(const QString& name, int value)
+{
+	psi_->popupManager()->setValue(name, value);
+}
+
+void PluginManager::addAccountMenu(QMenu *menu, PsiAccount* account)
+{
+	int i = accountIds_.id(account);
+	foreach (PluginHost* host, pluginsByPriority_) {
+		host->addAccountMenu(menu, i);
+	}
+}
+
+void PluginManager::addContactMenu(QMenu* menu, PsiAccount *account, QString jid)
+{
+	int i = accountIds_.id(account);
+	foreach (PluginHost* host, pluginsByPriority_) {
+		host->addContactMenu(menu, i, jid);
+	}
+}
+
+void PluginManager::setupChatTab(QWidget *tab, PsiAccount *account, const QString& contact)
+{
+	int i = accountIds_.id(account);
+	foreach (PluginHost* host, pluginsByPriority_) {
+		host->setupChatTab(tab, i, contact);
+	}
+}
+
+void PluginManager::setupGCTab(QWidget *tab, PsiAccount *account, const QString& contact)
+{
+	int i = accountIds_.id(account);
+	foreach (PluginHost* host, pluginsByPriority_) {
+		host->setupGCTab(tab, i, contact);
+	}
+}
+
+bool PluginManager::appendingChatMessage(PsiAccount *account, const QString &contact,
+					 QString &body, QDomElement &html, bool local)
+{
+	bool handled = false;
+	foreach (PluginHost* host, pluginsByPriority_) {
+		if (host->appendingChatMessage(accountIds_.id(account), contact, body, html, local)) {
+			handled = true;
+			break;
+		}
+	}
+	return handled;
+}
+
+bool PluginManager::hasInfoProvider(const QString& plugin) const
+{
+	if (hosts_.contains(plugin))
+		return hosts_[plugin]->hasInfoProvider();
+
+	return false;
+}
+
+QString PluginManager::pluginInfo(const QString& plugin) const
+{
+	QString info;
+	if (hosts_.contains(plugin))
+		info = hosts_[plugin]->pluginInfo();
+	return info;
+}
+
+QIcon PluginManager::icon(const QString& plugin) const
+{
+	QIcon icon;
+	if (hosts_.contains(plugin)) {
+		icon = hosts_[plugin]->icon();
+	}
+
+	return icon;
+}
+
 /**
  * Tells the plugin manager about an XMPP::Client and the owning PsiAccount
  */
-void PluginManager::addAccount(const PsiAccount* account, XMPP::Client* client)
+void PluginManager::addAccount(PsiAccount* account, XMPP::Client* client)
 {
 	clients_.append(client);
-	const int id = clients_.size() - 1;
-	accountIds_[account] = id;
+	const int id = accountIds_.appendAccount(account);
 	new StreamWatcher(client->rootTask(), this, id);
+	connect(account, SIGNAL(accountDestroyed()), this, SLOT(accountDestroyed()));
 }
 
 /**
@@ -372,6 +814,225 @@ bool PluginManager::verifyStanza(const Q
 	return true;
 }
 
+void PluginManager::applyOptions(const QString& plugin)
+{
+	if (hosts_.contains(plugin)) {
+		hosts_[plugin]->applyOptions();
+	}
+}
+
+void PluginManager::restoreOptions(const QString& plugin)
+{
+	if (hosts_.contains(plugin)) {
+		hosts_[plugin]->restoreOptions();
+	}
+}
+
+void PluginManager::addToolBarButton(QObject* parent, QWidget* toolbar, PsiAccount* account, const QString& contact, const QString& plugin)
+{
+	const int acc_id = accountIds_.id(account);
+	foreach (PluginHost* host, pluginsByPriority_) {
+		if (plugin.isEmpty() || (host->name() == plugin)) {
+			host->addToolBarButton(parent,toolbar, acc_id, contact);
+		}
+	}
+}
+
+bool PluginManager::hasToolBarButton(const QString& plugin) const
+{
+	return hosts_[plugin]->hasToolBarButton();
+}
+
+void PluginManager::addGCToolBarButton(QObject* parent, QWidget* toolbar, PsiAccount* account, const QString& contact, const QString& plugin)
+{
+	const int acc_id = accountIds_.id(account);
+	foreach (PluginHost* host, pluginsByPriority_) {
+		if (plugin.isEmpty() || (host->name() == plugin)) {
+			host->addGCToolBarButton(parent,toolbar, acc_id, contact);
+		}
+	}
+}
+
+bool PluginManager::hasGCToolBarButton(const QString& plugin) const
+{
+	return hosts_[plugin]->hasGCToolBarButton();
+}
+
+void PluginManager::setStatus(int account, const QString& status, const QString& statusMessage)
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		XMPP::Status s(status, statusMessage);
+		acc->setStatus(s, false, true);
+	}
+}
+
+bool PluginManager::appendSysMsg(int account, const QString& jid, const QString& message)
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		XMPP::Jid j (jid);
+		ChatDlg *chatDlg = acc->findChatDialogEx(j);
+		if(!chatDlg) {
+			chatDlg = acc->findChatDialog(j, false);
+		}
+		if(chatDlg) {
+			chatDlg->appendSysMsg(message);
+			return true;
+		}
+	}
+	return false;
+}
+
+
+void PluginManager::createNewEvent(int account, const QString &jid, const QString &descr, QObject *receiver, const char *slot)
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		acc->createNewPluginEvent(jid, descr, receiver, slot);
+	}
+}
+
+bool PluginManager::isSelf(int account, const QString& jid) const
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		PsiContact *pc = acc->findContact(XMPP::Jid(jid));
+		if(pc)
+			return pc->isSelf();
+	}
+	return false;
+}
+
+bool PluginManager::isAgent(int account, const QString& jid) const
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		PsiContact *pc = acc->findContact(XMPP::Jid(jid));
+		if(pc)
+			return pc->isAgent();
+	}
+	return false;
+}
+
+bool PluginManager::inList(int account, const QString& jid) const
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		PsiContact *pc = acc->findContact(XMPP::Jid(jid));
+		if(pc)
+			return pc->inList();
+	}
+	return false;
+}
+
+bool PluginManager::isPrivate(int account, const QString& jid) const
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		PsiContact *pc = acc->findContact(XMPP::Jid(jid));
+		if(pc)
+			return pc->isPrivate();
+	}
+	return false;
+}
+
+bool PluginManager::isConference(int account, const QString& jid) const
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		PsiContact *pc = acc->findContact(XMPP::Jid(jid));
+		if(pc)
+			return pc->isConference();
+	}
+	return false;
+}
+
+QString PluginManager::name(int account, const QString& jid) const
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		PsiContact *pc = acc->findContact(XMPP::Jid(jid));
+		if(pc)
+			return pc->name();
+	}
+	return QString();
+}
+
+QString PluginManager::status(int account, const QString& jid) const
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		PsiContact *pc = acc->findContact(XMPP::Jid(jid));
+		if(pc)
+			return pc->status().typeString();
+	}
+	return QString();
+}
+
+QString PluginManager::statusMessage(int account, const QString& jid) const
+{
+	PsiAccount *acc = accountIds_.account(account);
+	if(acc) {
+		PsiContact *pc = acc->findContact(XMPP::Jid(jid));
+		if(pc)
+			return pc->status().status();
+	}
+	return QString();
+}
+
+QStringList PluginManager::resources(int account, const QString& jid) const
+{
+	QStringList l;
+	PsiAccount *pa = accountIds_.account(account);
+	if(pa) {
+		UserListItem *u = pa->findFirstRelevant(XMPP::Jid(jid));
+		if(u) {
+			QMutableListIterator<UserResource> i(u->userResourceList());
+			while (i.hasNext()) {
+				l.push_back(i.next().name());
+			}
+		}
+	}
+	return l;
+}
+
+int AccountIds::appendAccount(PsiAccount *acc)
+{
+	int id = -1;
+	if (acc) {
+		id = id_keys.size();
+		id_keys[id] = acc;
+		acc_keys[acc] = id;
+	}
+	return id;
+}
+
+void AccountIds::removeAccount(PsiAccount *acc)
+{
+	int id = acc_keys.value(acc, -1);
+	if (id != -1) {
+		acc_keys.remove(acc);
+		id_keys[id] = 0;
+	}
+}
+
+void AccountIds::clear()
+{
+	acc_keys.clear();
+	id_keys.clear();
+}
+
+PsiAccount *AccountIds::account(int id) const
+{
+	return id_keys.value(id, 0);
+}
+
+int AccountIds::id(PsiAccount *acc) const
+{
+	return acc_keys.value(acc, -1);
+}
+
 PluginManager* PluginManager::instance_ = NULL;
 const QString PluginManager::loadOptionPrefix = "plugins.auto-load";
 const QString PluginManager::pluginOptionPrefix = "plugins.options";
--- psi.orig/src/pluginmanager.h
+++ psi/src/pluginmanager.h
@@ -11,12 +11,16 @@
 #include <QMap>
 #include <QHash>
 #include <QDomElement>
+#include <QMenu>
 
 class QPluginLoader;
 
 class PsiAccount;
 class PsiPlugin;
 class PluginHost;
+class PsiCon;
+
+#define PLUGINS_NO_DEBUG
 
 namespace XMPP {
 	class Client;
@@ -26,6 +30,20 @@ namespace QCA {
 	class DirWatch;
 }
 
+class AccountIds
+{
+public:
+	int appendAccount(PsiAccount *acc);
+	void removeAccount(PsiAccount *acc);
+	void clear();
+	bool isValidRange(int id) const { return id_keys.contains(id); }
+	PsiAccount *account(int id) const;
+	int id(PsiAccount *acc) const;
+
+private:
+	QHash<PsiAccount *, int> acc_keys;
+	QHash<int, PsiAccount *> id_keys;
+};
 
 class PluginManager : public QObject
 {
@@ -33,29 +51,58 @@ class PluginManager : public QObject
 
 public:
 	static PluginManager* instance();
+	void initNewSession(PsiCon *psi);
 
-	QStringList availablePlugins();
+	QStringList availablePlugins() const;
 
-	void addAccount(const PsiAccount* account, XMPP::Client* client);
+	void addAccount(PsiAccount* account, XMPP::Client* client);
 
 	void loadEnabledPlugins();
 	bool unloadAllPlugins();
 
-	QString pathToPlugin(const QString& plugin);
-	QString shortName(const QString& plugin);
+	bool isEnabled(const QString& plugin) const;
+	QString pathToPlugin(const QString& plugin) const;
+	QString shortName(const QString& plugin) const;
+	QString nameByShortName(const QString& shortName) const;
+	QString version(const QString& plugin) const;
 	QWidget* optionsWidget(const QString& plugin);
 
-	bool processEvent(const PsiAccount* account, QDomElement& eventXml);
-	bool processMessage(const PsiAccount* account, const QString& jidFrom, const QString& body, const QString& subject);
+	void setShortcuts();
+
+	bool processEvent(PsiAccount* account, QDomElement& eventXml);
+	bool processMessage(PsiAccount* account, const QString& jidFrom, const QString& body, const QString& subject);
+	bool processOutgoingMessage(PsiAccount* account, const QString& jidTo, QString& body, const QString& type, QString& subject);
+	void processOutgoingStanza(PsiAccount* account, QDomElement &stanza);
+	void logout(PsiAccount* account);
+
+	void applyOptions(const QString& plugin);
+	void restoreOptions(const QString& plugin);
+	void addToolBarButton(QObject* parent, QWidget* toolbar, PsiAccount* account, const QString& contact, const QString& plugin = "");
+	bool hasToolBarButton(const QString& plugin) const;
+	void addGCToolBarButton(QObject* parent, QWidget* toolbar, PsiAccount* account, const QString& contact, const QString& plugin = "");
+	bool hasGCToolBarButton(const QString& plugin) const;
+	void addAccountMenu(QMenu *menu, PsiAccount* account);
+	void addContactMenu(QMenu *menu, PsiAccount* account, QString jid);
+
+	void setupChatTab(QWidget *tab, PsiAccount* account, const QString& contact);
+	void setupGCTab(QWidget *tab, PsiAccount* account, const QString& contact);
+	bool appendingChatMessage(PsiAccount* account, const QString& contact,
+				  QString& body, QDomElement& html, bool local);
+
+	QString pluginInfo(const QString& plugin) const;
+	bool hasInfoProvider(const QString& plugin) const;
+	QIcon icon(const QString& plugin) const;
 
 	static const QString loadOptionPrefix;
 	static const QString pluginOptionPrefix;
 
 private:
 	PluginManager();
+	PsiCon *psi_;
 	void loadAllPlugins();
 	bool verifyStanza(const QString& stanza);
-	void updatePluginsList();
+	QList<PluginHost*> updatePluginsList();
+	void loadPluginIfEnabled(PluginHost* plugin);
 
 	static PluginManager* instance_;
 
@@ -63,26 +110,71 @@ private:
 	QVector<XMPP::Client*> clients_;
 
 	//account, account id
-	QHash<const PsiAccount*, int> accountIds_;
+	AccountIds accountIds_;
 
 	//name, host
-	QHash<QString, PluginHost*> hosts_;
+	QMap<QString, PluginHost*> hosts_;
 	//file, host
-	QHash<QString, PluginHost*> pluginByFile_;
+	QMap<QString, PluginHost*> pluginByFile_;
+	//sorted by priority
+	QList<PluginHost*> pluginsByPriority_;
 
 
 	QList<QCA::DirWatch*> dirWatchers_;
 
+	// Options widget provides by plugin on opt_plugins
+	QPointer<QWidget> optionsWidget_;
+
 	class StreamWatcher;
 	bool incomingXml(int account, const QDomElement &eventXml);
 	void sendXml(int account, const QString& xml);
-	QString uniqueId(int account);
+	QString uniqueId(int account) const;
+
+	QString getStatus(int account) const;
+	QString getStatusMessage(int account) const;
+	QString proxyHost(int account) const;
+	int proxyPort(int account) const;
+	QString proxyUser(int account) const;
+	QString proxyPassword(int account) const;
+	QStringList getRoster(int account) const;
+	QString getJid(int account) const;
+	QString getId(int account) const;
+	QString getName(int account) const;
+	int findOnlineAccountForContact(const QString &jid) const;
+
+	bool isSelf(int account, const QString& jid) const;
+	bool isAgent(int account, const QString& jid) const;
+	bool inList(int account, const QString& jid) const;
+	bool isPrivate(int account, const QString& jid) const;
+	bool isConference(int account, const QString& jid) const;
+	QString name(int account, const QString& jid) const;
+	QString status(int account, const QString& jid) const;
+	QString statusMessage(int account, const QString& jid) const;
+	QStringList resources(int account, const QString& jid) const;
+
+	bool setActivity(int account, const QString& Jid, QDomElement xml);
+	bool setMood(int account, const QString& Jid, QDomElement xml);
+	bool setTune(int account, const QString& Jid, const QString& tune);
+
+	void initPopup(const QString& text, const QString& title, const QString& icon, int type);
+	void initPopupForJid(int account, const QString& jid, const QString& text, const QString& title, const QString& icon, int tipe);
+	int registerOption(const QString& name, int initValue = 5, const QString& path = QString());
+	void unregisterOption(const QString& name);
+	int popupDuration(const QString& name) const;
+	void setPopupDuration(const QString& name, int value);
+
+	void setStatus(int account, const QString& status, const QString& statusMessage);
+
+	bool appendSysMsg(int account, const QString& jid, const QString& message);
+
+	void createNewEvent(int account, const QString& jid, const QString& descr, QObject *receiver, const char* slot);
 
 	friend class PluginHost;
 
 private slots:
 	void dirsChanged();
 	void optionChanged(const QString& option);
+	void accountDestroyed();
 };
 
 #endif
--- psi.orig/src/plugins/include/accountinfoaccessinghost.h
+++ psi/src/plugins/include/accountinfoaccessinghost.h
@@ -0,0 +1,27 @@
+#ifndef ACCOUNTINFOACCESSINGHOST_H
+#define ACCOUNTINFOACCESSINGHOST_H
+
+class QString;
+class QStringList;
+
+class AccountInfoAccessingHost
+{
+public:
+	virtual ~AccountInfoAccessingHost() {}
+
+	virtual QString getStatus(int account) = 0;
+	virtual QString getStatusMessage(int account) = 0;
+	virtual QString proxyHost(int account) = 0;
+	virtual int proxyPort(int account) = 0;
+	virtual QString proxyUser(int account) = 0;
+	virtual QString proxyPassword(int account) = 0;
+	virtual QString getJid(int account) = 0;  //if account out of range return "-1"
+	virtual QString getId(int account) = 0;  //if account out of range return "-1"
+	virtual QString getName(int account) = 0;  //if account out of range return ""
+	virtual QStringList getRoster(int account) = 0; //if account out of range return List with one element, value "-1"
+	virtual int findOnlineAccountForContact(const QString &jid) const = 0; //gets all accounts and searches for specified contact in them. return -1 if account is not found
+};
+
+Q_DECLARE_INTERFACE(AccountInfoAccessingHost, "org.psi-im.AccountInfoAccessingHost/0.1");
+
+#endif // ACCOUNTINFOACCESSINGHOST_H
--- psi.orig/src/plugins/include/accountinfoaccessor.h
+++ psi/src/plugins/include/accountinfoaccessor.h
@@ -0,0 +1,18 @@
+#ifndef ACCOUNTINFOACCESSOR_H
+#define ACCOUNTINFOACCESSOR_H
+
+class AccountInfoAccessingHost;
+
+class AccountInfoAccessor
+{
+public:
+	virtual ~AccountInfoAccessor() {}
+
+	virtual void setAccountInfoAccessingHost(AccountInfoAccessingHost* host) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(AccountInfoAccessor, "org.psi-im.AccountInfoAccessor/0.1");
+
+
+#endif // ACCOUNTINFOACCESSOR_H
--- psi.orig/src/plugins/include/activetabaccessinghost.h
+++ psi/src/plugins/include/activetabaccessinghost.h
@@ -0,0 +1,18 @@
+#ifndef ACTIVETABACCESSINGHOST_H
+#define ACTIVETABACCESSINGHOST_H
+
+class QString;
+class QTextEdit;
+
+class ActiveTabAccessingHost
+{
+public:
+	virtual ~ActiveTabAccessingHost() {}
+
+	virtual QTextEdit* getEditBox() = 0;
+	virtual QString getJid() = 0;
+	virtual QString getYourJid() = 0; //return full jid of your account for active tab
+};
+
+Q_DECLARE_INTERFACE(ActiveTabAccessingHost, "org.psi-im.ActiveTabAccessingHost/0.1");
+#endif // ACTIVETABACCESSINGHOST_H
--- psi.orig/src/plugins/include/activetabaccessor.h
+++ psi/src/plugins/include/activetabaccessor.h
@@ -0,0 +1,17 @@
+#ifndef ACTIVETABACCESSOR_H
+#define ACTIVETABACCESSOR_H
+
+class ActiveTabAccessingHost;
+
+class ActiveTabAccessor
+{
+public:
+	virtual ~ActiveTabAccessor() {}
+
+	virtual void setActiveTabAccessingHost(ActiveTabAccessingHost* host) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(ActiveTabAccessor, "org.psi-im.ActiveTabAccessor/0.1");
+
+#endif // ACTIVETABACCESSOR_H
--- psi.orig/src/plugins/include/applicationinfoaccessinghost.h
+++ psi/src/plugins/include/applicationinfoaccessinghost.h
@@ -0,0 +1,45 @@
+#ifndef APPLICATIONINFOACCESSINGHOST_H
+#define APPLICATIONINFOACCESSINGHOST_H
+
+class QString;
+
+struct Proxy {
+	QString type;
+	QString host;
+	int port;
+	QString user;
+	QString pass;
+};
+
+class ApplicationInfoAccessingHost
+{
+public:
+	enum HomedirType {
+		ConfigLocation,
+		DataLocation,
+		CacheLocation
+	};
+	virtual ~ApplicationInfoAccessingHost() {}
+
+	// Version info
+	virtual QString appName() = 0;
+	virtual QString appVersion() = 0;
+	virtual QString appCapsNode() = 0;
+	virtual QString appCapsVersion() = 0;
+	virtual QString appOsName() = 0;
+
+	// Directories
+	virtual QString appHomeDir(HomedirType type) = 0;
+	virtual QString appResourcesDir() = 0;
+	virtual QString appLibDir() = 0;
+	virtual QString appProfilesDir(HomedirType type) = 0;
+	virtual QString appHistoryDir() = 0;
+	virtual QString appCurrentProfileDir(HomedirType type) = 0;
+	virtual QString appVCardDir() = 0;
+
+	virtual Proxy getProxyFor(const QString& obj) = 0;
+};
+
+Q_DECLARE_INTERFACE(ApplicationInfoAccessingHost, "org.psi-im.ApplicationInfoAccessingHost/0.1");
+
+#endif // APPLICATIONINFOACCESSINGHOST_H
--- psi.orig/src/plugins/include/applicationinfoaccessor.h
+++ psi/src/plugins/include/applicationinfoaccessor.h
@@ -0,0 +1,17 @@
+#ifndef APPLICATIONINFOACCESSOR_H
+#define APPLICATIONINFOACCESSOR_H
+
+class ApplicationInfoAccessingHost;
+
+class ApplicationInfoAccessor
+{
+public:
+	virtual ~ApplicationInfoAccessor() {}
+
+	virtual void setApplicationInfoAccessingHost(ApplicationInfoAccessingHost* host) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(ApplicationInfoAccessor, "org.psi-im.ApplicationInfoAccessor/0.1");
+
+#endif // APPLICATIONINFOACCESSOR_H
--- psi.orig/src/plugins/include/chattabaccessor.h
+++ psi/src/plugins/include/chattabaccessor.h
@@ -0,0 +1,22 @@
+#ifndef CHATTABACCESSOR_H
+#define CHATTABACCESSOR_H
+
+class QWidget;
+class QString;
+class QDomElement;
+
+class ChatTabAccessor
+{
+public:
+	virtual ~ChatTabAccessor() {}
+
+	virtual void setupChatTab(QWidget* tab, int account, const QString& contact) = 0;
+	virtual void setupGCTab(QWidget* tab, int account, const QString& contact) = 0;
+
+	virtual bool appendingChatMessage(int account, const QString& contact,
+					  QString& body, QDomElement& html, bool local) = 0;
+};
+
+Q_DECLARE_INTERFACE(ChatTabAccessor, "org.psi-im.ChatTabAccessor/0.1")
+
+#endif // CHATTABACCESSOR_H
--- psi.orig/src/plugins/include/contactinfoaccessinghost.h
+++ psi/src/plugins/include/contactinfoaccessinghost.h
@@ -0,0 +1,27 @@
+#ifndef CONTACTINFOACCESSINGHOST_H
+#define CONTACTINFOACCESSINGHOST_H
+
+class QString;
+class QStringList;
+
+class ContactInfoAccessingHost
+{
+public:
+	virtual ~ContactInfoAccessingHost() {}
+
+	// Note that all this methods are checking full jid (with resource)
+	// So for normal contacts is preferable to use bare jid in queries
+	virtual bool isSelf(int account, const QString& jid) = 0;
+	virtual bool isAgent(int account, const QString& jid) = 0;
+	virtual bool inList(int account, const QString& jid) = 0;
+	virtual bool isPrivate(int account, const QString& jid) = 0;
+	virtual bool isConference(int account, const QString& jid) = 0;
+	virtual QString name(int account, const QString& jid) = 0;
+	virtual QString status(int account, const QString& jid) = 0;
+	virtual QString statusMessage(int account, const QString& jid) = 0;
+	virtual QStringList resources(int account, const QString& jid) = 0;
+};
+
+Q_DECLARE_INTERFACE(ContactInfoAccessingHost, "org.psi-im.ContactInfoAccessingHost/0.1");
+
+#endif // CONTACTINFOACCESSINGHOST_H
--- psi.orig/src/plugins/include/contactinfoaccessor.h
+++ psi/src/plugins/include/contactinfoaccessor.h
@@ -0,0 +1,18 @@
+#ifndef CONTACTINFOACCESSOR_H
+#define CONTACTINFOACCESSOR_H
+
+class ContactInfoAccessingHost;
+
+class ContactInfoAccessor
+{
+public:
+	virtual ~ContactInfoAccessor() {}
+
+	virtual void setContactInfoAccessingHost(ContactInfoAccessingHost* host) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(ContactInfoAccessor, "org.psi-im.ContactInfoAccessor/0.1");
+
+
+#endif // CONTACTINFOACCESSOR_H
--- psi.orig/src/plugins/include/contactstateaccessinghost.h
+++ psi/src/plugins/include/contactstateaccessinghost.h
@@ -0,0 +1,19 @@
+#ifndef CONTACTSTATEACCESSINGHOST_H
+#define CONTACTSTATEACCESSINGHOST_H
+
+class QDomElement;
+class QString;
+
+class ContactStateAccessingHost
+{
+public:
+	virtual ~ContactStateAccessingHost() {}
+
+	virtual bool setActivity(int account, const QString& Jid, QDomElement xml) = 0;
+	virtual bool setMood(int account, const QString& Jid, QDomElement xml) = 0;
+	virtual bool setTune(int account, const QString& Jid, QString tune) = 0;
+};
+
+Q_DECLARE_INTERFACE(ContactStateAccessingHost, "org.psi-im.ContactStateAccessingHost/0.2");
+
+#endif // CONTACTSTATEACCESSINGHOST_H
--- psi.orig/src/plugins/include/contactstateaccessor.h
+++ psi/src/plugins/include/contactstateaccessor.h
@@ -0,0 +1,18 @@
+#ifndef CONTACTSTATEACCESSOR_H
+#define CONTACTSTATEACCESSOR_H
+
+class ContactStateAccessingHost;
+
+class ContactStateAccessor
+{
+public:
+	virtual ~ContactStateAccessor() {}
+
+	virtual void setContactStateAccessingHost(ContactStateAccessingHost* host) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(ContactStateAccessor, "org.psi-im.ContactStateAccessor/0.2");
+
+
+#endif // CONTACTSTATEACCESSOR_H
--- psi.orig/src/plugins/include/eventcreatinghost.h
+++ psi/src/plugins/include/eventcreatinghost.h
@@ -0,0 +1,16 @@
+#ifndef EVENTCREATINGHOST_H
+#define EVENTCREATINGHOST_H
+
+class QObject;
+class QString;
+
+class EventCreatingHost
+{
+public:
+	virtual ~EventCreatingHost() {}
+
+	virtual void createNewEvent(int account, const QString& jid, const QString& descr, QObject *receiver, const char* slot) = 0;
+};
+
+Q_DECLARE_INTERFACE(EventCreatingHost, "org.psi-im.EventCreatingHost/0.1");
+#endif
--- psi.orig/src/plugins/include/eventcreator.h
+++ psi/src/plugins/include/eventcreator.h
@@ -0,0 +1,17 @@
+#ifndef EVENTCREATOR_H
+#define EVENTCREATOR_H
+
+class EventCreatingHost;
+
+class EventCreator
+{
+public:
+	virtual ~EventCreator() {}
+
+	virtual void setEventCreatingHost(EventCreatingHost* host) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(EventCreator, "org.psi-im.EventCreator/0.1");
+
+#endif
--- psi.orig/src/plugins/include/eventfilter.h
+++ psi/src/plugins/include/eventfilter.h
@@ -1,7 +1,8 @@
 #ifndef EVENTFILTER_H
 #define EVENTFILTER_H
 
-#include <QDomElement>
+class QDomElement;
+class QString;
 
 class EventFilter
 {
@@ -10,8 +11,10 @@ public:
 
 	// true = handled, don't pass to next handler
 
-    virtual bool processEvent(int account, const QDomElement& e) = 0;
+	virtual bool processEvent(int account, QDomElement& e) = 0;
 	virtual bool processMessage(int account, const QString& fromJid, const QString& body, const QString& subject) = 0;
+	virtual bool processOutgoingMessage(int account, const QString& fromJid, QString& body, const QString& type, QString& subject) = 0;
+	virtual void logout(int account) = 0;
 };
 
 Q_DECLARE_INTERFACE(EventFilter, "org.psi-im.EventFilter/0.1");
--- psi.orig/src/plugins/include/gctoolbariconaccessor.h
+++ psi/src/plugins/include/gctoolbariconaccessor.h
@@ -0,0 +1,22 @@
+#ifndef GCTOOLBARICONACCESSOR_H
+#define GCTOOLBARICONACCESSOR_H
+
+#include <QList>
+#include <QVariantHash>
+
+class QObject;
+class QAction;
+class QString;
+
+class GCToolbarIconAccessor
+{
+public:
+	virtual ~GCToolbarIconAccessor() {}
+
+	virtual QList < QVariantHash > getGCButtonParam() = 0;
+	virtual QAction* getGCAction(QObject* parent, int account, const QString& contact) = 0;
+};
+
+Q_DECLARE_INTERFACE(GCToolbarIconAccessor, "org.psi-im.GCToolbarIconAccessor/0.1");
+
+#endif // GCTOOLBARICONACCESSOR_H
--- psi.orig/src/plugins/include/iconfactoryaccessinghost.h
+++ psi/src/plugins/include/iconfactoryaccessinghost.h
@@ -0,0 +1,17 @@
+#ifndef ICONFACTORYACCESSINGHOST_H
+#define ICONFACTORYACCESSINGHOST_H
+
+class QByteArray;
+class QString;
+
+class IconFactoryAccessingHost
+{
+public:
+	virtual ~IconFactoryAccessingHost() {}
+
+	virtual void addIcon(const QString& name, const QByteArray& icon) = 0;
+	virtual QIcon getIcon(const QString& name) = 0;
+};
+
+Q_DECLARE_INTERFACE(IconFactoryAccessingHost, "org.psi-im.IconFactoryAccessingHost/0.1");
+#endif // ICONFACTORYACCESSINGHOST_H
--- psi.orig/src/plugins/include/iconfactoryaccessor.h
+++ psi/src/plugins/include/iconfactoryaccessor.h
@@ -0,0 +1,17 @@
+#ifndef ICONFACTORYACCESSOR_H
+#define ICONFACTORYACCESSOR_H
+
+class IconFactoryAccessingHost;
+
+class IconFactoryAccessor
+{
+public:
+	virtual ~IconFactoryAccessor() {}
+
+	virtual void setIconFactoryAccessingHost(IconFactoryAccessingHost* host) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(IconFactoryAccessor, "org.psi-im.IconFactoryAccessor/0.1");
+
+#endif // ICONFACTORYACCESSOR_H
--- psi.orig/src/plugins/include/iqfilteringhost.h
+++ psi/src/plugins/include/iqfilteringhost.h
@@ -1,8 +1,8 @@
 #ifndef IQFILTERINGHOST_H
 #define IQFILTERINGHOST_H
 
-#include <QString>
-#include <QRegExp>
+class QString;
+class QRegExp;
 
 class IqNamespaceFilter;
 
--- psi.orig/src/plugins/include/iqnamespacefilter.h
+++ psi/src/plugins/include/iqnamespacefilter.h
@@ -1,7 +1,7 @@
 #ifndef IQNAMESPACEFILTER_H
 #define IQNAMESPACEFILTER_H
 
-#include <QDomElement>
+class QDomElement;
 
 class IqNamespaceFilter
 {
--- psi.orig/src/plugins/include/menuaccessor.h
+++ psi/src/plugins/include/menuaccessor.h
@@ -0,0 +1,25 @@
+#ifndef MENUACCESSOR_H
+#define MENUACCESSOR_H
+
+#include <QList>
+#include <QVariantHash>
+
+class QObject;
+class QAction;
+class QString;
+
+class MenuAccessor
+{
+public:
+	virtual ~MenuAccessor() {}
+
+	virtual QList < QVariantHash > getAccountMenuParam() = 0;
+	virtual QList < QVariantHash > getContactMenuParam() = 0;
+	virtual QAction* getContactAction(QObject* parent, int account, const QString& contact) = 0;
+	virtual QAction* getAccountAction(QObject* parent, int account) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(MenuAccessor, "org.psi-im.MenuAccessor/0.1");
+
+#endif
--- psi.orig/src/plugins/include/optionaccessinghost.h
+++ psi/src/plugins/include/optionaccessinghost.h
@@ -1,8 +1,8 @@
 #ifndef OPTIONACCESSINGHOST_H
 #define OPTIONACCESSINGHOST_H
 
-#include <QDomElement>
-#include <QVariant>
+class QString;
+class QVariant;
 
 class OptionAccessingHost
 {
@@ -10,7 +10,7 @@ public:
 	virtual ~OptionAccessingHost() {}
 
 	virtual void setPluginOption(const QString& option, const QVariant& value) = 0;
-	virtual QVariant getPluginOption(const QString& option) = 0;
+	virtual QVariant getPluginOption(const QString &option, const QVariant &defValue = QVariant::Invalid) = 0;
 
 	virtual void setGlobalOption(const QString& option, const QVariant& value) = 0;
 	virtual QVariant getGlobalOption(const QString& option) = 0;
--- psi.orig/src/plugins/include/optionaccessor.h
+++ psi/src/plugins/include/optionaccessor.h
@@ -1,8 +1,7 @@
 #ifndef OPTIONACCESSOR_H
 #define OPTIONACCESSOR_H
 
-#include <QDomElement>
-//#include <QString>
+class QString;
 
 class OptionAccessingHost;
 
--- psi.orig/src/plugins/include/plugininfoprovider.h
+++ psi/src/plugins/include/plugininfoprovider.h
@@ -0,0 +1,18 @@
+#ifndef PLUGININFOPROVIDER_H
+#define PLUGININFOPROVIDER_H
+
+class QString;
+
+class PluginInfoProvider
+{
+public:
+	virtual ~PluginInfoProvider() {}
+
+	virtual QString pluginInfo() = 0;
+
+};
+
+Q_DECLARE_INTERFACE(PluginInfoProvider, "org.psi-im.PluginInfoProvider/0.1");
+
+
+#endif // PLUGININFOPROVIDER_H
--- psi.orig/src/plugins/include/popupaccessinghost.h
+++ psi/src/plugins/include/popupaccessinghost.h
@@ -0,0 +1,21 @@
+#ifndef POPUPACCESSINGHOST_H
+#define POPUPACCESSINGHOST_H
+
+class QString;
+
+class PopupAccessingHost
+{
+public:
+	virtual ~PopupAccessingHost() {}
+
+	virtual void initPopup(const QString& text, const QString& title, const QString& icon = "psi/headline", int type = 0) = 0;
+	virtual void initPopupForJid(int account, const QString& jid, const QString& text, const QString& title, const QString& icon = "psi/headline", int type = 0) = 0;
+	virtual int registerOption(const QString& name, int initValue = 5, const QString& path = QString()) = 0;
+	virtual int popupDuration(const QString& name) = 0;
+	virtual void setPopupDuration(const QString& name, int value) = 0;
+	virtual void unregisterOption(const QString& name) = 0;
+};
+
+Q_DECLARE_INTERFACE(PopupAccessingHost, "org.psi-im.PopupAccessingHost/0.1");
+
+#endif
--- psi.orig/src/plugins/include/popupaccessor.h
+++ psi/src/plugins/include/popupaccessor.h
@@ -0,0 +1,16 @@
+#ifndef POPUPACCESSOR_H
+#define POPUPACCESSOR_H
+
+class PopupAccessingHost;
+
+class PopupAccessor
+{
+public:
+	virtual ~PopupAccessor() {}
+
+	virtual void setPopupAccessingHost(PopupAccessingHost* host) = 0;
+};
+
+Q_DECLARE_INTERFACE(PopupAccessor, "org.psi-im.PopupAccessor/0.1");
+
+#endif // POPUPACCESSOR_H
--- psi.orig/src/plugins/include/psiaccountcontroller.h
+++ psi/src/plugins/include/psiaccountcontroller.h
@@ -0,0 +1,18 @@
+#ifndef PSIACCOUNTCONTROLLER_H
+#define PSIACCOUNTCONTROLLER_H
+
+class PsiAccountControllingHost;
+
+class PsiAccountController
+{
+public:
+	virtual ~PsiAccountController() {}
+
+	virtual void setPsiAccountControllingHost(PsiAccountControllingHost* host) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(PsiAccountController, "org.psi-im.PsiAccountController/0.1");
+
+
+#endif // PSIACCOUNTCONTROLLER_H
--- psi.orig/src/plugins/include/psiaccountcontrollinghost.h
+++ psi/src/plugins/include/psiaccountcontrollinghost.h
@@ -0,0 +1,18 @@
+#ifndef PSIACCOUNTCONTROLLINGHOST_H
+#define PSIACCOUNTCONTROLLINGHOST_H
+
+class QString;
+
+class PsiAccountControllingHost
+{
+public:
+	virtual ~PsiAccountControllingHost() {}
+
+	virtual void setStatus(int account, const QString& status, const QString& statusMessage) = 0;
+
+	virtual bool appendSysMsg(int account, const QString& jid, const QString& message) = 0;
+};
+
+Q_DECLARE_INTERFACE(PsiAccountControllingHost, "org.psi-im.PsiAccountControllingHost/0.1");
+
+#endif // PSIACCOUNTCONTROLLINGHOST_H
--- psi.orig/src/plugins/include/psiplugin.h
+++ psi/src/plugins/include/psiplugin.h
@@ -37,8 +37,29 @@ class QWidget;
 class PsiPlugin
 {
 public:
+	// Priorities allows plugins to make processing more ordered. For example
+	// some plugins may require process stanzas as early as possible, others
+	// may want to do some work at the end. So here here are 5 levels of
+	// priority which plugin may choose from. If plugin is not aware about
+	// priority then Normal will be choosed for it.
+	// While writing plugins its desirable to think twice before choosing
+	// Lowest or Highest priority, since your plugin may be not the only which
+	// need it. Think about for example stopspam plugin which is known to be
+	// highest prioroty blocker/processor. Are you writing stopspam? If not
+	// choose High if you want something more then Normal.
+	enum Priority
+	{
+		PriorityLowest	= 0, // always in the end. last loaded Lowest plugin moves other Lowest to Low side
+		PriorityLow		= 1,
+		PriorityNormal	= 2, // default
+		PriorityHigh	= 3,
+		PriorityHighest	= 4, // always in the start. last loaded Highest plugin moves others to High side
+	};
+
 	virtual ~PsiPlugin() {}
 
+	virtual Priority priority() { return PriorityNormal; }
+
 	/**
 	 * \brief Plugin Name
 	 * The full name of the plugin.
@@ -72,7 +93,7 @@ public:
 	 *
 	 * TODO: make sure this is really deleted, etc
 	 */
-	virtual QWidget* options() const = 0;
+	virtual QWidget* options() = 0;
 
 	/**
 	 * \brief Enable plugin
@@ -87,8 +108,12 @@ public:
 	 */
 	virtual bool disable() = 0;
 
+	virtual void applyOptions() = 0;
+	virtual void restoreOptions() = 0;
+
+	virtual QPixmap icon() const = 0;
 };
 
-Q_DECLARE_INTERFACE(PsiPlugin, "org.psi-im.PsiPlugin/0.3");
+Q_DECLARE_INTERFACE(PsiPlugin, "org.psi-im.PsiPlugin/0.4");
 
 #endif
--- psi.orig/src/plugins/include/shortcutaccessinghost.h
+++ psi/src/plugins/include/shortcutaccessinghost.h
@@ -0,0 +1,20 @@
+#ifndef SHORTCUTACCESSINGHOST_H
+#define SHORTCUTACCESSINGHOST_H
+
+class QObject;
+class QKeySequence;
+
+class ShortcutAccessingHost
+{
+public:
+	virtual ~ShortcutAccessingHost() {}
+
+	virtual void connectShortcut(const QKeySequence& shortcut, QObject *receiver, const char* slot) = 0;
+	virtual void disconnectShortcut(const QKeySequence& shortcut, QObject *receiver, const char* slot) = 0;
+	virtual void requestNewShortcut(QObject *receiver, const char* slot) = 0;
+
+};
+
+Q_DECLARE_INTERFACE(ShortcutAccessingHost, "org.psi-im.ShortcutAccessingHost/0.1");
+
+#endif
--- psi.orig/src/plugins/include/shortcutaccessor.h
+++ psi/src/plugins/include/shortcutaccessor.h
@@ -0,0 +1,18 @@
+#ifndef SHORTCUTACCESSOR_H
+#define SHORTCUTACCESSOR_H
+
+class ShortcutAccessingHost;
+
+class ShortcutAccessor
+{
+public:
+	virtual ~ShortcutAccessor() {}
+
+	virtual void setShortcutAccessingHost(ShortcutAccessingHost* host) = 0;
+	virtual void setShortcuts() = 0;
+
+};
+
+Q_DECLARE_INTERFACE(ShortcutAccessor, "org.psi-im.ShortcutAccessor/0.1");
+
+#endif
--- psi.orig/src/plugins/include/soundaccessinghost.h
+++ psi/src/plugins/include/soundaccessinghost.h
@@ -0,0 +1,16 @@
+#ifndef SOUNDACCESSINGHOST_H
+#define SOUNDACCESSINGHOST_H
+
+class QString;
+
+class SoundAccessingHost
+{
+public:
+	virtual ~SoundAccessingHost() {}
+
+	virtual void playSound(const QString& fileName) = 0;
+};
+
+Q_DECLARE_INTERFACE(SoundAccessingHost, "org.psi-im.SoundAccessingHost/0.1");
+
+#endif
--- psi.orig/src/plugins/include/soundaccessor.h
+++ psi/src/plugins/include/soundaccessor.h
@@ -0,0 +1,16 @@
+#ifndef SOUNDACCESSOR_H
+#define SOUNDACCESSOR_H
+
+class SoundAccessingHost;
+
+class SoundAccessor
+{
+public:
+	virtual ~SoundAccessor() {}
+
+	virtual void setSoundAccessingHost(SoundAccessingHost* host) = 0;
+};
+
+Q_DECLARE_INTERFACE(SoundAccessor, "org.psi-im.SoundAccessor/0.1");
+
+#endif
--- psi.orig/src/plugins/include/stanzafilter.h
+++ psi/src/plugins/include/stanzafilter.h
@@ -1,7 +1,7 @@
 #ifndef STANZAFILTER_H
 #define STANZAFILTER_H
 
-#include <QDomElement>
+class QDomElement;
 
 class StanzaFilter
 {
@@ -10,7 +10,8 @@ public:
 
 	// true = handled, don't pass to next handler
 
-    virtual bool incomingStanza(int account, const QDomElement& xml) = 0;
+	virtual bool incomingStanza(int account, const QDomElement& xml) = 0;
+	virtual bool outgoingStanza(int account, QDomElement &xml) = 0;
 };
 
 Q_DECLARE_INTERFACE(StanzaFilter, "org.psi-im.StanzaFilter/0.1");
--- psi.orig/src/plugins/include/stanzasendinghost.h
+++ psi/src/plugins/include/stanzasendinghost.h
@@ -1,8 +1,8 @@
 #ifndef STANZASENDINGHOST_H
 #define STANZASENDINGHOST_H
 
-#include <QDomElement>
-#include <QString>
+class QDomElement;
+class QString;
 
 class StanzaSendingHost
 {
@@ -15,6 +15,7 @@ public:
 	virtual void sendMessage(int account, const QString& to, const QString& body, const QString& subject, const QString& type) = 0;
 
 	virtual QString uniqueId(int account) = 0;
+	virtual QString escape(const QString& str) = 0;
 };
 
 Q_DECLARE_INTERFACE(StanzaSendingHost, "org.psi-im.StanzaSendingHost/0.1");
--- psi.orig/src/plugins/include/toolbariconaccessor.h
+++ psi/src/plugins/include/toolbariconaccessor.h
@@ -0,0 +1,22 @@
+#ifndef TOOLBARICONACCESSOR_H
+#define TOOLBARICONACCESSOR_H
+
+#include <QList>
+#include <QVariantHash>
+
+class QObject;
+class QAction;
+class QString;
+
+class ToolbarIconAccessor
+{
+public:
+	virtual ~ToolbarIconAccessor() {}
+
+	virtual QList < QVariantHash > getButtonParam() = 0;
+	virtual QAction* getAction(QObject* parent, int account, const QString& contact) = 0;
+};
+
+Q_DECLARE_INTERFACE(ToolbarIconAccessor, "org.psi-im.ToolbarIconAccessor/0.1");
+
+#endif // TOOLBARICONACCESSOR_H
--- psi.orig/src/plugins/plugins.pri
+++ psi/src/plugins/plugins.pri
@@ -10,5 +10,31 @@ HEADERS += \
 	$$PWD/include/iqfilteringhost.h \
 	$$PWD/include/eventfilter.h \
 	$$PWD/include/optionaccessor.h \
-	$$PWD/include/optionaccessinghost.h
-
+	$$PWD/include/optionaccessinghost.h \
+	$$PWD/include/popupaccessor.h \
+	$$PWD/include/popupaccessinghost.h \
+	$$PWD/include/shortcutaccessor.h \
+	$$PWD/include/shortcutaccessinghost.h\
+	$$PWD/include/iconfactoryaccessor.h \
+	$$PWD/include/iconfactoryaccessinghost.h\
+	$$PWD/include/activetabaccessor.h \
+	$$PWD/include/activetabaccessinghost.h \
+	$$PWD/include/applicationinfoaccessor.h \
+	$$PWD/include/applicationinfoaccessinghost.h \
+	$$PWD/include/accountinfoaccessor.h \
+	$$PWD/include/accountinfoaccessinghost.h\
+	$$PWD/include/gctoolbariconaccessor.h \
+	$$PWD/include/toolbariconaccessor.h \
+	$$PWD/include/menuaccessor.h \
+	$$PWD/include/contactstateaccessor.h \
+	$$PWD/include/contactstateaccessinghost.h \
+	$$PWD/include/plugininfoprovider.h \
+	$$PWD/include/psiaccountcontroller.h\
+	$$PWD/include/psiaccountcontrollinghost.h \
+	$$PWD/include/eventcreatinghost.h \
+	$$PWD/include/eventcreator.h \
+	$$PWD/include/contactinfoaccessor.h \
+	$$PWD/include/contactinfoaccessinghost.h \
+	$$PWD/include/soundaccessor.h \
+	$$PWD/include/soundaccessinghost.h \
+	$$PWD/include/chattabaccessor.h
--- psi.orig/src/psiaccount.cpp
+++ psi/src/psiaccount.cpp
@@ -783,6 +783,13 @@ public slots:
 		xmlRingbufWrite = (xmlRingbufWrite + 1) % xmlRingbuf.count();
 	}
 
+	void client_stanzaElementOutgoing(QDomElement &s)
+	{
+#ifdef PSI_PLUGINS
+		PluginManager::instance()->processOutgoingStanza(account, s);
+#endif
+	}
+
 	void pm_proxyRemoved(QString proxykey)
 	{
 		if (acc.proxyID == proxykey) acc.proxyID = "";
@@ -1138,6 +1145,11 @@ PsiAccount::PsiAccount(const UserAccount
 
 	// create XMPP::Client
 	d->client = new Client;
+
+	// Plugins
+#ifdef PSI_PLUGINS
+	PluginManager::instance()->addAccount(this, d->client);
+#endif
 	d->client->setOSName(SystemInfo::instance()->os());
 	d->client->setClientName(ApplicationInfo::name());
 	d->client->setClientVersion(ApplicationInfo::version());
@@ -1195,6 +1207,7 @@ PsiAccount::PsiAccount(const UserAccount
 	connect(d->client, SIGNAL(endImportRoster()), SIGNAL(endBulkContactUpdate()));
 	connect(d->client, SIGNAL(xmlIncoming(const QString &)), d, SLOT(client_xmlIncoming(const QString &)));
 	connect(d->client, SIGNAL(xmlOutgoing(const QString &)), d, SLOT(client_xmlOutgoing(const QString &)));
+	connect(d->client, SIGNAL(stanzaElementOutgoing(QDomElement &)), d, SLOT(client_stanzaElementOutgoing(QDomElement &)));
 
 	// Privacy manager
 	d->privacyManager = new PsiPrivacyManager(d->account, d->client->rootTask());
@@ -1257,11 +1270,6 @@ PsiAccount::PsiAccount(const UserAccount
 	d->rcLeaveMucServer =0;
 	setRCEnabled(PsiOptions::instance()->getOption("options.external-control.adhoc-remote-control.enable").toBool());
 
-	// Plugins
-#ifdef PSI_PLUGINS
-	PluginManager::instance()->addAccount(this, d->client);
-#endif
-
 	//Idle server
 	if(PsiOptions::instance()->getOption("options.service-discovery.last-activity").toBool()) {
 		new IdleServer(this, d->client->rootTask());
@@ -1831,6 +1839,9 @@ void PsiAccount::logout(bool fast, const
 	if(!isActive())
 		return;
 
+#ifdef PSI_PLUGINS
+	PluginManager::instance()->logout(this);
+#endif
 	clearCurrentConnectionError();
 
 	d->stopReconnect();
@@ -4728,6 +4739,22 @@ void PsiAccount::dj_sendMessage(const Me
 			nm.setNick(nick());
 		}
 	}
+	
+#ifdef PSI_PLUGINS
+	if (!nm.body().isEmpty()) {
+		QString body = nm.body();
+		QString subject = nm.subject();
+
+		if(PluginManager::instance()->processOutgoingMessage(this, nm.to().full(), body, nm.type(), subject))
+			return;
+		if (body != nm.body()) {
+			nm.setBody(body);
+		}
+		if (subject != nm.subject()) {
+			nm.setSubject(subject);
+		}
+	}
+#endif
 
 	// GSOC: stream management
 	// check whether message came from a ChatDlg
@@ -5020,6 +5047,15 @@ static bool messageListContainsEvent(con
 	return false;
 }
 
+#ifdef PSI_PLUGINS
+void PsiAccount::createNewPluginEvent(const QString &jid, const QString &descr, QObject *receiver, const char *slot)
+{
+	PluginEvent::Ptr pe(new PluginEvent(jid, descr, this));
+	connect(pe.data(), SIGNAL(activated(QString)), receiver, slot);
+	handleEvent(pe, IncomingStanza);
+}
+#endif
+
 // handle an incoming event
 void PsiAccount::handleEvent(const PsiEvent::Ptr &e, ActivationType activationType)
 {
@@ -5065,12 +5101,13 @@ void PsiAccount::handleEvent(const PsiEv
 	e->setJid(j);
 
 #ifdef PSI_PLUGINS
-	QDomElement eXml = e->toXml(new QDomDocument());
+	QDomDocument doc;
+	QDomElement eXml = e->toXml(&doc);
 	if (PluginManager::instance()->processEvent(this, eXml)) {
-		delete e;
 		return;
+	} else {
+		e->fromXml(psi(),this, &eXml);
 	}
-	//FIXME(KIS): must now cause the event to be recreated from this xml or such. Horrid.
 #endif
 
 	if (d->psi->filterEvent(this, e)) {
@@ -5115,7 +5152,6 @@ void PsiAccount::handleEvent(const PsiEv
 		//if ( !ul.isEmpty() )
 		//	ulItem=ul.first();
 		if (PluginManager::instance()->processMessage(this, e->from().full(), m.body(), m.subject())) {
-			delete e;
 			return;
 		}
 		//PluginManager::instance()->message(this,e->from(),ulItem,((MessageEvent*)e)->message().body());
@@ -5313,6 +5349,13 @@ void PsiAccount::handleEvent(const PsiEv
 		}
 #endif
 	}
+#ifdef PSI_PLUGINS
+	else if (e->type() == PsiEvent::Plugin) {
+		soundType = eSystem;
+		doPopup = true;
+		popupType = PopupManager::AlertHeadline;
+	}
+#endif
 	else {
 		putToQueue = false;
 		doPopup = false;
@@ -5332,7 +5375,16 @@ void PsiAccount::handleEvent(const PsiEv
 		    (popupType == PopupManager::AlertAvCall    && o->getOption("options.ui.notifications.passive-popups.incoming-message").toBool()) ||
 		    (popupType == PopupManager::AlertComposing && o->getOption("options.ui.notifications.passive-popups.composing").toBool()))
 		{
-			psi()->popupManager()->doPopup(this, popupType, j, r, u, e, false);
+#ifdef PSI_PLUGINS
+			if(e->type() != PsiEvent::Plugin) {
+#endif
+				psi()->popupManager()->doPopup(this, popupType, j, r, u, e, false);
+#ifdef PSI_PLUGINS
+ 			}
+ 			else {
+				psi()->popupManager()->doPopup(this, j, IconsetFactory::iconPtr("psi/headline"), tr("Headline"), 0, 0, e->description(), false, popupType);
+			}
+#endif
 		}
 		emit startBounce();
 	}
@@ -5499,6 +5551,10 @@ void PsiAccount::queueEvent(const PsiEve
 		else if (e->type() == PsiEvent::File) {
 			doPopup = PsiOptions::instance()->getOption("options.ui.file-transfer.auto-popup").toBool();
 		}
+#ifdef PSI_PLUGINS
+		else if (e->type() == PsiEvent::Plugin)
+			doPopup = false;
+#endif
 		else {
 			doPopup = PsiOptions::instance()->getOption("options.ui.message.auto-popup").toBool();
 		}
@@ -5521,6 +5577,18 @@ void PsiAccount::openNextEvent(const Use
 	PsiEvent::Ptr e = d->eventQueue->peek(u.jid());
 	if(!e)
 		return;
+#ifdef PSI_PLUGINS
+	if(e->type() == PsiEvent::Plugin) {
+		PluginEvent::Ptr pe = e.staticCast<PluginEvent>();
+		pe->activate();
+		eventQueue()->dequeue(e);
+		queueChanged();
+		UserListItem *u = e->account()->find(e->jid());
+		if(u)
+			e->account()->cpUpdate(*u);
+		return;
+	}
+#endif
 
 	psi()->processEvent(e, activationType);
 }
--- psi.orig/src/psiaccount.h
+++ psi/src/psiaccount.h
@@ -252,6 +252,10 @@ public:
 	};
 	void playSound(SoundType onevent);
 
+#ifdef PSI_PLUGINS
+	void createNewPluginEvent(const QString& jid, const QString& descr, QObject *receiver, const char* slot);
+#endif
+
 	QStringList hiddenChats(const Jid &) const;
 
 	int sendMessageEncrypted(const Message &);
--- psi.orig/src/psiactionlist.cpp
+++ psi/src/psiactionlist.cpp
@@ -28,6 +28,9 @@
 
 #include "iconset.h"
 #include "psioptions.h"
+#ifdef PSI_PLUGINS
+#include "pluginmanager.h"
+#endif
 
 #include "mainwin_p.h"
 
@@ -515,6 +518,23 @@ void PsiActionList::Private::createGroup
 
 void PsiActionList::Private::addPluginsActions(ActionsType type)
 {
+#ifdef PSI_PLUGINS
+	PluginManager *pm = PluginManager::instance();
+	QStringList plugins = pm->availablePlugins();
+	ActionList *actions = new ActionList(tr("Plugins"), type, false);
+	foreach (const QString &plugin, plugins) {
+		if ((type == Actions_Chat      && !pm->hasToolBarButton(plugin)) ||
+			(type == Actions_Groupchat && !pm->hasGCToolBarButton(plugin))) {
+
+			continue;
+		}
+
+		IconAction *action = new IconAction(plugin, "", plugin, 0, this);
+		action->setIcon(pm->icon(plugin));
+		actions->addAction(pm->shortName(plugin) + "-plugin", action);
+	}
+	list->addList(actions);
+#endif
 }
 
 void PsiActionList::Private::optionsChanged()
--- psi.orig/src/psichatdlg.cpp
+++ psi/src/psichatdlg.cpp
@@ -50,6 +50,9 @@
 #include "avcall/avcall.h"
 #include "actionlist.h"
 #include "psiactionlist.h"
+#ifdef PSI_PLUGINS
+#include "pluginmanager.h"
+#endif
 
 #define MCMDCHAT		"http://psi-im.org/ids/mcmd#chatmain"
 
@@ -291,6 +294,10 @@ void PsiChatDlg::initUi()
 	connect(ui_.log->textWidget(), SIGNAL(quote(const QString &)), ui_.mle->chatEdit(), SLOT(insertAsQuote(const QString &)));
 	
 	ui_.log->realTextWidget()->installEventFilter(this);
+
+#ifdef PSI_PLUGINS
+	PluginManager::instance()->setupChatTab(this, account(), jid().full());
+#endif
 	
 	ui_.mini_prompt->hide();
 
@@ -451,6 +458,14 @@ void PsiChatDlg::updateToolbuttons()
 			continue;
 		}
 
+#ifdef PSI_PLUGINS
+		if (actionName.endsWith("-plugin")) {
+			QString name = PluginManager::instance()->nameByShortName(actionName.mid(0, actionName.length() - 7));
+			PluginManager::instance()->addToolBarButton(this, ui_.toolbar, account(), jid().full(), name);
+			continue;
+		}
+#endif
+
 		// Hack. separator action can be added only once.
 		if (actionName == "separator") {
 			ui_.toolbar->addSeparator();
@@ -925,6 +940,12 @@ void PsiChatDlg::buildMenu()
 
 	pm_settings_->addAction(actions_->action("chat_info"));
 	pm_settings_->addAction(actions_->action("chat_history"));
+#ifdef PSI_PLUGINS
+	if(!PsiOptions::instance()->getOption("options.ui.contactlist.toolbars.m0.visible").toBool()) {
+		pm_settings_->addSeparator();
+		PluginManager::instance()->addToolBarButton(this, pm_settings_, account(), jid().full());
+	}
+#endif
 }
 
 void PsiChatDlg::updateCounter()
--- psi.orig/src/psicon.cpp
+++ psi/src/psicon.cpp
@@ -598,7 +598,7 @@ bool PsiCon::init()
 
 #ifdef PSI_PLUGINS
 	// Plugin Manager
-	PluginManager::instance();
+	PluginManager::instance()->initNewSession(this);
 #endif
 
 	// Global shortcuts
@@ -803,7 +803,9 @@ void PsiCon::deinit()
 	// save profile
 	if(d->contactList)
 		d->saveProfile(acc);
-
+#ifdef PSI_PLUGINS
+	PluginManager::instance()->unloadAllPlugins();
+#endif
 	GlobalShortcutManager::clear();
 
 	DesktopUtil::unsetUrlHandler("xmpp");
@@ -823,6 +825,9 @@ void PsiCon::setShortcuts()
 #ifdef YAPSI
 	ShortcutManager::connect("global.filter-contacts", d->mainwin, SLOT(filterContacts()));
 #endif
+#ifdef PSI_PLUGINS
+	PluginManager::instance()->setShortcuts();
+#endif
 }
 
 PsiContactList* PsiCon::contactList() const
@@ -1325,7 +1330,14 @@ void PsiCon::openUri(const QUrl &uri)
 	// authority
 	PsiAccount *pa = 0;
 	//if (uri.authority().isEmpty()) {
-		pa = d->contactList->defaultAccount();
+		TabbableWidget* tw = findActiveTab();
+		if (tw) {
+			pa = tw->account();
+		}
+		if (!pa) {
+			pa = d->contactList->defaultAccount();
+		}
+
 		if (!pa) {
 			QMessageBox::critical(0, tr("Error"), QString("You need to have an account configured and enabled to open URIs (links)."));
 			return;
--- psi.orig/src/psicontactmenu.cpp
+++ psi/src/psicontactmenu.cpp
@@ -39,6 +39,7 @@
 #include "statusdlg.h"
 #include "xmpp_tasks.h"
 #include "avcall/avcall.h"
+#include "pluginmanager.h"
 #ifdef HAVE_PGPUTIL
 #include "pgputil.h"
 #endif
@@ -455,6 +456,11 @@ public:
 			}
 			menu_->addSeparator();
 			menu_->addAction(sendFileAction_);
+
+#ifdef PSI_PLUGINS
+			PluginManager::instance()->addContactMenu(menu, contact_->account(), contact_->jid().full());
+#endif
+
 			menu_->addMenu(inviteToGroupchatMenu_);
 			menu_->addSeparator();
 			mngMenu_ = menu_->addMenu(IconsetFactory::icon("psi/manageContact").icon(), tr("Manage &Contact"));
--- psi.orig/src/psievent.cpp
+++ psi/src/psievent.cpp
@@ -208,6 +208,49 @@ void PsiEvent::setId(int id)
 }
 #endif
 
+
+#ifdef PSI_PLUGINS
+//----------------------------------------------------------------------------
+// PluginEvent
+//----------------------------------------------------------------------------
+PluginEvent::PluginEvent(const QString& jid, const QString& descr, PsiAccount *acc)
+	: PsiEvent(acc)
+	, descr_(descr)
+{
+	from_ = XMPP::Jid(jid);
+}
+
+PluginEvent::~PluginEvent()
+{
+
+}
+
+int PluginEvent::type() const
+{
+	return Plugin;
+}
+
+XMPP::Jid PluginEvent::from() const
+{
+	return from_;
+}
+
+void PluginEvent::setFrom(const XMPP::Jid &j)
+{
+	from_ = j;
+}
+
+void PluginEvent::activate()
+{
+	emit activated(from_.full());
+}
+
+QString PluginEvent::description() const
+{
+	return descr_;
+}
+#endif
+
 //----------------------------------------------------------------------------
 // MessageEvent
 //----------------------------------------------------------------------------
--- psi.orig/src/psievent.h
+++ psi/src/psievent.h
@@ -64,6 +64,10 @@ public:
 		//Status
 		HttpAuth,
 		AvCallType
+#ifdef PSI_PLUGINS
+		,Plugin
+#endif
+
 	};
 	virtual int type() const = 0;
 
@@ -108,6 +112,32 @@ private:
 #endif
 };
 
+
+#ifdef PSI_PLUGINS
+class PluginEvent : public PsiEvent
+{
+	Q_OBJECT
+public:
+	PluginEvent(const QString& jid, const QString& descr, PsiAccount *acc);
+	~PluginEvent();
+
+	typedef QSharedPointer<PluginEvent> Ptr;
+	int type() const;
+	XMPP::Jid from() const;
+	virtual void setFrom(const XMPP::Jid &j);
+	virtual QString description() const;
+	void activate();
+
+signals:
+	void activated(QString);
+
+private:
+	XMPP::Jid from_;
+	QString descr_;
+};
+#endif
+
+
 // normal, chat, error, headline, etc
 class MessageEvent : public PsiEvent
 {
--- psi.orig/src/psioptions.cpp
+++ psi/src/psioptions.cpp
@@ -31,6 +31,9 @@
 #include "statuspreset.h"
 #include "psitoolbar.h"
 #include "common.h"
+#ifdef PSI_PLUGINS
+#include "pluginmanager.h"
+#endif
 using namespace XMPP;
 
 // ----------------------------------------------------------------------------
@@ -182,6 +185,13 @@ bool PsiOptions::newProfile()
 
 	{
 		QStringList pluginsKeys;
+#ifdef PSI_PLUGINS
+		PluginManager *pm = PluginManager::instance();
+		QStringList plugins = pm->availablePlugins();
+		foreach (const QString &plugin, plugins) {
+			pluginsKeys << pm->shortName(plugin) + "-plugin";
+		}
+#endif
 		ToolbarPrefs chatToolbar;
 		chatToolbar.on = true;
 		chatToolbar.name = "Chat";
--- psi.orig/src/psi_profiles.cpp
+++ psi/src/psi_profiles.cpp
@@ -45,6 +45,9 @@
 #ifdef HAVE_PGPUTIL
 #include "pgputil.h"
 #endif
+#ifdef PSI_PLUGINS
+#include "pluginmanager.h"
+#endif
 
 using namespace XMPP;
 using namespace XMLHelper;
@@ -1361,6 +1364,13 @@ void OptionsMigration::lateMigration()
 	// Add default chat and groupchat toolbars
 	if (PsiOptions::instance()->getOption("options.ui.contactlist.toolbars.m0.name").toString() != "Chat") {
 		QStringList pluginsKeys;
+#ifdef PSI_PLUGINS
+		PluginManager *pm = PluginManager::instance();
+		QStringList plugins = pm->availablePlugins();
+		foreach (const QString &plugin, plugins) {
+			pluginsKeys << pm->shortName(plugin) + "-plugin";
+		}
+#endif
 		ToolbarPrefs chatToolbar;
 		chatToolbar.on = PsiOptions::instance()->getOption("options.ui.chat.central-toolbar").toBool();
 		PsiOptions::instance()->removeOption("options.ui.chat.central-toolbar");
--- psi.orig/src/tabs/tabdlg.cpp
+++ psi/src/tabs/tabdlg.cpp
@@ -921,3 +921,8 @@ void TabDlg::updateVSplitters(int log, i
 		w->setVSplitterPosition(log, chat);
 	}
 }
+
+TabbableWidget* TabDlg::getCurrentTab() const
+{
+	return dynamic_cast<TabbableWidget*>(tabWidget_->currentPage());
+}
--- psi.orig/src/tabs/tabdlg.h
+++ psi/src/tabs/tabdlg.h
@@ -88,6 +88,7 @@ public:
 	void setTabBarShownForSingles(bool enabled); // default enabled
 	void setSimplifiedCaptionEnabled(bool enabled); // default disabled
 	void setTabIcon(QWidget *,const QIcon &);
+	TabbableWidget* getCurrentTab() const;
 
 protected:
 	void setShortcuts();
