--- psi.orig/options/default.xml
+++ psi/options/default.xml
@@ -297,6 +297,21 @@ QLineEdit#le_status_text {
 			</menu>
 			<muc comment="Multi-User Chat options">
 				<hide-on-autojoin type="bool">false</hide-on-autojoin>
+				<userlist comment="Userlist options">
+					<show-groups type="bool">true</show-groups>
+					<use-slim-group-headings type="bool">false</use-slim-group-headings>
+					<nick-coloring type = "bool">true</nick-coloring>
+					<show-client-icons type = "bool">true</show-client-icons>
+					<show-affiliation-icons type = "bool">true</show-affiliation-icons>
+					<contact-sort-style type = "QString">alpha</contact-sort-style>
+					<show-status-icons type = "bool">true</show-status-icons>
+					<avatars>
+						<show type="bool">false</show>
+						<size type="int">24</size>
+						<avatars-at-left type="bool">true</avatars-at-left>
+						<radius type="int">3</radius>
+					</avatars>
+				</userlist>
 				<status-with-priority comment="Show priority with status change" type="bool">false</status-with-priority>
 				<show-initial-joins comment="Show joins on your MUC join (with status and priority, depends on options)" type="bool">false</show-initial-joins>
 				<log-width type="int">500</log-width>
@@ -373,6 +388,10 @@ QLineEdit#le_status_text {
 							<item>Purple</item>
 							<item>Red</item>
 						</nick-colors>
+						<role-moderator type="QColor">#910000</role-moderator>
+						<role-participant type="QColor">#00008a</role-participant>
+						<role-visitor type="QColor">#336600</role-visitor>
+						<role-norole type="QColor">black</role-norole>
 					</muc>
 					<messages comment="Message coloring.">
 						<received type="QColor" comment="Color used to indicate received messages.">#0000ff</received>
--- psi.orig/src/avatars.cpp
+++ psi/src/avatars.cpp
@@ -42,6 +42,7 @@
 #include "xmpp_client.h"
 #include "xmpp_resource.h"
 #include "xmpp_pubsubitem.h"
+#include "xmpp_tasks.h"
 #include "avatars.h"
 #include "applicationinfo.h"
 #include "psiaccount.h"
@@ -275,7 +276,7 @@ protected:
 	void avatarUpdated() 
 		{ emit avatarChanged(jid_); }
 
-private:
+protected:
 	Jid jid_;
 };
 
@@ -303,6 +304,48 @@ void VCardAvatar::receivedVCard()
 //------------------------------------------------------------------------------
 
 //------------------------------------------------------------------------------
+// VCardMucAvatar: Avatars coming from VCards of MUC contacts.
+//------------------------------------------------------------------------------
+
+class VCardMucAvatar : public VCardAvatar
+{
+	Q_OBJECT
+
+public:
+	VCardMucAvatar(AvatarFactory* factory, const Jid& jid);
+
+public slots:
+	virtual void receivedVCard();
+
+protected:
+	virtual void requestAvatar();
+};
+
+
+VCardMucAvatar::VCardMucAvatar(AvatarFactory* factory, const Jid& jid)
+	: VCardAvatar(factory, jid)
+{
+}
+
+void VCardMucAvatar::requestAvatar()
+{
+	VCardFactory::instance()->getVCard(jid_.full(), factory()->account()->client()->rootTask(), this, SLOT(receivedVCard()), false);
+}
+
+void VCardMucAvatar::receivedVCard()
+{
+	JT_VCard* task = static_cast<JT_VCard*>(sender());
+	const VCard vcard = task->vcard();
+	if (!vcard.isEmpty()) {
+		saveToCache(vcard.photo());
+		setImage(vcard.photo());
+		emit avatarChanged(jid_);
+	}
+}
+
+//------------------------------------------------------------------------------
+
+//------------------------------------------------------------------------------
 // VCardStaticAvatar: VCard static photo avatar (not published through presence)
 //------------------------------------------------------------------------------
 
@@ -505,6 +548,25 @@ QPixmap AvatarFactory::getAvatar(const J
 	return pm;
 }
 
+QPixmap AvatarFactory::getMucAvatar(const Jid& _jid)
+{
+	Jid jid = _jid;
+	Avatar* av = 0;
+	if (muc_vcard_avatars_.contains(jid.full()) && !muc_vcard_avatars_[jid.full()]->isEmpty()) {
+		av = muc_vcard_avatars_[jid.full()];
+	}
+
+	QPixmap pm = (av ? av->getPixmap() : QPixmap());	
+	pm = ensureSquareAvatar(pm);
+
+	// Update iconset
+	PsiIcon icon;
+	icon.setImpix(pm);
+	iconset_.setIcon(QString("avatars/%1").arg(jid.full()),icon);
+
+	return pm;
+}
+
 Avatar* AvatarFactory::retrieveAvatar(const Jid& jid)
 {
 	//printf("Retrieving avatar of %s\n", jid.full().latin1());
@@ -577,6 +639,12 @@ void AvatarFactory::updateAvatar(const J
 	emit avatarChanged(j);
 }
 
+void AvatarFactory::updateMucAvatar(const Jid &j)
+{
+	getMucAvatar(j);
+	emit avatarChanged(j);
+}
+
 void AvatarFactory::importManualAvatar(const Jid& j, const QString& fileName)
 {
 	FileAvatar(this, j).import(fileName);
@@ -609,6 +677,18 @@ void AvatarFactory::resourceAvailable(co
 	}
 }
 
+void AvatarFactory::newMucItem(const Jid &fullJid, const Status &s)
+{
+	if (s.hasPhotoHash()) {
+		const QString hash = s.photoHash();
+		if (!muc_vcard_avatars_.contains(fullJid.full())) {
+			muc_vcard_avatars_[fullJid.full()] = new VCardMucAvatar(this, fullJid);
+			connect(muc_vcard_avatars_[fullJid.full()], SIGNAL(avatarChanged(const Jid&)), this, SLOT(updateMucAvatar(const Jid&)));
+		}
+		muc_vcard_avatars_[fullJid.full()]->updateHash(hash);
+	}
+}
+
 QString AvatarFactory::getManualDir()
 {
 	QDir avatars(pathToProfile(activeProfile, ApplicationInfo::DataLocation) + "/pictures");
@@ -634,6 +714,37 @@ int AvatarFactory::maxAvatarSize()
 	return MAX_AVATAR_SIZE;
 }
 
+QPixmap AvatarFactory::roundedAvatar(const QPixmap &pix, int rad, int avSize)
+{
+	QPixmap avatar_icon;
+	QPixmap av = pix;
+	if(!pix.isNull()) {
+		if (avSize != 0) {
+			if (rad != 0) {
+				avSize = qMax(avSize, rad*2);
+				av = av.scaled(avSize, avSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);
+				int w = av.width(), h = av.height();
+				QPainterPath pp;
+				pp.addRoundedRect(0, 0, w, h, rad, rad);
+				avatar_icon = QPixmap(w, h);
+				avatar_icon.fill(QColor(0,0,0,0));
+				QPainter mp(&avatar_icon);
+				mp.setBackgroundMode(Qt::TransparentMode);
+				mp.setRenderHints(QPainter::Antialiasing, true);
+				mp.fillPath(pp, QBrush(av));
+			}
+			else {
+				avatar_icon = av.scaled(avSize, avSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);
+			}
+		}
+		else {
+			avatar_icon = QPixmap();
+		}
+	}
+
+	return avatar_icon;
+}
+
 void AvatarFactory::itemPublished(const Jid& jid, const QString& n, const PubSubItem& item)
 {
 	if (n == PEP_AVATAR_DATA_NS) {
--- psi.orig/src/avatars.h
+++ psi/src/avatars.h
@@ -37,6 +37,7 @@
 class PsiAccount;
 class Avatar;
 class VCardAvatar;
+class VCardMucAvatar;
 class VCardStaticAvatar;
 class FileAvatar;
 class PEPAvatar;
@@ -45,6 +46,7 @@ namespace XMPP {
 	class Jid;
 	class Resource;
 	class PubSubItem;
+	class Status;
 }
 
 using namespace XMPP;
@@ -65,16 +67,21 @@ public:
 	void importManualAvatar(const Jid& j, const QString& fileName);
 	void removeManualAvatar(const Jid& j);
 	bool hasManualAvatar(const Jid& j);
+
+	void newMucItem(const Jid& fullJid, const Status& s);
+	QPixmap getMucAvatar(const Jid& jid);
 	
 	static QString getManualDir();
 	static QString getCacheDir();
 	static int maxAvatarSize();
+	static QPixmap roundedAvatar(const QPixmap& pix, int rad, int avatarSize);
 
 signals:
 	void avatarChanged(const Jid&);
 
 public slots:
 	void updateAvatar(const Jid&);
+	void updateMucAvatar(const Jid&);
 
 protected slots:
 	void itemPublished(const Jid&, const QString&, const PubSubItem&);
@@ -92,6 +99,7 @@ private:
 	QMap<QString,PEPAvatar*> pep_avatars_;
 	QMap<QString,FileAvatar*> file_avatars_;
 	QMap<QString,VCardAvatar*> vcard_avatars_;
+	QMap<QString,VCardMucAvatar*> muc_vcard_avatars_;
 	QMap<QString,VCardStaticAvatar*> vcard_static_avatars_;
 	PsiAccount* pa_;
 	Iconset iconset_;
--- psi.orig/src/contactlistmodel.cpp
+++ psi/src/contactlistmodel.cpp
@@ -536,7 +536,9 @@ QVariant ContactListModel::contactData(c
 		return QVariant(contact->userListItem().clients());
 	}
 	else if (role == AvatarRole) {
-		QPixmap pix = contact->account()->avatarFactory()->getAvatar(contact->jid());
+		QPixmap pix = contact->isPrivate() ?
+			      contact->account()->avatarFactory()->getMucAvatar(contact->jid()) :
+			      contact->account()->avatarFactory()->getAvatar(contact->jid());
 		return QVariant(pix);
 	}
 	else if (role == IsMucRole) {
--- psi.orig/src/gcuserview.cpp
+++ psi/src/gcuserview.cpp
@@ -36,6 +36,8 @@
 #include "psioptions.h"
 #include "coloropt.h"
 #include "avcall/avcall.h"
+#include "xmpp_muc.h"
+#include "avatars.h"
 
 static bool caseInsensitiveLessThan(const QString &s1, const QString &s2)
 {
@@ -53,6 +55,31 @@ public:
 	GCUserViewDelegate(QObject* p)
 		: QItemDelegate(p)
 	{
+		updateSettings();
+	}
+
+	void updateSettings()
+	{
+		colorForeground_ = ColorOpt::instance()->color("options.ui.look.colors.contactlist.grouping.header-foreground");
+		colorBackground_ = ColorOpt::instance()->color("options.ui.look.colors.contactlist.grouping.header-background");
+		colorModerator_ = PsiOptions::instance()->getOption("options.ui.look.colors.muc.role-moderator").value<QColor>();
+		colorParticipant_ = PsiOptions::instance()->getOption("options.ui.look.colors.muc.role-participant").value<QColor>();
+		colorVisitor_ = PsiOptions::instance()->getOption("options.ui.look.colors.muc.role-visitor").value<QColor>();
+		colorNoRole_ = PsiOptions::instance()->getOption("options.ui.look.colors.muc.role-norole").value<QColor>();
+		showGroups_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.show-groups").toBool();
+		slimGroups_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.use-slim-group-headings").toBool();
+		nickColoring_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.nick-coloring").toBool();
+		showClients_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.show-client-icons").toBool();
+		showAffiliations_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.show-affiliation-icons").toBool();
+		showStatusIcons_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.show-status-icons").toBool();
+		showAvatar_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.avatars.show").toBool();
+		avatarSize_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.avatars.size").toInt();
+		avatarAtLeft_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.avatars.avatars-at-left").toBool();
+		avatarRadius_ = PsiOptions::instance()->getOption("options.ui.muc.userlist.avatars.radius").toInt();
+
+		QFont font;
+		font.fromString(PsiOptions::instance()->getOption("options.ui.look.font.contactlist").toString());
+		fontHeight_ = QFontMetrics(font).height()+2;
 	}
 
 	void paint(QPainter* mp, const QStyleOptionViewItem& option, const QModelIndex& index) const
@@ -65,52 +91,204 @@ public:
 				paintGroup(mp, option, gi);
 			}
 			else {
-				paintContact(mp, option, index);
+				paintContact(mp, option, index, (GCUserViewItem*)i);
 			}
 		}
 	}
 
 	void paintGroup(QPainter* p, const QStyleOptionViewItem& o, GCUserViewGroupItem* gi) const
 	{
+		if(!showGroups_)
+			return;
+
-		bool slimGroups = PsiOptions::instance()->getOption("options.ui.look.contactlist.use-slim-group-headings").toBool();
 		QRect rect = o.rect;
 		QFont f = o.font;
-		f.setPointSize(common_smallFontSize);
 		p->setFont(f);
-		QColor colorForeground = ColorOpt::instance()->color("options.ui.look.colors.contactlist.grouping.header-foreground");
-		QColor colorBackground = ColorOpt::instance()->color("options.ui.look.colors.contactlist.grouping.header-background");
-		if (!slimGroups || (o.state & QStyle::State_Selected) ) {
-			p->fillRect(rect, colorBackground);
+		if (!slimGroups_ || (o.state & QStyle::State_Selected) ) {
+			p->fillRect(rect, colorBackground_);
 		}
 
-		p->setPen(QPen(colorForeground));
+		p->setPen(QPen(colorForeground_));
 		rect.translate(2, (rect.height() - o.fontMetrics.height())/2);
 		p->drawText(rect, gi->text(0));
-		if (slimGroups	&& !(o.state & QStyle::State_Selected))
+		if (slimGroups_	&& !(o.state & QStyle::State_Selected))
 		{
 			QFontMetrics fm(f);
 			int x = fm.width(gi->text(0)) + 8;
 			int width = rect.width();
 			if(x < width - 8) {
 				int h = rect.y() + (rect.height() / 2) - 1;
-				p->setPen(QPen(colorBackground));
+				p->setPen(QPen(colorBackground_));
 				p->drawLine(x, h, width - 8, h);
 				h++;
-				p->setPen(QPen(colorForeground));
+				p->setPen(QPen(colorForeground_));
 				p->drawLine(x, h, width - 8, h);
 			}
 		}
 	}
 
-	void paintContact(QPainter* mp, const QStyleOptionViewItem& option, const QModelIndex& index) const
+	void paintContact(QPainter* mp, const QStyleOptionViewItem& option, const QModelIndex& index, GCUserViewItem* item) const
 	{
-		QItemDelegate::paint(mp, option, index);
+		mp->save();
+		QStyleOptionViewItem o = option;
+		QPalette palette = o.palette;
+		MUCItem::Role r = item->s.mucItem().role();
+		QRect rect = o.rect;
+
+		if(nickColoring_) {
+			if(r == MUCItem::Moderator)
+				palette.setColor(QPalette::Text, colorModerator_);
+			else if(r == MUCItem::Participant)
+				palette.setColor(QPalette::Text, colorParticipant_);
+			else if(r == MUCItem::Visitor)
+				palette.setColor(QPalette::Text, colorVisitor_);
+			else
+				palette.setColor(QPalette::Text, colorNoRole_);
+		}
+
+		mp->fillRect(rect, (o.state & QStyle::State_Selected) ? palette.color(QPalette::Highlight) : palette.color(QPalette::Base));
+
+		if(showAvatar_) {
+			QPixmap ava = item->avatar();
+			if(ava.isNull()) {
+				ava = IconsetFactory::iconPixmap("psi/default_avatar");
+			}
+			ava = AvatarFactory::roundedAvatar(ava, avatarRadius_, avatarSize_);
+			QRect avaRect(rect);
+			avaRect.setWidth(ava.width());
+			avaRect.setHeight(ava.height());
+			if(!avatarAtLeft_) {
+				avaRect.moveTopRight(rect.topRight());
+				avaRect.translate(-1, 1);
+				rect.setRight(avaRect.left() - 1);
+			}
+			else {
+				avaRect.translate(1, 1);
+				rect.setLeft(avaRect.right() + 1);
+			}
+			mp->drawPixmap(avaRect, ava);
+		}
+
+		QPixmap status = showStatusIcons_ ? item->icon() : QPixmap();
+		int h = rect.height();
+		int sh = status.isNull() ? 0 : status.height();
+		rect.setHeight(qMax(sh, fontHeight_));
+		rect.moveTop(rect.top() + (h - rect.height())/2);
+		if(!status.isNull()) {
+			QRect statusRect(rect);
+			statusRect.setWidth(status.width());
+			statusRect.setHeight(status.height());
+			statusRect.translate(1, 1);
+			mp->drawPixmap(statusRect, status);
+			rect.setLeft(statusRect.right() + 2);
+		}
+		else
+			rect.setLeft(rect.left() + 2);
+
+		mp->setPen(QPen((o.state & QStyle::State_Selected) ? palette.color(QPalette::HighlightedText) : palette.color(QPalette::Text)));
+		mp->setFont(o.font);
+		mp->setClipRect(rect);
+		QTextOption to;
+		to.setWrapMode(QTextOption::NoWrap);
+		mp->drawText(rect, index.data(Qt::DisplayRole).toString(), to);
+
+		QList<QPixmap> rightPixs;
+		if(showClients_) {
+			GCUserView *gcuv = (GCUserView*)item->treeWidget();
+			GCMainDlg* dlg = gcuv->mainDlg();
+			QPixmap clientPix;
+			if(dlg) {
+				UserListItem u;
+				const QString &nick = item->text(0);
+				Jid caps_jid(/*s.mucItem().jid().isEmpty() ? */ dlg->jid().withResource(nick) /* : s.mucItem().jid()*/);
+				QString client_name = dlg->account()->capsManager()->clientName(caps_jid);
+				QString client_version = (client_name.isEmpty() ? QString() : dlg->account()->capsManager()->clientVersion(caps_jid));
+				UserResource ur;
+				ur.setClient(client_name,client_version,"");
+				u.userResourceList().append(ur);
+				QStringList clients = u.clients();
+				if(!clients.isEmpty())
+					clientPix = IconsetFactory::iconPixmap("clients/" + clients.takeFirst());
+			}
+			if(!clientPix.isNull())
+				rightPixs.push_back(clientPix);
+		}
+
+		if(showAffiliations_) {
+			MUCItem::Affiliation a = item->s.mucItem().affiliation();
+			QPixmap pix;
+			if(a == MUCItem::Owner)
+				pix = IconsetFactory::iconPixmap("affiliation/owner");
+			else if(a == MUCItem::Admin)
+				pix = IconsetFactory::iconPixmap("affiliation/admin");
+			else if(a == MUCItem::Member)
+				pix = IconsetFactory::iconPixmap("affiliation/member");
+			else if(a == MUCItem::Outcast)
+				pix = IconsetFactory::iconPixmap("affiliation/outcast");
+			else
+				pix = IconsetFactory::iconPixmap("affiliation/noaffiliation");
+			if(!pix.isNull())
+				rightPixs.push_back(pix);
+		}
+
+		mp->restore();
+
+		if(rightPixs.isEmpty())
+			return;
+
+		int sumWidth = 0;
+		foreach (const QPixmap& pix, rightPixs) {
+				sumWidth += pix.width();
+		}
+		sumWidth += rightPixs.count();
+
+		QColor bgc = (option.state & QStyle::State_Selected) ? palette.color(QPalette::Highlight) : palette.color(QPalette::Base);
+		QColor tbgc = bgc;
+		tbgc.setAlpha(0);
+		QLinearGradient grad(rect.right() - sumWidth - 20, 0, rect.right() - sumWidth, 0);
+		grad.setColorAt(0, tbgc);
+		grad.setColorAt(1, bgc);
+		QBrush tbakBr(grad);
+		QRect gradRect(rect);
+		gradRect.setLeft(gradRect.right() - sumWidth - 20);
+		mp->fillRect(gradRect, tbakBr);
+
+		QRect iconRect(rect);
+		for (int i=0; i<rightPixs.size(); i++) {
+			const QPixmap pix = rightPixs[i];
+			iconRect.setRight(iconRect.right() - pix.width() -1);
+			mp->drawPixmap(iconRect.topRight(), pix);
+		}
+
 	}
 
 	QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const
 	{
-		return QItemDelegate::sizeHint(option, index);
+		if(!index.isValid())
+			return QSize(0,0);
+
+		QSize size = QItemDelegate::sizeHint(option, index);
+		GCUserView *uv = static_cast<GCUserView*>(parent());
+		if(uv) {
+			QTreeWidgetItem *i = uv->findEntry(index);
+			GCUserViewItem *vi = dynamic_cast<GCUserViewItem*>(i);
+			if(vi) {
+				int rowH = qMax(fontHeight_, vi->icon().height() + 2);
+				int h = showAvatar_ ? qMax(avatarSize_ + 2, rowH) : rowH;
+				size.setHeight(h);
+			}
+			else {
+				size.setHeight(showGroups_ ? fontHeight_ : 0);
+			}
+		}
+
+		return size;
 	}
+
+private:
+	QColor colorForeground_, colorBackground_, colorModerator_, colorParticipant_, colorVisitor_, colorNoRole_;
+	bool showGroups_, slimGroups_, nickColoring_, showClients_, showAffiliations_, showStatusIcons_, showAvatar_, avatarAtLeft_;
+	int avatarSize_, fontHeight_, avatarRadius_;
 };
 
 
@@ -123,10 +303,21 @@ GCUserViewItem::GCUserViewItem(GCUserVie
 {
 }
 
+void GCUserViewItem::setAvatar(const QPixmap &pix)
+{
+	avatar_ = pix;
+	treeWidget()->viewport()->update();
+}
+
+void GCUserViewItem::setIcon(const QPixmap &icon)
+{
+	icon_ = icon;
+}
+
 bool GCUserViewItem::operator<(const QTreeWidgetItem& it) const
 {	
 	GCUserViewItem *item = (GCUserViewItem*)(&it);
-	if(PsiOptions::instance()->getOption("options.ui.contactlist.contact-sort-style").toString() == "status") {
+	if(PsiOptions::instance()->getOption("options.ui.muc.userlist.contact-sort-style").toString() == "status") {
 		int rank = rankStatus(s.type()) - rankStatus(item->s.type());
 		if (rank == 0)
 			rank = QString::localeAwareCompare(text(0).toLower(), it.text(0).toLower());
@@ -220,7 +412,7 @@ void GCUserView::updateAll()
 		int count = j->childCount();
 		for(int num = 0; num < count; num++) {
 			GCUserViewItem *i = (GCUserViewItem*)j->child(num);
-			i->setIcon(0, PsiIconset::instance()->status(i->s).icon());
+			i->setIcon(PsiIconset::instance()->status(i->s).pixmap());
 		}
 		j->sortChildren(0, Qt::AscendingOrder);
 	}
@@ -300,7 +492,7 @@ void GCUserView::updateEntry(const QStri
 	}
 
 	lvi->s = s;
-	lvi->setIcon(0, PsiIconset::instance()->status(lvi->s).icon());
+	lvi->setIcon(PsiIconset::instance()->status(lvi->s).pixmap());
 	gr->sortChildren(0, Qt::AscendingOrder);
 }
 
@@ -365,6 +557,8 @@ bool GCUserView::maybeTip(const QPoint &
 	ur.setClient(client_name,client_version,"");
 	//ur.setClient(QString(),QString(),"");
 	u.userResourceList().append(ur);
+	u.setPrivate(true);
+	u.setAvatarFactory(dlg->account()->avatarFactory());
 
 	PsiToolTip::showText(mapToGlobal(pos), u.makeTip(), this);
 	return true;
@@ -569,4 +763,10 @@ void GCUserView::mousePressEvent(QMouseE
 		contextMenuRequested(event->pos());
 }
 
+void GCUserView::setLooks()
+{
+	((GCUserViewDelegate*)itemDelegate())->updateSettings();
+	viewport()->update();
+}
+
 #include "gcuserview.moc"
--- psi.orig/src/gcuserview.h
+++ psi/src/gcuserview.h
@@ -39,10 +39,18 @@ class GCUserViewItem : public QObject, p
 {
 public:
 	GCUserViewItem(GCUserViewGroupItem *);
+	void setAvatar(const QPixmap& pix);
+	QPixmap avatar() const { return avatar_; };
+	void setIcon(const QPixmap &icon);
+	QPixmap icon() const { return icon_; };
 
 	Status s;
 
 	virtual bool operator<  (const QTreeWidgetItem& it) const;
+
+private:
+	QPixmap avatar_;
+	QPixmap icon_;
 };
 
 class GCUserViewGroupItem : public QTreeWidgetItem
@@ -66,6 +74,7 @@ public:
 	~GCUserView();
 
 	void setMainDlg(GCMainDlg* mainDlg);
+	GCMainDlg* mainDlg() const { return gcDlg_; };
 	virtual QMimeData* mimeData(const QList<QTreeWidgetItem*>items) const;
 	void clear();
 	void updateAll();
@@ -76,6 +85,7 @@ public:
 	void removeEntry(const QString &);
 	QStringList nickList() const;
 	void doContextMenu(QTreeWidgetItem* it);
+	void setLooks();
 
 protected:
 	enum Role { Moderator = 0, Participant = 1, Visitor = 2 };
--- psi.orig/src/groupchatdlg.cpp
+++ psi/src/groupchatdlg.cpp
@@ -86,6 +86,7 @@
 #include "lastactivitytask.h"
 #include "psirichtext.h"
 #include "psiwindowheader.h"
+#include "avatars.h"
 
 #include "mcmdsimplesite.h"
 
@@ -817,6 +818,7 @@ GCMainDlg::GCMainDlg(PsiAccount *pa, con
 
 	// Connect signals from MUC manager
 	connect(d->mucManager,SIGNAL(action_error(MUCManager::Action, int, const QString&)), SLOT(action_error(MUCManager::Action, int, const QString&)));
+	connect(d->mucManager, SIGNAL(action_success(MUCManager::Action)), ui_.lv_users, SLOT(update()));
 
 	setLooks();
 	setShortcuts();
@@ -825,6 +827,8 @@ GCMainDlg::GCMainDlg(PsiAccount *pa, con
 	connect(URLObject::getInstance(), SIGNAL(vcardsig(QString)), SLOT(vcard(QString)));
 
 	connect(ui_.log->textWidget(), SIGNAL(quote(const QString &)), ui_.mle->chatEdit(), SLOT(insertAsQuote(const QString &)));
+
+	connect(pa->avatarFactory(), SIGNAL(avatarChanged(Jid)), SLOT(avatarUpdated(Jid)));
 }
 
 void GCMainDlg::vcard(const QString& _str)
@@ -1485,6 +1489,8 @@ void GCMainDlg::presence(const QString &
 			}
 		}
 		ui_.lv_users->updateEntry(nick, s);
+		if(!nick.isEmpty())
+			avatarUpdated(jidForNick(nick));
 	} 
 	else {
 		// Unavailable
@@ -1579,6 +1585,22 @@ void GCMainDlg::presence(const QString &
 		account()->capsManager()->updateCaps(caps_jid,s.capsNode(),s.capsVersion(),s.capsExt());
 	}
 
+	if(!nick.isEmpty())
+		account()->avatarFactory()->newMucItem(jidForNick(nick), s);
+}
+
+XMPP::Jid GCMainDlg::jidForNick(const QString &nick) const
+{
+	return Jid(jid()).withResource(nick);
+}
+
+void GCMainDlg::avatarUpdated(const Jid &jid_)
+{
+	if(jid_.compare(jid(), false)) {
+		GCUserViewItem *it = dynamic_cast<GCUserViewItem*>(ui_.lv_users->findEntry(jid_.resource()));
+		if(it)
+			it->setAvatar(account()->avatarFactory()->getMucAvatar(jid_));
+	}
 }
 
 void GCMainDlg::message(const Message &_m)
@@ -1841,6 +1863,8 @@ void GCMainDlg::setLooks()
 #ifndef Q_WS_MAC
 	setWindowIcon(IconsetFactory::icon("psi/groupChat").icon());
 #endif
+
+	ui_.lv_users->setLooks();
 }
 
 void GCMainDlg::optionsUpdate()
--- psi.orig/src/groupchatdlg.h
+++ psi/src/groupchatdlg.h
@@ -147,6 +147,7 @@ private slots:
 	void horizSplitterMoved();
 	void verticalSplitterMoved(int, int);
 	void doMinimize();
+	void avatarUpdated(const Jid& jid);
 
 
 
@@ -173,6 +174,7 @@ private:
 	QDateTime lastMsgTime_;
 
 	void setMargins();
+	inline XMPP::Jid jidForNick(const QString &nick) const;
 };
 
 class GCFindDlg : public QDialog
--- psi.orig/src/options/opt_appearance.cpp
+++ psi/src/options/opt_appearance.cpp
@@ -99,6 +99,7 @@ OptionsTabIconset::OptionsTabIconset(QOb
 	addTab( new OptionsTabIconsetClients(this) );
 	addTab( new OptionsTabIconsetRoster(this) );
 	addTab( new OptionsTabIconsetSystem(this) );
+	addTab( new OptionsTabIconsetAffiliations(this) );
 }
 
 
--- psi.orig/src/options/opt_iconset_affiliation.ui
+++ psi/src/options/opt_iconset_affiliation.ui
@@ -0,0 +1,88 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>IconsetAffiliation</class>
+ <widget class="QWidget" name="IconsetAffiliation">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>256</width>
+    <height>195</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>IconsetClientUI</string>
+  </property>
+  <layout class="QVBoxLayout">
+   <property name="spacing">
+    <number>6</number>
+   </property>
+   <property name="margin">
+    <number>9</number>
+   </property>
+   <item>
+    <widget class="QGroupBox" name="groupBox10">
+     <property name="title">
+      <string>Affiliation iconsets</string>
+     </property>
+     <layout class="QGridLayout">
+      <property name="margin">
+       <number>8</number>
+      </property>
+      <property name="spacing">
+       <number>6</number>
+      </property>
+      <item row="1" column="2">
+       <spacer>
+        <property name="orientation">
+         <enum>Qt::Horizontal</enum>
+        </property>
+        <property name="sizeType">
+         <enum>QSizePolicy::Expanding</enum>
+        </property>
+        <property name="sizeHint" stdset="0">
+         <size>
+          <width>204</width>
+          <height>20</height>
+         </size>
+        </property>
+       </spacer>
+      </item>
+      <item row="1" column="3">
+       <widget class="IconButton" name="pb_affiliationDetails" native="true">
+        <property name="text" stdset="0">
+         <string>&amp;Show Details</string>
+        </property>
+       </widget>
+      </item>
+      <item row="0" column="0" colspan="4">
+       <widget class="IconsetSelect" name="iss_affiliation" native="true"/>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <widget class="QProgressBar" name="progress">
+     <property name="orientation">
+      <enum>Qt::Horizontal</enum>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <layoutdefault spacing="6" margin="11"/>
+ <customwidgets>
+  <customwidget>
+   <class>IconButton</class>
+   <extends></extends>
+   <header>iconbutton.h</header>
+  </customwidget>
+  <customwidget>
+   <class>IconsetSelect</class>
+   <extends></extends>
+   <header>iconsetselect.h</header>
+  </customwidget>
+ </customwidgets>
+ <resources/>
+ <connections/>
+</ui>
--- psi.orig/src/options/opt_iconset.cpp
+++ psi/src/options/opt_iconset.cpp
@@ -28,6 +28,7 @@
 #include "ui_opt_iconset_client.h"
 #include "ui_opt_iconset_system.h"
 #include "ui_opt_iconset_roster.h"
+#include "ui_opt_iconset_affiliation.h"
 #include "ui_ui_isdetails.h"
 
 class IconsetEmoUI : public QWidget, public Ui::IconsetEmo
@@ -60,6 +61,12 @@ public:
 	IconsetSystemUI() : QWidget() { setupUi(this); }
 };
 
+class IconsetAffiliationUI : public QWidget, public Ui::IconsetAffiliation
+{
+  public:
+    IconsetAffiliationUI() : QWidget() { setupUi(this); }
+};
+
 class IconsetRosterUI : public QWidget, public Ui::IconsetRoster
 {
 public:
@@ -963,6 +970,153 @@ void OptionsTabIconsetActivity::cancelTh
 		thread = 0;
 	}
 }
+//----------------------------------------------------------------------------
+// OptionsTabIconsetAffiliations
+//----------------------------------------------------------------------------
+
+OptionsTabIconsetAffiliations::OptionsTabIconsetAffiliations(QObject *parent)
+	: OptionsTab(parent, "iconset_affiliations", "", tr("Affiliations"), tr("Select your affiliations iconset"))
+	, w(0)
+	, thread(0)
+{
+}
+
+OptionsTabIconsetAffiliations::~OptionsTabIconsetAffiliations()
+{
+	cancelThread();
+}
+
+QWidget *OptionsTabIconsetAffiliations::widget()
+{
+	if ( w )
+		return 0;
+
+	w = new IconsetAffiliationUI;
+	IconsetAffiliationUI *d = (IconsetAffiliationUI *)w;
+
+	connect(d->pb_affiliationDetails, SIGNAL(clicked()), SLOT(previewIconset()));
+
+	return w;
+}
+
+void OptionsTabIconsetAffiliations::applyOptions()
+{
+	if ( !w || thread )
+		return;
+
+	IconsetAffiliationUI *d = (IconsetAffiliationUI *)w;
+
+	const Iconset *is = d->iss_affiliation->iconset();
+	if ( is ) {
+		QFileInfo fi( is->fileName() );
+		PsiOptions::instance()->setOption("options.iconsets.affiliations", fi.fileName());
+	}
+}
+
+void OptionsTabIconsetAffiliations::restoreOptions()
+{
+	if ( !w || thread )
+		return;
+
+	IconsetAffiliationUI *d = (IconsetAffiliationUI *)w;
+
+	d->iss_affiliation->clear();
+	QStringList loaded;
+
+	d->setCursor(Qt::WaitCursor);
+
+	QPalette customPal = d->palette();
+	customPal.setCurrentColorGroup(QPalette::Inactive);
+	d->iss_affiliation->setEnabled(false);
+	d->iss_affiliation->setPalette(customPal);
+
+	d->pb_affiliationDetails->setEnabled(false);
+	d->pb_affiliationDetails->setPalette(customPal);
+
+	d->progress->show();
+	d->progress->setValue( 0 );
+
+	numIconsets = countIconsets("/affiliations", loaded);
+	iconsetsLoaded = 0;
+
+	cancelThread();
+
+	thread = new IconsetLoadThread(this, "/affiliations");
+	thread->start();
+}
+
+bool OptionsTabIconsetAffiliations::event(QEvent *e)
+{
+	IconsetAffiliationUI *d = (IconsetAffiliationUI *)w;
+	if ( e->type() == QEvent::User ) { // iconset load event
+		IconsetLoadEvent *le = (IconsetLoadEvent *)e;
+
+		if ( thread != le->thread() )
+			return false;
+
+		if ( !numIconsets )
+			numIconsets = 1;
+		d->progress->setValue( (int)((float)100 * ++iconsetsLoaded / numIconsets) );
+
+		Iconset *i = le->iconset();
+		if ( i ) {
+			PsiIconset::instance()->stripFirstAnimFrame(i);
+			d->iss_affiliation->insert(*i);
+
+			QFileInfo fi( i->fileName() );
+			if ( fi.fileName() == PsiOptions::instance()->getOption("options.iconsets.affiliations").toString() )
+				d->iss_affiliation->setItemSelected(d->iss_affiliation->lastItem(), true);
+
+			delete i;
+		}
+
+		return true;
+	}
+	else if ( e->type() == QEvent::User + 1 ) { // finish event
+		d->iss_affiliation->setEnabled(true);
+		d->iss_affiliation->setPalette(QPalette());
+
+		d->pb_affiliationDetails->setEnabled(true);
+		d->pb_affiliationDetails->setPalette(QPalette());
+
+		connect(d->iss_affiliation, SIGNAL(currentItemChanged(QListWidgetItem*, QListWidgetItem*)), SIGNAL(dataChanged()));
+
+		d->progress->hide();
+
+		d->unsetCursor();
+		thread = 0;
+
+		return true;
+	}
+
+	return false;
+}
+
+void OptionsTabIconsetAffiliations::previewIconset()
+{
+	IconsetAffiliationUI *d = (IconsetAffiliationUI *)w;
+	const Iconset *is = d->iss_affiliation->iconset();
+	if (is) {
+		isDetails(*is, parentWidget->parentWidget(), psi);
+	}
+}
+
+void OptionsTabIconsetAffiliations::setData(PsiCon *psicon, QWidget *p)
+{
+	psi = psicon;
+	parentWidget = p;
+}
+
+void OptionsTabIconsetAffiliations::cancelThread()
+{
+	if ( thread ) {
+		threadCancelled.lock();
+		thread->cancelled = true;
+		threadCancelled.unlock();
+
+		thread = 0;
+	}
+}
 
 //----------------------------------------------------------------------------
 // OptionsTabIconsetClients
--- psi.orig/src/options/opt_iconset.h
+++ psi/src/options/opt_iconset.h
@@ -149,6 +149,34 @@ private:
 	IconsetLoadThread *thread;
 };
 
+class OptionsTabIconsetAffiliations : public OptionsTab
+{
+	Q_OBJECT
+public:
+	OptionsTabIconsetAffiliations(QObject *parent);
+	~OptionsTabIconsetAffiliations();
+
+	QWidget *widget();
+	void applyOptions();
+	void restoreOptions();
+	bool stretchable() const { return true; }
+
+private slots:
+	void setData(PsiCon *, QWidget *);
+	void previewIconset();
+
+protected:
+	bool event(QEvent *);
+	void cancelThread();
+
+private:
+	QWidget *w, *parentWidget;
+	PsiCon *psi;
+
+	int numIconsets, iconsetsLoaded;
+	IconsetLoadThread *thread;
+};
+
 class OptionsTabIconsetRoster : public OptionsTab
 {
 	Q_OBJECT
--- psi.orig/src/options/options.pri
+++ psi/src/options/options.pri
@@ -74,6 +74,7 @@ FORMS += \
 	$$PWD/opt_iconset_mood.ui \
 	$$PWD/opt_iconset_activity.ui \
 	$$PWD/opt_iconset_client.ui \
+	$$PWD/opt_iconset_affiliation.ui \
 	$$PWD/opt_iconset_system.ui \
 	$$PWD/opt_iconset_roster.ui \
 	$$PWD/opt_general_groupchat.ui \
--- psi.orig/src/psiaccount.cpp
+++ psi/src/psiaccount.cpp
@@ -6161,6 +6161,7 @@ void PsiAccount::invokeGCChat(const Jid 
 	u->setInList(false);
 	u->setName(j.resource());
 	u->setPrivate(true);
+	u->setAvatarFactory(avatarFactory());
 
 	// make a resource so the contact appears online
 	UserResource ur;
--- psi.orig/src/psichatdlg.cpp
+++ psi/src/psichatdlg.cpp
@@ -716,6 +716,7 @@ void PsiChatDlg::updateAvatar()
 	}
 
 	UserListItem *ul = account()->findFirstRelevant(jid());
+	bool private_ = false;
 	if (ul && !ul->userResourceList().isEmpty()) {
 		UserResourceList::Iterator it = ul->userResourceList().find(jid().resource());
 		if (it == ul->userResourceList().end())
@@ -723,9 +724,12 @@ void PsiChatDlg::updateAvatar()
 
 		res = (*it).name();
 		client = (*it).clientName();
+		private_ = ul->isPrivate();
 	}
 	//QPixmap p = account()->avatarFactory()->getAvatar(jid().withResource(res),client);
-	QPixmap p = account()->avatarFactory()->getAvatar(jid().withResource(res));
+	QPixmap p = private_ ?
+			account()->avatarFactory()->getMucAvatar(jid().withResource(res)) :
+			account()->avatarFactory()->getAvatar(jid().withResource(res));
 	if (p.isNull()) {
 		ui_.avatar->hide();
 	}
--- psi.orig/src/psicontactlistviewdelegate.cpp
+++ psi/src/psicontactlistviewdelegate.cpp
@@ -28,6 +28,7 @@
 #include "coloropt.h"
 #include "contactlistview.h"
 #include "common.h"
+#include "avatars.h"
 
 static const QString contactListFontOptionPath = "options.ui.look.font.contactlist";
 static const QString slimGroupsOptionPath = "options.ui.look.contactlist.use-slim-group-headings";
@@ -158,33 +159,12 @@ QList<QPixmap> PsiContactListViewDelegat
 
 QPixmap PsiContactListViewDelegate::avatarIcon(const QModelIndex& index) const
 {
-	QPixmap avatar_icon;
 	int avSize = showAvatars_ ? avatarSize_ : 0;
-	QPixmap av = qVariantValue<QPixmap>(index.data(ContactListModel::AvatarRole));
+	QPixmap av = index.data(ContactListModel::IsMucRole).toBool() ? QPixmap() : qVariantValue<QPixmap>(index.data(ContactListModel::AvatarRole));
 	if(av.isNull() && useDefaultAvatar_)
 		av = IconsetFactory::iconPixmap("psi/default_avatar");
-	int radius;
-	if (avSize && !av.isNull()) {
-		if ( (radius = avatarRadius_) ) {
-			avSize = qMax(avSize, radius*2);
-			av = av.scaled(avSize, avSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);
-			int w = av.width(), h = av.height();
-			QPainterPath pp;
-			pp.addRoundedRect(0, 0, w, h, radius, radius);
-			avatar_icon = QPixmap(w, h);
-			avatar_icon.fill(QColor(0,0,0,0));
-			QPainter mp(&avatar_icon);
-			mp.setBackgroundMode(Qt::TransparentMode);
-			mp.setRenderHints(QPainter::Antialiasing, true);
-			mp.fillPath(pp, QBrush(av));
-		} else {
-			avatar_icon = av.scaled(avSize, avSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);
-		}
-	} else {
-		avatar_icon = QPixmap();
-	}
 
-	return avatar_icon;
+	return AvatarFactory::roundedAvatar(av, avatarRadius_, avSize);
 }
 
 QSize PsiContactListViewDelegate::sizeHint(const QStyleOptionViewItem& /*option*/, const QModelIndex& index) const
--- psi.orig/src/psiiconset.cpp
+++ psi/src/psiiconset.cpp
@@ -42,8 +42,8 @@ class PsiIconset::Private
 private:
 	PsiIconset *psi;
 public:
-	Iconset system, moods, clients, activities;
-	QString cur_system, cur_status, cur_moods, cur_clients, cur_activity;
+	Iconset system, moods, clients, activities, affiliations;
+	QString cur_system, cur_status, cur_moods, cur_clients, cur_activity, cur_affiliations;
 	QStringList cur_emoticons;
 	QMap<QString, QString> cur_service_status;
 	QMap<QString, QString> cur_custom_status;
@@ -288,6 +288,23 @@ public:
 		return def;
 	}
 
+	Iconset affiliationsIconset(bool *ok)
+	{
+		Iconset def;
+		*ok = def.load( iconsetPath("affiliations/default") );
+
+		if ( PsiOptions::instance()->getOption("options.iconsets.affiliations").toString() != "default" ) {
+			Iconset is;
+			is.load ( iconsetPath("affiliations/" + PsiOptions::instance()->getOption("options.iconsets.affiliations").toString()) );
+
+			loadIconset(&def, &is);
+		}
+
+		stripFirstAnimFrame( def );
+
+		return def;
+	}
+
 	QList<Iconset*> emoticons()
 	{
 		QList<Iconset*> emo;
@@ -462,6 +479,21 @@ bool PsiIconset::loadClients()
 	return ok;
 }
 
+bool PsiIconset::loadAffiliations()
+{
+	bool ok = true;
+	QString cur_affiliations = PsiOptions::instance()->getOption("options.iconsets.affiliations").toString();
+	if (d->cur_affiliations != cur_affiliations) {
+		Iconset affiliations = d->affiliationsIconset(&ok);
+		d->loadIconset(&d->affiliations, &affiliations);
+		d->affiliations.addToFactory();
+
+		d->cur_affiliations = cur_affiliations;
+	}
+
+	return ok;
+}
+
 bool PsiIconset::loadAll()
 {
 	if (!loadSystem() || !loadRoster())
@@ -471,6 +503,7 @@ bool PsiIconset::loadAll()
 	loadMoods();
 	loadActivity();
 	loadClients();
+	loadAffiliations();
 	return true;
 }
 
@@ -491,6 +524,9 @@ void PsiIconset::optionChanged(const QSt
 	else if (option == "options.iconsets.clients") {
 		loadClients();
 	}
+	else if (option == "options.iconsets.affiliations") {
+		loadAffiliations();
+	}
 
 	// currently we rely on PsiCon calling reloadRoster() when
 	// all options are already applied. otherwise we risk the chance
--- psi.orig/src/psiiconset.h
+++ psi/src/psiiconset.h
@@ -47,6 +47,7 @@ public:
 	Iconset moods;
 	Iconset activities;
 	Iconset clients;
+	Iconset affiliations;
 	const Iconset &system() const;
 	void stripFirstAnimFrame(Iconset *);
 	static void removeAnimation(Iconset *);
@@ -103,6 +104,8 @@ private:
 	bool loadMoods();
 	bool loadActivity();
 	bool loadClients();
+	bool loadAffiliations();
+	
 };
 
 QString status2name(int s);
--- psi.orig/src/userlist.cpp
+++ psi/src/userlist.cpp
@@ -767,14 +767,18 @@ QString UserListItem::makeBareTip(bool t
 		mucItem = userResourceList()[0].status().hasMUCItem();
 	}
 
-	if (v_avatarFactory && !v_avatarFactory->getAvatar(jid().bare()).isNull() && PsiOptions::instance()->getOption("options.ui.contactlist.tooltip.avatar").toBool())
+	if (v_avatarFactory
+		&& (isPrivate() ? !v_avatarFactory->getMucAvatar(jid().full()).isNull() : !v_avatarFactory->getAvatar(jid().bare()).isNull())
+		&& PsiOptions::instance()->getOption("options.ui.contactlist.tooltip.avatar").toBool())
+	{
 		useAvatar = true;
+	}
 	
 	str += "<table cellspacing=\"3\"><tr>";
 	str += "<td>";
 
 	if (useAvatar) {
-		str += QString("<icon name=\"avatars/%1\">").arg(jid().bare());
+		str += QString("<icon name=\"avatars/%1\">").arg(isPrivate() ? Qt::escape(jid().full()) : jid().bare());
 		str += "</td><td width=\"10\"></td>";
 		str += "<td>";
 	}
